{"meta":{"title":"星云比特","subtitle":null,"description":null,"author":"xingyunbite","url":"http://xingyunbite.github.com"},"pages":[],"posts":[{"title":"以太坊，燃气，燃料 和 费用（翻译）","slug":"以太坊，燃气，燃料-和-费用","date":"2018-03-01T08:20:06.000Z","updated":"2018-03-01T09:32:39.881Z","comments":false,"path":"2018/03/01/以太坊，燃气，燃料-和-费用/","link":"","permalink":"http://xingyunbite.github.com/2018/03/01/以太坊，燃气，燃料-和-费用/","excerpt":"","text":"来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel &amp; Fees 以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。 使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。 燃气（gas）是什么？燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。 EVM 中的每个操作都会消耗燃气。例如，一个乘法（MUL）消耗 5 燃气而一个加法（ADD）消耗 3 燃气。以太坊操作的燃气消耗表格 将燃气看做是燃料的代名词 计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。 了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 (开始燃气 - 剩余燃气) * 燃气价格。 这里是一个关于交易燃料和交易费用的影响的总结： 燃料 费用 通常 EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。 每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH） 交易开始时 交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。 交易发起人必须支付所有燃料。放置 初始燃气 * 燃气价格 = 以太币 在托管中。 每个操作 剩余燃气会由于操作消耗而减少 知道交易完成（不论成功不成功），才会有后续的操作。 不成功的交易 剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销 所有托管的费用都会被支付给矿工 成功的交易 所有剩余的燃气会回退给交易发起人 （初始燃气 - 剩余燃气） * 燃气价格 = 费用 支付给矿工；剩余燃气 * 燃气价格 = 回退给交易发起人的费用。 在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。 简单的例子在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述： 操作消耗的燃气 剩余燃气 交易开始 150 存储 31 45 105 两个数相加 10 95 存储和 45 50 交易结束 数字 31 和 加法的和- -已经被存储写入区块链 交易发起人支付给矿工的费用是： （150–50) × 0.02µETH = 2µETH = 0.000002 ETH 燃料与费用交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响： 燃料 费用 太低 不会广播给矿工（错误：intrinsic gas too low） 矿工不会执行计算 低 少量计算或者燃料耗尽 之后会打包进区块 中等 通常是理想的 通常是理想的 高 可能导致打包被延迟 尽快被打包入区块 太高 不会广播给矿工（错误：exceeds block gas limit） 如果交易发起人没有足够的以太币，则不会广播给矿工 尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 高初始燃气可能会导致延迟 部分。 初始燃气让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分： 以太坊白皮书中使用了 初始燃气 以太坊黄皮书中使用了燃料限制 Geth 和 web3.js 等软件中，简单地使用了 “燃气”。 因为在通常情况下，不真正运行计算（关联 停机问题），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。 燃料耗尽异常一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和日志的写入）都会回滚。 让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图： 操作的燃料消耗 剩余燃料 交易开始 90 存储 31 45 45 求和 10 35 保存和 45 燃料耗尽 交易结束 因为燃料耗尽，存储的 31 会回滚 耗尽 在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为： 90 × 0.02µETH = 1.8µETH 当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。 燃气回退EVM 中有两个负值燃气的操作： 清空合约是 -24000 清空存储是 -15000 当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。 一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。 退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。 区块燃气限制（Block gas limit:BGL）回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。 高初始燃气可能存在的延迟既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？ 答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。 如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非内在气体也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。 绕过交易所以太坊有两种类型的账户： 用户账户（由私钥控制） 合约（由代码控制） 发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。 计量和费用关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。 比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。 结论燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括估计燃气，内在燃气（intrinsic gas），燃气价格预告（gas price oracle），交易大小的影响，读者可以在本文的基础上进一步地探索和理解。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"区块链 以太坊 燃料 gas 翻译","slug":"区块链-以太坊-燃料-gas-翻译","permalink":"http://xingyunbite.github.com/tags/区块链-以太坊-燃料-gas-翻译/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"比特币挖矿之矿工任务","slug":"比特币挖矿之矿工任务-1","date":"2018-02-28T03:10:09.000Z","updated":"2018-03-01T08:19:32.321Z","comments":false,"path":"2018/02/28/比特币挖矿之矿工任务-1/","link":"","permalink":"http://xingyunbite.github.com/2018/02/28/比特币挖矿之矿工任务-1/","excerpt":"","text":"挖矿介绍中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。 矿工任务考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。 区块头BlockHeader挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：123456int32_t nVersion; //版本号，4字节uint256 hashPrevBlock; //前一个区块的hash值，32字节uint256 hashMerkleRoot; //根据区块所包含交易构建的Merkle树根，32字节uint32_t nTime; //Uinx时间戳，4字节uint32_t nBits; //难度的压缩表示，4字节uint32_t nNonce; //随机数，4字节 比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：1SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits) 关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。","categories":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}],"tags":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/tags/矿池/"}],"keywords":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}]},{"title":"比特币挖矿之矿工任务","slug":"比特币挖矿之矿工任务","date":"2018-02-28T03:10:09.000Z","updated":"2018-02-28T09:16:21.349Z","comments":false,"path":"2018/02/28/比特币挖矿之矿工任务/","link":"","permalink":"http://xingyunbite.github.com/2018/02/28/比特币挖矿之矿工任务/","excerpt":"","text":"挖矿介绍中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。 矿工任务考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。 区块头BlockHeader挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：123456int32_t nVersion; //版本号，4字节uint256 hashPrevBlock; //前一个区块的hash值，32字节uint256 hashMerkleRoot; //根据区块所包含交易构建的Merkle树根，32字节uint32_t nTime; //Uinx时间戳，4字节uint32_t nBits; //难度的压缩表示，4字节uint32_t nNonce; //随机数，4字节 比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：1SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits) 关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。","categories":[],"tags":[],"keywords":[]},{"title":"以太坊wiki-设计原理翻译四","slug":"以太坊wiki-设计原理翻译四","date":"2018-02-24T03:01:05.000Z","updated":"2018-02-28T09:16:21.349Z","comments":false,"path":"2018/02/24/以太坊wiki-设计原理翻译四/","link":"","permalink":"http://xingyunbite.github.com/2018/02/24/以太坊wiki-设计原理翻译四/","excerpt":"","text":"以太坊wiki-设计原理翻译三 燃料和手续费比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。 交易手续费的基本机制如下： 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 startgas），以及愿意为每单位燃料支付的价格（gasprice）。在执行之初，startgas * gasprice 这么多的 ether 会从交易发送者的账户中被扣除。 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 gas_rem。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 gas_rem * gasprice，矿工会收到一笔 (startgas - gas_rem) * gasprice 的奖励。 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 startgas * gasprice 会被转给矿工。 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。 以上的每个部分都是必要的。例如： 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。 整个值 startgas * gasprice 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。 注意燃料消耗的特定的特性： 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。 SSTORE 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（CALLDATACOPY, CODECOPY, EXTCODECOPY）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（LOG 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 CALLDATACOPY 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料） 如果值非零，那么CALL 操作码（和对称的 CALLCODE）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。 燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。 目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。 虚拟机以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 虚拟机 和 合约 与 消息模型 分别看待，比如， SIGNEXTEND 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括： 简单：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。 完全明确：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。 节省空间：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。 期望的应用的专业能力（Specialization to expected applications）：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。 简单的安全：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。 优化友好：应该很容易优化，以便可以构建 JIT 编译的和其他速度更快的 VM 版本。 一些特殊的设计决定如下： 临时/永久存储的区别 - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 B.S[0] = 5，B.M[0] = 9，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 B.S[0]，它会获取到之前存储在 B 中的值，但是 B 树读取 B.M[0]，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 B.M[0] = 13 和 B.S[0] = 17，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 B.M[0] = 9(自上次设置此值在同一个 VM 执行实例中) 和 B.S[0] = 17。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 B.M[0] = 0 和 B.S[0] = 17。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。 栈/内存模型 - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 ADD R1 R2 R3:M[R1] = M[R2] + M[R3]。选择堆栈范例的原因很明显，它使代码缩小了四倍。 32 字节字大小 - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。 拥有我们自己的虚拟机 - 替代方案是使用 Java，或者一些 Lisp dialect，或者 Lua。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。 使用可变的可扩展内存大小 - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。 不限制堆栈大小 - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。 有一个 1024 层级深度的调用限制 - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。 没有类型 - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 DIV, SDIV, MOD, SMOD（事实证明，对于 ADD 和 MUL，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，a * b -&gt; (a * b) / 2^32，a / b -&gt; a * 2^32 / b 以及 +，- 和 * 在整数情况下保持不变。 虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下： ADDMOD, MULMOD：在大多数情况下，addmod(a, b, c) = a * b % c。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 a * b % c 实际上是 ((a * b) % 2 ^ 256) % c，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 a * b % c 的公式是十分普通和臃肿的。 SIGNEXTEND：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。 SHA3： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。 ORIGIN：提供交易发送人的 ORIGIN 操作码的主要用途是允许合约对燃料进行退款支付。 COINBASE：COINBASE 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。 PREVHASH：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。 EXTCODESIZE, EXTCODECOPY：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/ JUMPDEST：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。 LOG：LOG 表示记录事件，可见上面树的使用部分。 CALLCODE：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。 SELFDESTRUCT：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。 PC：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"区块链 以太坊","slug":"区块链-以太坊","permalink":"http://xingyunbite.github.com/tags/区块链-以太坊/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"以太坊wiki-设计原理翻译三","slug":"以太坊wiki-设计原理翻译三","date":"2018-02-24T02:39:17.000Z","updated":"2018-02-28T09:16:21.349Z","comments":false,"path":"2018/02/24/以太坊wiki-设计原理翻译三/","link":"","permalink":"http://xingyunbite.github.com/2018/02/24/以太坊wiki-设计原理翻译三/","excerpt":"","text":"以太坊wiki-设计原理翻译二 树的使用方式警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:http://en.wikipedia.org/wiki/Bloom_filter 以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 key 0:第一笔要执行的交易，key 1:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 RLP 编码的数据结构： [ medstate, gas_used, logbloom, logs ] 对应的： medstate 是处理交易之后的状态树的根。 gas_used 是处理该笔交易之后消耗的燃料数量。 logs 是交易执行过程中由 LOG0 ... LOG4 操作码生成的 [address, [topic1, topic2...], data]形式的项目列表（包括主调用和次调用）。address 是产生日志的合约的地址，topics 最多为 4 个 32 字节值，data 是任意大小的字节数组。 logbloom 是交易中所有的日志的 topics 和地址组成的布隆过滤器。 区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:light client page (principles section)。 叔块激励“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月首次推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。GHOST 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。 正如 Sompolinsky 和 Zohar 所描述的那样，GHOST 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。 为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。 在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 GHOST 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。 这里有一个可用的衡量集中化风险的仿真器:https://github.com/ethereum/economic-modeling/blob/master/ghost.py 一个更高级的讨论:https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/ 我们的区块时间算法中的设计决定包含： 12 秒出块时间：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的一篇文章测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。 7 个区块祖先限制：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。 一个区块后代限制（如，c(c(p(p(p(head)))))，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。 叔块验证要求：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 DAG）。 要求叔块的块合法也是一个有效的方法。 难度调整算法以太坊目前的难度调整规则如下： 12345diff(genesis) = 2^32diff(block) = diff.block.parent + floor(diff.block.parent / 1024) * 1 if block.timestamp - block.parent.timestamp &lt; 9 else -1 if block.timestamp - block.parent.timestamp &gt;= 9 难度调整规则的设计目标是： 快速更新：区块之间的时间的调整要快。 稳定：如果算力不变，难度不应该过大。 简单：算法实现要简单。 占用内存低：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。 非开发性：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。 我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"区块链 以太坊","slug":"区块链-以太坊","permalink":"http://xingyunbite.github.com/tags/区块链-以太坊/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"比特币挖矿之全网难度","slug":"比特币挖矿之全网难度","date":"2018-02-09T04:24:39.000Z","updated":"2018-02-28T09:16:21.349Z","comments":false,"path":"2018/02/09/比特币挖矿之全网难度/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/比特币挖矿之全网难度/","excerpt":"","text":"2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？ 目标值（target）上文中提到，矿工在打包区块的时候，合格的区块应该满足:1SHA256(SHA256(BlockHeader))&lt;target 在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。1target = bits_coefficient * 2^(8 * (bits_exponent-3)) 以508230区块为例，此区块对应的bits为0x1761e9f8123target = 0x61e9f8 *2^(0x08*(0x17-3)) = 0x61e9f8 *2^(0x08*0x14) = 0x61e9f8 *2^0xA0 按十进制计算为:1target = 6,416,888 * 2^160 转换为十六进制后为:1target =0x00000000000000000061e9f80000000000000000000000000000000000000000 而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。 难度（difficulty）难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：12345678910111213141516171819202122232425262728double GetDifficulty(const CBlockIndex* blockindex)&#123; if (blockindex == NULL) &#123; if (chainActive.Tip() == NULL) return 1.0; else blockindex = chainActive.Tip(); &#125; int nShift = (blockindex-&gt;nBits &gt;&gt; 24) &amp; 0xff; double dDiff = (double)0x0000ffff / (double)(blockindex-&gt;nBits &amp;0x00ffffff); while (nShift &lt; 29) &#123; dDiff *= 256.0; nShift++; &#125; while (nShift &gt; 29) &#123; dDiff /= 256.0; nShift--; &#125; return dDiff;&#125; 创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:1difficulty = difficulty_1_target/current_target 其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。同样以508230区块为例:1234difficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000000000061e9f80000000000000000000000000000000000000000 = 2.87 * 10^12 = 2.87 T 难度调整上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？ 比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：1New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes) 通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。 在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断1、当高度不是2016的倍数时，会直接返回上一个区块的bit2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。具体代码实现如下：12345678910111213141516171819202122232425unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)&#123; if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; // Limit adjustment step int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); &#125;&#125; 为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。","categories":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}],"tags":[{"name":"bitcoin 比特币","slug":"bitcoin-比特币","permalink":"http://xingyunbite.github.com/tags/bitcoin-比特币/"}],"keywords":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}]},{"title":"以太坊wiki-设计原理翻译一","slug":"以太坊wiki-设计原理翻译一","date":"2018-02-09T03:22:26.000Z","updated":"2018-02-28T09:16:21.345Z","comments":false,"path":"2018/02/09/以太坊wiki-设计原理翻译一/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/以太坊wiki-设计原理翻译一/","excerpt":"","text":"设计原理原文链接尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。 原则以太坊协议的设计过程遵循了下列原则： 三明治复杂模型：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，leveldb存储接口和有线协议等。但是，这种偏好并不是绝对的。 自由：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 OP_RETURN 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 Ethereum 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（bloat-producing）的方式内部化其活动成本（即 Pigovian 税）。 概念：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 LOG 操作码作为向（特别是轻客户端）dapps 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。 我们没有特征：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。 非风险规避：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。 这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。 区块链层次的协议这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。 账户和非 UTXOs比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 unspent transaction outputs(UTXOs) 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有： 每一个被引用的输入必须是合法的并且没有被花费过 交易中的每一个输入都必须有一个符合该输入的主人的签名 所有的输入必须大于等于所有的输出 因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。 (图片来自 https://bitcoin.org/en/developer-guide) 以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。 UTXOs 的好处： 高度的隐私性：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 dapps 就不是那么合适了，因为 dapps 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。 潜在的可扩展性范例：UTXO 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 Merkle 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 Merkle 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 UTXO 依赖的可伸缩性范例确实存在。 账户的好处： 节省了大量空间：例如，如果一个账户有 5 个 UTXO，然后将一个 UTXO 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 txid，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 nonce)。实际上，要求的存储空间没有这么大，因为账户需要存储在 Patricia 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。 更好的可替代性：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。 简单：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 UTXO 模型来实现 dapp，但本质上是通过赋予脚本能力，来限制给定的 UTXO 可以以哪种 UTXO 类型来花费，并且需要花费包括根据脚本评估的 Merkle 树中的应用程序状态改变的证明的 Merkle 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。 持久的轻客户端引用：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 UTXO 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 UTXO 状态传播机制的长期运行的 dapps 来说，这是一个特别麻烦的问题。 我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 dapps 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。 账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 nonce 值，这样账户就可以对使用的 nonce 进行跟踪，并且只接受当前 nonce 值比之前的 nonce 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 nonce。矿工或者其他用户会对账户进行 ping 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 1.0 的发展; 1.1 及以后可能会使用这样一个系统。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"以太坊 ethereum","slug":"以太坊-ethereum","permalink":"http://xingyunbite.github.com/tags/以太坊-ethereum/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"以太坊wiki-设计原理翻译二","slug":"以太坊wiki-设计原理翻译二","date":"2018-02-08T18:10:31.000Z","updated":"2018-02-28T09:16:21.349Z","comments":false,"path":"2018/02/09/以太坊wiki-设计原理翻译二/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/以太坊wiki-设计原理翻译二/","excerpt":"","text":"以太坊wiki-设计原理翻译一 默克尔帕夏里克树默克尔帕夏里克树（Merkle Patricia tree/trie），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。MPT 是 Merkle tree 和 Patricia tree 的结合，以两者的元素来创建具有以下两个属性的结构： 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力） 在对数时间内进行修改，添加和删除键值对。 这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 MPT 的正式描述如下：https://github.com/ethereum/wiki/wiki/Patricia-Tree MPT 中详细的设计决定包括： 拥有两种节点类别：kv 节点和分叉节点（从 MPT 详解中获得更多信息）。kv 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，kv 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。 使分叉节点为 6 而不是 2：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 1.1。 空值和“没有成员”之间没有区别：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。 终止和非终止节点之间的区别：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 MPT 的实现方式。 使用 sha3(k) 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 SLOAD 和 SSTORE」这样的方式，对树进行 DoS 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 sha3（k） - &gt; k。 RLPRLP（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。RLP 的正式描述如下：https://github.com/ethereum/wiki/wiki/RLP RLP 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 protobuf，BSON 和其他解决方式，RLP 并不想定义任何具体的数据类型，如 booleans, floats, doubles 或者 integers，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为[[k1，v1]，[k2，v2]，...]，其中 k1，k2 ... 使用字符串的标准排序来排序。 RLP 的备选方案可以使用已经存在的算法如 protobuf 或者 BSON，但我们更青睐 RLP 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 VM）。注意 BitTorrent 使用的 bencode，可能为 RLP 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 RLP 相比稍微不太理想。 压缩算法有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（run-length-encoding zeroes），并保留其他值，除了像 sha3（&#39;&#39;） 这样的常见值的一些特殊情况例外。例如： 1234567&gt;&gt;&gt; compress(&apos;horse&apos;)&apos;horse&apos;&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)&apos;donkey dragon 1231231243&apos;&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos; 在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，sha3 常常被覆盖，这样 sha3(&#39;&#39;)=&#39;&#39;，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"区块链 以太坊 ethereum","slug":"区块链-以太坊-ethereum","permalink":"http://xingyunbite.github.com/tags/区块链-以太坊-ethereum/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"linux下Zcash钱包使用教程","slug":"linux下Zcash钱包使用教程","date":"2018-02-08T11:04:15.000Z","updated":"2018-02-28T09:16:21.345Z","comments":false,"path":"2018/02/08/linux下Zcash钱包使用教程/","link":"","permalink":"http://xingyunbite.github.com/2018/02/08/linux下Zcash钱包使用教程/","excerpt":"","text":"Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥. ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的. 目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。 现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。 下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gzhash : 352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a 下载后请务必进行哈希值验证，以保证文件的真实和准确性。 tar -xvf zcash-1.0.14-linux64.tar.gz //解压缩mv -t /usr/local/bin/ zcash-1.0.14/bin/* //移动可执行文件 现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。 zcash-fetch-params 这里由于国内网络的原因，可能会失败，请多试几次。 验证通过后，我们需要对客户端进行配置。 mkdir ~/.zcash //创建zcash目录 vim zcash.conf 以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。 //这是测试链接的配置 addnode=testnet.z.cash //节点 rpcuser=test //rpc用户名 rpcpassword=test //rpc密码 gen=0 //屏蔽cpu挖矿 testnet=1 //开启测试链 rpcallowip=100.100.60.10 //允许访问的IP rpcport=8333 //rpc端口号 equihashsolver=tromp //指定算法，非挖矿钱包可以删除 好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。 下面提供一些zcash节点常用命令： zcash-cli getinfo //显示节点信息 zcashd -daemon //后台启动zcash守护 zcash-cli getnetworkhashps //获取全网算力 zcash-cli z_getnewaddress //生成一个Z-addr zcash-cli getnewaddress //生成一个t-addr zcas-cli getblockhash //区块高度 zcash-cli getaddressesbyaccount &quot;&quot; //显示所有t-addr钱包 zcash-cli z_listaddresses //显示所有Z-addr钱包 zcash-cli z_getbalance &quot;&quot; //z钱包余额 如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。 附1： zcash钱包配置： //这里是zcash钱包主链配置 rpcuser=rpc用户名 rpcpassword=rpc密码 rpcport=rpc端口 rpcallowip=允许链接rpc ip地址 server=1 //打开服务 daemon=1 //后台运行守护 mainnet=1 //主链 addnode=mainnet.z.cash //主链节点 附2： //zcash命令 == Blockchain == getbestblockhash getblock &quot;hash|height&quot; ( verbose ) getblockchaininfo getblockcount getblockhash index getblockheader &quot;hash&quot; ( verbose ) getchaintips getdifficultygetmempoolinfogetrawmempool ( verbose ) gettxout “txid” n ( includemempool ) gettxoutproof [“txid”,…] ( blockhash ) gettxoutsetinfo verifychain ( checklevel numblocks ) verifytxoutproof “proof” == Control == getinfo help ( &quot;command&quot; ) stop == Disclosure == z_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) z_validatepaymentdisclosure &quot;paymentdisclosure&quot; == Generating == generate numblocks getgenerate setgenerate generate ( genproclimit ) == Mining == getblocksubsidy height getblocktemplate ( &quot;jsonrequestobject&quot; ) getlocalsolps getmininginfo getnetworkhashps ( blocks height ) getnetworksolps ( blocks height ) prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt; submitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; ) == Network == addnode &quot;node&quot; &quot;add|remove|onetry&quot; clearbanned disconnectnode &quot;node&quot; getaddednodeinfo dns ( &quot;node&quot; ) getconnectioncount getnettotals getnetworkinfo getpeerinfo listbanned ping setban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute) == Rawtransactions == createrawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...} decoderawtransaction &quot;hexstring&quot; decodescript &quot;hex&quot; fundrawtransaction &quot;hexstring&quot; getrawtransaction &quot;txid&quot; ( verbose ) sendrawtransaction &quot;hexstring&quot; ( allowhighfees ) signrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype ) == Util == createmultisig nrequired [&quot;key&quot;,...] estimatefee nblocks estimatepriority nblocks validateaddress &quot;zcashaddress&quot; verifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot; z_validateaddress &quot;zaddr&quot; == Wallet == addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; ) backupwallet &quot;destination&quot; dumpprivkey &quot;zcashaddress&quot; dumpwallet &quot;filename&quot; encryptwallet &quot;passphrase&quot; getaccount &quot;zcashaddress&quot; getaccountaddress &quot;account&quot; getaddressesbyaccount &quot;account&quot; getbalance ( &quot;account&quot; minconf includeWatchonly ) getnewaddress ( &quot;account&quot; ) getrawchangeaddress getreceivedbyaccount &quot;account&quot; ( minconf ) getreceivedbyaddress &quot;zcashaddress&quot; ( minconf ) gettransaction &quot;txid&quot; ( includeWatchonly ) getunconfirmedbalance getwalletinfo importaddress &quot;address&quot; ( &quot;label&quot; rescan ) importprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan ) importwallet &quot;filename&quot; keypoolrefill ( newsize ) listaccounts ( minconf includeWatchonly) listaddressgroupings listlockunspent listreceivedbyaccount ( minconf includeempty includeWatchonly) listreceivedbyaddress ( minconf includeempty includeWatchonly) listsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly) listtransactions ( &quot;account&quot; count from includeWatchonly) listunspent ( minconf maxconf [&quot;address&quot;,...] ) lockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...] move &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; ) sendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; ) sendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] ) sendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount ) setaccount &quot;zcashaddress&quot; &quot;account&quot; settxfee amount signmessage &quot;zcashaddress&quot; &quot;message&quot; z_exportkey &quot;zaddr&quot; z_exportviewingkey &quot;zaddr&quot; z_exportwallet &quot;filename&quot; z_getbalance &quot;address&quot; ( minconf ) z_getnewaddress z_getoperationresult ([&quot;operationid&quot;, ... ]) z_getoperationstatus ([&quot;operationid&quot;, ... ]) z_gettotalbalance ( minconf includeWatchonly ) z_importkey &quot;zkey&quot; ( rescan startHeight ) z_importviewingkey &quot;vkey&quot; ( rescan startHeight ) z_importwallet &quot;filename&quot; z_listaddresses ( includeWatchonly ) z_listoperationids z_listreceivedbyaddress &quot;address&quot; ( minconf ) z_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee ) z_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit ) zcbenchmark benchmarktype samplecount zcrawjoinsplit rawtx inputs outputs vpub_old vpub_new zcrawkeygen zcrawreceive zcsecretkey encryptednote zcsamplejoinsplit","categories":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}],"tags":[{"name":"zcash 矿池","slug":"zcash-矿池","permalink":"http://xingyunbite.github.com/tags/zcash-矿池/"}],"keywords":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}]}]}