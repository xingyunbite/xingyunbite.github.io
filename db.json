{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/snippet/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/branding.png","path":"img/branding.png","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":1,"renderable":1},{"_id":"themes/snippet/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/snippet/.travis.yml","hash":"8b868cf1653a88ff06ebb776d7441c7a0e0f194b","modified":1518084196325},{"_id":"themes/snippet/LICENSE","hash":"c720db99e36a717d9808bf97b736612462e883dd","modified":1518084196325},{"_id":"themes/snippet/README.md","hash":"4c6f1d4892eb6fdb6e375ad5d1cd44b50a61e9e2","modified":1518084196325},{"_id":"themes/snippet/_config.yml","hash":"c8077f225796071dfb7dc8b2f8c91633b3e01493","modified":1519369036539},{"_id":"themes/snippet/_config1.yml","hash":"c65b4a58b94b9d53a75d5c46f6548e99c1f4c7d6","modified":1518084196325},{"_id":"themes/snippet/_travis.sh","hash":"6f28564a4a83aed0e5cbe2969a07fa28ada6e1f4","modified":1518084196325},{"_id":"themes/snippet/gulpfile.js","hash":"876e7ff1359e589ec99ad29a7182d076831a6655","modified":1518084196325},{"_id":"themes/snippet/package.json","hash":"2ac1a7806f43b75a7e0111e4f6b89008528a5407","modified":1518084196329},{"_id":"source/_posts/linux下Zcash钱包使用教程.md","hash":"e6fa5b61888d48b6882d1c935623089b8af80ece","modified":1518170988544},{"_id":"source/_posts/test.md","hash":"e12ddf5c15241f08e7c1755797d0a24a30af8e7c","modified":1519793245972},{"_id":"source/_posts/以太坊wiki-设计原理翻译一.md","hash":"fb30459e01429bbd7c6ae0bdc73a9cc90de6000d","modified":1518170908046},{"_id":"source/_posts/以太坊wiki-设计原理翻译三.md","hash":"a4b99ec4df6fb39d9fa957376401e45e3b55b32b","modified":1519441252525},{"_id":"source/_posts/以太坊wiki-设计原理翻译二.md","hash":"6f02280714493f07a528aa6de17776dbb9be2a6e","modified":1519439589369},{"_id":"source/_posts/以太坊wiki-设计原理翻译四.md","hash":"9b788ca203a53f414b9f3179bb5d42f678403f33","modified":1519444116078},{"_id":"source/_posts/比特币挖矿之全网难度.md","hash":"2cc4f2b88fc3ab72f01d725a14537174bf8f1097","modified":1518170854484},{"_id":"themes/snippet/languages/default.yml","hash":"3514b76f1f39009803abe47d1be22d5a6012e398","modified":1518084196325},{"_id":"themes/snippet/languages/zh-CN.yml","hash":"1baa7ea790a0011706bb7eca308b87dd9991ee8d","modified":1518084196325},{"_id":"themes/snippet/languages/zh-TW.yml","hash":"0c7591ce46476677c0903c160817454566f7e978","modified":1518084196325},{"_id":"themes/snippet/layout/archive.ejs","hash":"c42bc18ba370905c813981e3f6681e09b6a5857d","modified":1518084196329},{"_id":"themes/snippet/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1518084196329},{"_id":"themes/snippet/layout/index.ejs","hash":"bc1a4dbde309dfc7618486a6e8ffc59604814124","modified":1518084196329},{"_id":"themes/snippet/layout/layout.ejs","hash":"a8a1c39ca9b0f961690dd0ac0f174475c9f71288","modified":1518084196329},{"_id":"themes/snippet/layout/page.ejs","hash":"3036c21565da3964f472c5867e6acc3453d0d316","modified":1518084196329},{"_id":"themes/snippet/layout/post.ejs","hash":"27bfa699d73929dace550d61f2010a9187213a0f","modified":1518084196329},{"_id":"themes/snippet/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1518084196329},{"_id":"themes/snippet/scripts/helper.js","hash":"836d369cf95ac51de957e09d396e6a8be1e84cf6","modified":1518084196329},{"_id":"themes/snippet/scripts/process.js","hash":"c2f0571899a6dd38bd944aaf47e21fc650f7d52e","modified":1518084196329},{"_id":"themes/snippet/source/favicon.ico","hash":"107ca59f31dbe89dcb4aaeea95b22ead3ffd53bb","modified":1519444318028},{"_id":"themes/snippet/layout/_partial/archive.ejs","hash":"17f5e3d17bc6bd9def8203ce1cb695b25603c12b","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/article-meta.ejs","hash":"d0606be951c92c5af7cb8ce68b43ea62390471bd","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/copyright.ejs","hash":"4c35b1071a3b426233190db28f552c50ff71a299","modified":1519374717096},{"_id":"themes/snippet/layout/_partial/footer.ejs","hash":"1f0417b44c8617e0a4f500c17c639ccc1d329a5b","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/gallery.ejs","hash":"1b6b7859f395e10a3ecaa900de2d1312dc140def","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/head.ejs","hash":"1aea0e44f11d9f6f3e78f0da7dba0f35b910e6c3","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/header.ejs","hash":"b1ae20eb0901a77faffe338af959da29e17f8dbd","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/nav.ejs","hash":"4276098a03b1392d70cc73bbdbd49d1a299c1344","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/pagination.ejs","hash":"2ec88a22fd29e7cc97ca2a508eee7d168e338969","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/script.ejs","hash":"4deb486529a91e79cf067aeac7befaef79894d75","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/sidebar.ejs","hash":"f2ad132c8a0eae0a8b1f868bf4dda730ebeab82c","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/baidu_sitemap.ejs","hash":"f17db411dc1607e7d1eb133b7b7dfe5b575cabad","modified":1518084196325},{"_id":"themes/snippet/layout/_widget/archive.ejs","hash":"906cc9b37734fd17b9c70d0089fd5a9b8178f6b1","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/category.ejs","hash":"1c6881cd5b6b034ddecda6c85a3337d17a03e9ff","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/friends.ejs","hash":"43b0404d608db1a237b3cf17ec8df7b2d24f9533","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/notification.ejs","hash":"6e75cc9fbee74d7cd4e9b26e62475f6113205585","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/search.ejs","hash":"2b6a0e7d07032920211dedec0be6844728e9b17f","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/social.ejs","hash":"f97313cdc1b495f7602e023b2ade5630acc4b667","modified":1518084196329},{"_id":"themes/snippet/layout/_widget/tagcloud.ejs","hash":"457b6081e2f24afd5c4c3a2d566c1f5940f3f21a","modified":1518084196329},{"_id":"themes/snippet/source/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1518084196329},{"_id":"themes/snippet/source/css/style.css","hash":"e1fc8aa20dede36c08bde6330ab2a7f36e31aa48","modified":1518084196333},{"_id":"themes/snippet/source/img/avatar.jpg","hash":"1e195d1fc20c180d6a54e6f90ce3762ef3f6d9af","modified":1519373969690},{"_id":"themes/snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1518084196341},{"_id":"themes/snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1518084196341},{"_id":"themes/snippet/source/js/app.js","hash":"41fe02b22201e3be72dcebfb05cac8cbfae8d85f","modified":1518084196341},{"_id":"themes/snippet/source/js/search.js","hash":"b806e6ac8b92750113033d4ab0cc598953c3d5ac","modified":1518084196341},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1518084196337},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1518084196337},{"_id":"themes/snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1518084196341},{"_id":"themes/snippet/layout/_partial/_head-sections/IE.ejs","hash":"567494a97ba2db7bb452294a9980b4d63b399ef0","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/_head-sections/seo.ejs","hash":"f80ec948f4f23763a1bf9b71efef6d6ebc6fc5d5","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/_head-sections/style.ejs","hash":"fc4d4fcfdc68719b4fa2b17117dd1a8638ca2299","modified":1518084196325},{"_id":"themes/snippet/layout/_partial/_head-sections/title.ejs","hash":"1482f56c44221cbc0d28ba06e377f4b55cdaacc2","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/analytics/baidu.ejs","hash":"eb4a75fb5ba9237d93430e727165d98ccda75a02","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/analytics/cnzz.ejs","hash":"8bfc514b178fafd81cc8181880afc5c9cbee02dc","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/analytics/google.ejs","hash":"91844d4521f97517ea9f169ee85b18c9d0d8cf17","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/analytics/index.ejs","hash":"6315abe9c31f4c4de719fa3cbfa2b1c6f294b0de","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/analytics/tencent.ejs","hash":"6a3d3c479ef08b735827caa63791879c6972b2ca","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/comments/changyan.ejs","hash":"202c94162ac2eeb0c93c8d2667c82b8705de6390","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/comments/disqus.ejs","hash":"7b5e05154be0408be110893439bfa33e262245de","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/comments/gitment.ejs","hash":"be5c261ae8a769747704a228aa35758120b814e1","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/comments/index.ejs","hash":"91ce022b7a379f3d1b53cf3b13612c2645a16139","modified":1518084196325},{"_id":"themes/snippet/layout/_vendor/comments/livere.ejs","hash":"6333308ba24ae6f2a3e73f4cdc1b42e024d19910","modified":1518084196329},{"_id":"themes/snippet/layout/_vendor/comments/uyan.ejs","hash":"2c2abe17f4f5c5ba1a9aaa948ef0a88d99f653f8","modified":1518084196329},{"_id":"themes/snippet/source/css/less/_highlight.less","hash":"c799cfa32c323c33a09569d326786874026fd1ef","modified":1518084196329},{"_id":"themes/snippet/source/css/less/_mixins.less","hash":"e89dc55772b5ae6bfd4cac3b5c32bf9ce73ac805","modified":1518084196329},{"_id":"themes/snippet/source/css/less/_style.less","hash":"c4bd243fe7470fcf2543c5fa970c359c5e5d45fe","modified":1518084196329},{"_id":"themes/snippet/source/css/less/_variable.less","hash":"b06c46ac56dbb8cd75ac13310479c643d5087d9b","modified":1518084196329},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1518084196333},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1518084196333},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1518084196337},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1518084196337}],"Category":[{"name":"矿池","_id":"cje6lnsz80002psjxhg8qyj3m"},{"name":"区块链","_id":"cje6lnt0f0007psjxzlxl8lpo"}],"Data":[],"Page":[],"Post":[{"title":"linux下Zcash钱包使用教程","comments":0,"date":"2018-02-08T11:04:15.000Z","img":null,"_content":"\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","source":"_posts/linux下Zcash钱包使用教程.md","raw":"---\ntitle: linux下Zcash钱包使用教程\ncomments: false\ndate: 2018-02-08 19:04:15\ncategories: 矿池\ntags: zcash 矿池\nimg:\n---\n\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","slug":"linux下Zcash钱包使用教程","published":1,"updated":"2018-02-09T10:09:48.544Z","layout":"post","photos":[],"link":"","_id":"cje6lnsy90000psjxfm4iblqx","content":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>"},{"title":"test","comments":0,"date":"2018-02-28T04:46:57.000Z","img":null,"_content":"\n# zcash矿池之Z-NOMP(Node Open Mining Portal)\n\n------\n\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\n  z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n    **警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\t  \n\t  首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n\t    \n\t    1.安装z-nomp依赖：\n\t\t``` \n\t\t    sudo apt-get install update\n\t\t\t    sudo apt-get install build-essential libsodium-dev npm git\n\t\t\t\t    sudo npm install n -g\n\t\t\t\t\t    sudo n 8.9.4\n\t\t\t\t\t\t```\n\t\t\t\t\t\t2.下载和安装z-nomp：\n\t\t\t\t\t\t```\n\t\t\t\t\t\t    git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\t\t\t\t\t\t\t    cd /pool\n\t\t\t\t\t\t\t\t    npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\t\t\t\t\t\t\t\t\t    npm update\n\t\t\t\t\t\t\t\t\t\t    sudo npm install   #就算root账户也一定要加sudo\n\t\t\t\t\t\t\t\t\t\t\t```    \n\n\t\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t\t3.矿池配置文件：\n\n\t\t\t\t\t\t\t\t\t\t\t修改示例文件config_example.json。\n\t\t\t\t\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\t\t\t\t    mv config_example.json config.json\n\t\t\t\t\t\t\t\t\t\t\t\t    vim config.json\n\t\t\t\t\t\t\t\t\t\t\t\t\t```    \n\t\t\t\t\t\t\t\t\t\t\t\t\t下面提供一些主要配置说明：\n\t\t\t\t\t\t\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\t\t\t\t\t\t            \"redis\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"host\": \"127.0.0.1\",   #redis地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"port\": 6379,          #redis端口\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"password\": \"\"      #redis密码\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        }\n    },\n\t    \n\t       \"website\": {\n\t\t\t           \"enabled\": true,\n\t\t\t\t\t           \"host\": \"0.0.0.0\",                 #website地址\n\t\t\t\t\t\t\t\t           \"port\": 8080,                      #website端口\n\t\t\t\t\t\t\t\t\t\t           \"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\t\t\t\t\t\t\t\t\t\t           \"stats\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"updateInterval\": 30,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"historicalRetention\": 14400,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"hashrateWindow\": 300\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           },\n\t\t\t\t\t\t\t           \n\t\t\t\t\t\t\t               \"tlsOptions\" : {\n\t\t\t\t\t\t\t\t\t\t\t               \"enabled\": false,          #ssl挖矿\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"cert\": \"\",                #ssl公钥地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"key\": \"\"                  #ssl私钥地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           }\n\t\t\t\t\t       },\n\t\t\t\t\t\t   ```    \n\t\t\t\t\t\t   4.数字货币配置：\n\n\t\t\t\t\t\t   进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\t\t\t\t\t\t   ```\n\t\t\t\t\t\t       cd pool_config\n\t\t\t\t\t\t\t       mv zcash_example.json zcash.json\n\t\t\t\t\t\t\t\t       vim zcash.json\n\t\t\t\t\t\t\t\t\t   ```    \n\t\t\t\t\t\t\t\t\t   主要配置文件说明：\n\t\t\t\t\t\t\t\t\t   ```\n\t\t\t\t\t\t\t\t\t       \"enabled\": true,         #设置打开coin\n\t\t\t\t\t\t\t\t\t\t       \"coin\": \"zcash.json\",    #coin配置文件\n\t\t\t\t\t\t\t\t\t\t\t       \"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\t\t\t\t\t\t\t\t\t\t\t       \"zAddress\": \"\",          #Z地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t       \"tAddress\": \"\",          #T地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t       \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"rewardRecipients\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"\": 0.2,             #手续费和接收手续费地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"paymentProcessing\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \"minConf\": 10,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"enabled\": false,             #支付进程\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"paymentMode\": \"prop\",        #挖矿模式\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"paymentInterval\": 20, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"minimumPayment\": 0.1,         #最低支付额\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"maxBlocksPerPayment\": 1,     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"host\": \"127.0.0.1\",       \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"port\": 19332,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"user\": \"testuser\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"password\": \"testpass\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"ports\": {                 #支付端口和难度\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"3032\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"diff\": 0.05,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"tls\": false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"varDiff\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"minDiff\": 0.04,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"maxDiff\": 16,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"targetTime\": 15,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"retargetTime\": 60,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"variancePercent\": 30\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"host\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"port\": 18232,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"user\": \"rpcuser\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"password\": \"rpcpassword\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n    ],\n\t```    \n\t5.coin配置：\n\n\t进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\n\n\tok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","source":"_posts/test.md","raw":"---\ntitle: test\ncomments: false\ndate: 2018-02-28 12:46:57\ncategories:\ntags:\nimg:\n---\n\n# zcash矿池之Z-NOMP(Node Open Mining Portal)\n\n------\n\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\n  z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n    **警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\t  \n\t  首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n\t    \n\t    1.安装z-nomp依赖：\n\t\t``` \n\t\t    sudo apt-get install update\n\t\t\t    sudo apt-get install build-essential libsodium-dev npm git\n\t\t\t\t    sudo npm install n -g\n\t\t\t\t\t    sudo n 8.9.4\n\t\t\t\t\t\t```\n\t\t\t\t\t\t2.下载和安装z-nomp：\n\t\t\t\t\t\t```\n\t\t\t\t\t\t    git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\t\t\t\t\t\t\t    cd /pool\n\t\t\t\t\t\t\t\t    npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\t\t\t\t\t\t\t\t\t    npm update\n\t\t\t\t\t\t\t\t\t\t    sudo npm install   #就算root账户也一定要加sudo\n\t\t\t\t\t\t\t\t\t\t\t```    \n\n\t\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t\t3.矿池配置文件：\n\n\t\t\t\t\t\t\t\t\t\t\t修改示例文件config_example.json。\n\t\t\t\t\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\t\t\t\t    mv config_example.json config.json\n\t\t\t\t\t\t\t\t\t\t\t\t    vim config.json\n\t\t\t\t\t\t\t\t\t\t\t\t\t```    \n\t\t\t\t\t\t\t\t\t\t\t\t\t下面提供一些主要配置说明：\n\t\t\t\t\t\t\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\t\t\t\t\t\t            \"redis\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"host\": \"127.0.0.1\",   #redis地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"port\": 6379,          #redis端口\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            \"password\": \"\"      #redis密码\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        }\n    },\n\t    \n\t       \"website\": {\n\t\t\t           \"enabled\": true,\n\t\t\t\t\t           \"host\": \"0.0.0.0\",                 #website地址\n\t\t\t\t\t\t\t\t           \"port\": 8080,                      #website端口\n\t\t\t\t\t\t\t\t\t\t           \"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\t\t\t\t\t\t\t\t\t\t           \"stats\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"updateInterval\": 30,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"historicalRetention\": 14400,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"hashrateWindow\": 300\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           },\n\t\t\t\t\t\t\t           \n\t\t\t\t\t\t\t               \"tlsOptions\" : {\n\t\t\t\t\t\t\t\t\t\t\t               \"enabled\": false,          #ssl挖矿\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"cert\": \"\",                #ssl公钥地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \"key\": \"\"                  #ssl私钥地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           }\n\t\t\t\t\t       },\n\t\t\t\t\t\t   ```    \n\t\t\t\t\t\t   4.数字货币配置：\n\n\t\t\t\t\t\t   进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\t\t\t\t\t\t   ```\n\t\t\t\t\t\t       cd pool_config\n\t\t\t\t\t\t\t       mv zcash_example.json zcash.json\n\t\t\t\t\t\t\t\t       vim zcash.json\n\t\t\t\t\t\t\t\t\t   ```    \n\t\t\t\t\t\t\t\t\t   主要配置文件说明：\n\t\t\t\t\t\t\t\t\t   ```\n\t\t\t\t\t\t\t\t\t       \"enabled\": true,         #设置打开coin\n\t\t\t\t\t\t\t\t\t\t       \"coin\": \"zcash.json\",    #coin配置文件\n\t\t\t\t\t\t\t\t\t\t\t       \"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\t\t\t\t\t\t\t\t\t\t\t       \"zAddress\": \"\",          #Z地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t       \"tAddress\": \"\",          #T地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t       \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"rewardRecipients\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"\": 0.2,             #手续费和接收手续费地址\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           \"paymentProcessing\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \"minConf\": 10,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"enabled\": false,             #支付进程\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"paymentMode\": \"prop\",        #挖矿模式\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"paymentInterval\": 20, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"minimumPayment\": 0.1,         #最低支付额\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"maxBlocksPerPayment\": 1,     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"host\": \"127.0.0.1\",       \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"port\": 19332,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"user\": \"testuser\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"password\": \"testpass\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"ports\": {                 #支付端口和难度\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"3032\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"diff\": 0.05,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"tls\": false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"varDiff\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"minDiff\": 0.04,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"maxDiff\": 16,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"targetTime\": 15,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"retargetTime\": 60,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                 \"variancePercent\": 30\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     \"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"host\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"port\": 18232,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"user\": \"rpcuser\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             \"password\": \"rpcpassword\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         }\n    ],\n\t```    \n\t5.coin配置：\n\n\t进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\n\n\tok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","slug":"test","published":1,"updated":"2018-02-28T04:47:25.972Z","layout":"post","photos":[],"link":"","_id":"cje6lnsys0001psjxo31h9tys","content":"<h1 id=\"zcash矿池之Z-NOMP-Node-Open-Mining-Portal\"><a href=\"#zcash矿池之Z-NOMP-Node-Open-Mining-Portal\" class=\"headerlink\" title=\"zcash矿池之Z-NOMP(Node Open Mining Portal)\"></a>zcash矿池之Z-NOMP(Node Open Mining Portal)</h1><hr>\n<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>  z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<pre><code>**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n  首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n\n    1.安装z-nomp依赖：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\"> sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">  sudo npm install n -g</span><br><span class=\"line\">   sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n\n                    2.下载和安装z-nomp：\n                    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\"> cd /pool</span><br><span class=\"line\">  npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">   npm update</span><br><span class=\"line\">    sudo npm install   #就算root账户也一定要加sudo</span><br><span class=\"line\">\t```    </span><br><span class=\"line\"></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t3.矿池配置文件：</span><br><span class=\"line\"></span><br><span class=\"line\">\t修改示例文件config_example.json。</span><br></pre></td></tr></table></figure>\n\n                                            mv config_example.json config.json\n                                                vim config.json\n                                                <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面提供一些主要配置说明：</span><br></pre></td></tr></table></figure>\n\n                                                            &quot;redis&quot;: {\n                                                                            &quot;host&quot;: &quot;127.0.0.1&quot;,   #redis地址\n                                                                                            &quot;port&quot;: 6379,          #redis端口\n                                                                                                        &quot;password&quot;: &quot;&quot;      #redis密码\n                                                                                                                }\n},\n\n       &quot;website&quot;: {\n                   &quot;enabled&quot;: true,\n                           &quot;host&quot;: &quot;0.0.0.0&quot;,                 #website地址\n                                       &quot;port&quot;: 8080,                      #website端口\n                                               &quot;stratumHost&quot;: &quot;cryppit.com&quot;,      #挖矿域名    \n                                                       &quot;stats&quot;: {\n                                                                       &quot;updateInterval&quot;: 30,\n                                                                                   &quot;historicalRetention&quot;: 14400,\n                                                                                               &quot;hashrateWindow&quot;: 300\n                                                                                                           },\n\n                                       &quot;tlsOptions&quot; : {\n                                                       &quot;enabled&quot;: false,          #ssl挖矿\n                                                                       &quot;cert&quot;: &quot;&quot;,                #ssl公钥地址\n                                                                                   &quot;key&quot;: &quot;&quot;                  #ssl私钥地址\n                                                                                           }\n                       },\n                       <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4.数字货币配置：</span><br><span class=\"line\"></span><br><span class=\"line\">进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</span><br></pre></td></tr></table></figure>\n\n                           cd pool_config\n                               mv zcash_example.json zcash.json\n                                   vim zcash.json\n                                   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要配置文件说明：</span><br></pre></td></tr></table></figure>\n\n                                       &quot;enabled&quot;: true,         #设置打开coin\n                                           &quot;coin&quot;: &quot;zcash.json&quot;,    #coin配置文件\n                                               &quot;address&quot;: &quot;&quot;,           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n                                                   &quot;zAddress&quot;: &quot;&quot;,          #Z地址\n                                                       &quot;tAddress&quot;: &quot;&quot;,          #T地址\n\n                                                               &quot;rewardRecipients&quot;: {\n                                                                           &quot;&quot;: 0.2,             #手续费和接收手续费地址\n                                                                                   },\n\n\n                                                                                           &quot;paymentProcessing&quot;: {\n                                                                                                     &quot;minConf&quot;: 10,\n                                                                                                             &quot;enabled&quot;: false,             #支付进程\n                                                                                                                         &quot;paymentMode&quot;: &quot;prop&quot;,        #挖矿模式\n                                                                                                                                 &quot;_comment_paymentMode&quot;:&quot;prop, pplnt&quot;,\n                                                                                                                     &quot;paymentInterval&quot;: 20, \n                                                                                                                             &quot;minimumPayment&quot;: 0.1,         #最低支付额\n                                                                                                                                         &quot;maxBlocksPerPayment&quot;: 1,     \n                                                                                                                                     &quot;daemon&quot;: {                    #节点信息 这里为支付节点\n                                                                                                                                                     &quot;host&quot;: &quot;127.0.0.1&quot;,       \n                                                                                                                                                                 &quot;port&quot;: 19332,\n                                                                                                                                                                             &quot;user&quot;: &quot;testuser&quot;,\n                                                                                                                                                                                         &quot;password&quot;: &quot;testpass&quot;\n                                                                                                                                                                                                     }\n                                                                                                         },\n\n                                                                                                                 &quot;ports&quot;: {                 #支付端口和难度\n                                                                                                                             &quot;3032&quot;: {\n                                                                                                                                             &quot;diff&quot;: 0.05,\n                                                                                                                                                         &quot;tls&quot;: false,\n                                                                                                                                                                     &quot;varDiff&quot;: {\n                                                                                                                                                                                         &quot;minDiff&quot;: 0.04,\n                                                                                                                                                                                                         &quot;maxDiff&quot;: 16,\n                                                                                                                                                                                                                         &quot;targetTime&quot;: 15,\n                                                                                                                                                                                                                                         &quot;retargetTime&quot;: 60,\n                                                                                                                                                                                                                                                         &quot;variancePercent&quot;: 30\n                                                                                                                                                                                                                                                                         }\n                                                                                                                                                     }\n                                                                                                                                 },\n                                                                                                                                     &quot;daemons&quot;: [                #节点  这里为挖矿节点 可与支付节点一致\n                                                                                                                                             {\n                                                                                                                                                             &quot;host&quot;: &quot;127.0.0.1&quot;,\n                                                                                                                                                                         &quot;port&quot;: 18232,\n                                                                                                                                                                                     &quot;user&quot;: &quot;rpcuser&quot;,\n                                                                                                                                                                                                 &quot;password&quot;: &quot;rpcpassword&quot;\n                                                                                                                                                                                                             }\n],\n```    \n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"zcash矿池之Z-NOMP-Node-Open-Mining-Portal\"><a href=\"#zcash矿池之Z-NOMP-Node-Open-Mining-Portal\" class=\"headerlink\" title=\"zcash矿池之Z-NOMP(Node Open Mining Portal)\"></a>zcash矿池之Z-NOMP(Node Open Mining Portal)</h1><hr>\n<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>  z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<pre><code>**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n  首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n\n    1.安装z-nomp依赖：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\"> sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">  sudo npm install n -g</span><br><span class=\"line\">   sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n\n                    2.下载和安装z-nomp：\n                    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\"> cd /pool</span><br><span class=\"line\">  npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">   npm update</span><br><span class=\"line\">    sudo npm install   #就算root账户也一定要加sudo</span><br><span class=\"line\">\t```    </span><br><span class=\"line\"></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t3.矿池配置文件：</span><br><span class=\"line\"></span><br><span class=\"line\">\t修改示例文件config_example.json。</span><br></pre></td></tr></table></figure>\n\n                                            mv config_example.json config.json\n                                                vim config.json\n                                                <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面提供一些主要配置说明：</span><br></pre></td></tr></table></figure>\n\n                                                            &quot;redis&quot;: {\n                                                                            &quot;host&quot;: &quot;127.0.0.1&quot;,   #redis地址\n                                                                                            &quot;port&quot;: 6379,          #redis端口\n                                                                                                        &quot;password&quot;: &quot;&quot;      #redis密码\n                                                                                                                }\n},\n\n       &quot;website&quot;: {\n                   &quot;enabled&quot;: true,\n                           &quot;host&quot;: &quot;0.0.0.0&quot;,                 #website地址\n                                       &quot;port&quot;: 8080,                      #website端口\n                                               &quot;stratumHost&quot;: &quot;cryppit.com&quot;,      #挖矿域名    \n                                                       &quot;stats&quot;: {\n                                                                       &quot;updateInterval&quot;: 30,\n                                                                                   &quot;historicalRetention&quot;: 14400,\n                                                                                               &quot;hashrateWindow&quot;: 300\n                                                                                                           },\n\n                                       &quot;tlsOptions&quot; : {\n                                                       &quot;enabled&quot;: false,          #ssl挖矿\n                                                                       &quot;cert&quot;: &quot;&quot;,                #ssl公钥地址\n                                                                                   &quot;key&quot;: &quot;&quot;                  #ssl私钥地址\n                                                                                           }\n                       },\n                       <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4.数字货币配置：</span><br><span class=\"line\"></span><br><span class=\"line\">进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</span><br></pre></td></tr></table></figure>\n\n                           cd pool_config\n                               mv zcash_example.json zcash.json\n                                   vim zcash.json\n                                   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要配置文件说明：</span><br></pre></td></tr></table></figure>\n\n                                       &quot;enabled&quot;: true,         #设置打开coin\n                                           &quot;coin&quot;: &quot;zcash.json&quot;,    #coin配置文件\n                                               &quot;address&quot;: &quot;&quot;,           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n                                                   &quot;zAddress&quot;: &quot;&quot;,          #Z地址\n                                                       &quot;tAddress&quot;: &quot;&quot;,          #T地址\n\n                                                               &quot;rewardRecipients&quot;: {\n                                                                           &quot;&quot;: 0.2,             #手续费和接收手续费地址\n                                                                                   },\n\n\n                                                                                           &quot;paymentProcessing&quot;: {\n                                                                                                     &quot;minConf&quot;: 10,\n                                                                                                             &quot;enabled&quot;: false,             #支付进程\n                                                                                                                         &quot;paymentMode&quot;: &quot;prop&quot;,        #挖矿模式\n                                                                                                                                 &quot;_comment_paymentMode&quot;:&quot;prop, pplnt&quot;,\n                                                                                                                     &quot;paymentInterval&quot;: 20, \n                                                                                                                             &quot;minimumPayment&quot;: 0.1,         #最低支付额\n                                                                                                                                         &quot;maxBlocksPerPayment&quot;: 1,     \n                                                                                                                                     &quot;daemon&quot;: {                    #节点信息 这里为支付节点\n                                                                                                                                                     &quot;host&quot;: &quot;127.0.0.1&quot;,       \n                                                                                                                                                                 &quot;port&quot;: 19332,\n                                                                                                                                                                             &quot;user&quot;: &quot;testuser&quot;,\n                                                                                                                                                                                         &quot;password&quot;: &quot;testpass&quot;\n                                                                                                                                                                                                     }\n                                                                                                         },\n\n                                                                                                                 &quot;ports&quot;: {                 #支付端口和难度\n                                                                                                                             &quot;3032&quot;: {\n                                                                                                                                             &quot;diff&quot;: 0.05,\n                                                                                                                                                         &quot;tls&quot;: false,\n                                                                                                                                                                     &quot;varDiff&quot;: {\n                                                                                                                                                                                         &quot;minDiff&quot;: 0.04,\n                                                                                                                                                                                                         &quot;maxDiff&quot;: 16,\n                                                                                                                                                                                                                         &quot;targetTime&quot;: 15,\n                                                                                                                                                                                                                                         &quot;retargetTime&quot;: 60,\n                                                                                                                                                                                                                                                         &quot;variancePercent&quot;: 30\n                                                                                                                                                                                                                                                                         }\n                                                                                                                                                     }\n                                                                                                                                 },\n                                                                                                                                     &quot;daemons&quot;: [                #节点  这里为挖矿节点 可与支付节点一致\n                                                                                                                                             {\n                                                                                                                                                             &quot;host&quot;: &quot;127.0.0.1&quot;,\n                                                                                                                                                                         &quot;port&quot;: 18232,\n                                                                                                                                                                                     &quot;user&quot;: &quot;rpcuser&quot;,\n                                                                                                                                                                                                 &quot;password&quot;: &quot;rpcpassword&quot;\n                                                                                                                                                                                                             }\n],\n```    \n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n</code></pre>"},{"title":"以太坊wiki-设计原理翻译一","comments":0,"date":"2018-02-09T03:22:26.000Z","img":null,"_content":"## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","source":"_posts/以太坊wiki-设计原理翻译一.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译一\ncomments: false\ndate: 2018-02-09 11:22:26\ncategories: 区块链\ntags: 以太坊 ethereum\nimg:\n---\n## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","slug":"以太坊wiki-设计原理翻译一","published":1,"updated":"2018-02-09T10:08:28.046Z","layout":"post","photos":[],"link":"","_id":"cje6lnszi0004psjx35zvuo7x","content":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n"},{"title":"以太坊wiki-设计原理翻译三","comments":0,"date":"2018-02-24T02:39:17.000Z","img":null,"_content":"[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","source":"_posts/以太坊wiki-设计原理翻译三.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译三\ncomments: false\ndate: 2018-02-24 10:39:17\ncategories: 区块链\ntags: 区块链 以太坊\nimg:\n---\n[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","slug":"以太坊wiki-设计原理翻译三","published":1,"updated":"2018-02-24T03:00:52.525Z","layout":"post","photos":[],"link":"","_id":"cje6lnszm0005psjxy6m2fbyd","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n"},{"title":"以太坊wiki-设计原理翻译二","comments":0,"date":"2018-02-08T18:10:31.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","source":"_posts/以太坊wiki-设计原理翻译二.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译二\ncomments: false\ndate: 2018-02-09 02:10:31\ncategories: 区块链\ntags: 区块链 以太坊 ethereum\nimg:\n---\n\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","slug":"以太坊wiki-设计原理翻译二","published":1,"updated":"2018-02-24T02:33:09.369Z","layout":"post","photos":[],"link":"","_id":"cje6lnt030006psjx0tslfwlq","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n"},{"title":"以太坊wiki-设计原理翻译四","comments":0,"date":"2018-02-24T03:01:05.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","source":"_posts/以太坊wiki-设计原理翻译四.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译四\ncomments: false\ndate: 2018-02-24 11:01:05\ncategories: 区块链\ntags: 区块链 以太坊\nimg:\n---\n\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","slug":"以太坊wiki-设计原理翻译四","published":1,"updated":"2018-02-24T03:48:36.078Z","layout":"post","photos":[],"link":"","_id":"cje6lnt0j000apsjxq7kbw9rz","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n"},{"title":"比特币挖矿之全网难度","comments":0,"date":"2018-02-09T04:24:39.000Z","img":null,"_content":"\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 难度表示\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<F(nBits)\n```\n这儿的nBits正是难度的一种压缩表达方式。\n前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)\n``` bash\ncurrent_target = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ncurrent_target = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ncurrent_target = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ncurrent_target =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n创世区块的bits值在代码中是写死的，具体代码如下:\n``` bash\ngenesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\n```\n其中各参数含义如下:\n1231006505:时间戳，对应北京时间:2009/1/4 2:15:5\n2083236893:nNonce,随机数\n0x1d00ffff:bits,难度的压缩表示\n1:版本号\n50:区块奖励数\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","source":"_posts/比特币挖矿之全网难度.md","raw":"---\ntitle: 比特币挖矿之全网难度\ncomments: false\ndate: 2018-02-09 12:24:39\ncategories: 矿池\ntags: bitcoin 比特币\nimg:\n---\n\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 难度表示\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<F(nBits)\n```\n这儿的nBits正是难度的一种压缩表达方式。\n前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)\n``` bash\ncurrent_target = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ncurrent_target = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ncurrent_target = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ncurrent_target =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n创世区块的bits值在代码中是写死的，具体代码如下:\n``` bash\ngenesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\n```\n其中各参数含义如下:\n1231006505:时间戳，对应北京时间:2009/1/4 2:15:5\n2083236893:nNonce,随机数\n0x1d00ffff:bits,难度的压缩表示\n1:版本号\n50:区块奖励数\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","slug":"比特币挖矿之全网难度","published":1,"updated":"2018-02-09T10:07:34.484Z","layout":"post","photos":[],"link":"","_id":"cje6lnt0p000bpsjxpo71il0j","content":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"难度表示\"><a href=\"#难度表示\" class=\"headerlink\" title=\"难度表示\"></a>难度表示</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>这儿的nBits正是难度的一种压缩表达方式。<br>前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<p>创世区块的bits值在代码中是写死的，具体代码如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);</span><br></pre></td></tr></table></figure></p>\n<p>其中各参数含义如下:<br>1231006505:时间戳，对应北京时间:2009/1/4 2:15:5<br>2083236893:nNonce,随机数<br>0x1d00ffff:bits,难度的压缩表示<br>1:版本号<br>50:区块奖励数</p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。</p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"难度表示\"><a href=\"#难度表示\" class=\"headerlink\" title=\"难度表示\"></a>难度表示</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>这儿的nBits正是难度的一种压缩表达方式。<br>前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current_target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<p>创世区块的bits值在代码中是写死的，具体代码如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);</span><br></pre></td></tr></table></figure></p>\n<p>其中各参数含义如下:<br>1231006505:时间戳，对应北京时间:2009/1/4 2:15:5<br>2083236893:nNonce,随机数<br>0x1d00ffff:bits,难度的压缩表示<br>1:版本号<br>50:区块奖励数</p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。</p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cje6lnsy90000psjxfm4iblqx","category_id":"cje6lnsz80002psjxhg8qyj3m","_id":"cje6lnt0v000cpsjxdaoabnwg"},{"post_id":"cje6lnt0j000apsjxq7kbw9rz","category_id":"cje6lnt0f0007psjxzlxl8lpo","_id":"cje6lnt11000gpsjxg5ams7im"},{"post_id":"cje6lnszi0004psjx35zvuo7x","category_id":"cje6lnt0f0007psjxzlxl8lpo","_id":"cje6lnt16000jpsjxumo79fk2"},{"post_id":"cje6lnt0p000bpsjxpo71il0j","category_id":"cje6lnsz80002psjxhg8qyj3m","_id":"cje6lnt17000lpsjx1sf94pha"},{"post_id":"cje6lnszm0005psjxy6m2fbyd","category_id":"cje6lnt0f0007psjxzlxl8lpo","_id":"cje6lnt1a000npsjxdbzkl2ko"},{"post_id":"cje6lnt030006psjx0tslfwlq","category_id":"cje6lnt0f0007psjxzlxl8lpo","_id":"cje6lnt1g000ppsjxj6ystjxn"}],"PostTag":[{"post_id":"cje6lnsy90000psjxfm4iblqx","tag_id":"cje6lnszh0003psjxx892axrh","_id":"cje6lnt0i0009psjx51pt1q5n"},{"post_id":"cje6lnszi0004psjx35zvuo7x","tag_id":"cje6lnt0g0008psjxv2tk0yl1","_id":"cje6lnt10000fpsjx4uto3925"},{"post_id":"cje6lnszm0005psjxy6m2fbyd","tag_id":"cje6lnt0w000epsjxup9b8j09","_id":"cje6lnt16000kpsjxz3wia7qe"},{"post_id":"cje6lnt030006psjx0tslfwlq","tag_id":"cje6lnt14000ipsjxph4o99l0","_id":"cje6lnt1c000opsjx9wqrz7fn"},{"post_id":"cje6lnt0j000apsjxq7kbw9rz","tag_id":"cje6lnt0w000epsjxup9b8j09","_id":"cje6lnt1j000rpsjx7pzd1n9g"},{"post_id":"cje6lnt0p000bpsjxpo71il0j","tag_id":"cje6lnt1h000qpsjxdvuy21wq","_id":"cje6lnt1m000spsjxb15t5zuc"}],"Tag":[{"name":"zcash 矿池","_id":"cje6lnszh0003psjxx892axrh"},{"name":"以太坊 ethereum","_id":"cje6lnt0g0008psjxv2tk0yl1"},{"name":"区块链 以太坊","_id":"cje6lnt0w000epsjxup9b8j09"},{"name":"区块链 以太坊 ethereum","_id":"cje6lnt14000ipsjxph4o99l0"},{"name":"bitcoin 比特币","_id":"cje6lnt1h000qpsjxdvuy21wq"}]}}