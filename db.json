{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/W2.png","path":"images/W2.png","modified":1,"renderable":0},{"_id":"source/images/miner.png","path":"images/miner.png","modified":1,"renderable":0},{"_id":"source/images/pz.png","path":"images/pz.png","modified":1,"renderable":0},{"_id":"themes/snippet/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/images/wallet.jpeg","path":"images/wallet.jpeg","modified":1,"renderable":0},{"_id":"themes/snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/branding.png","path":"img/branding.png","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":1,"renderable":1},{"_id":"themes/snippet/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/snippet/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/images/c5.png","path":"images/c5.png","modified":1,"renderable":0},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"43a3b49dd417de9e9e4707f71089fe943b90337c","modified":1520412661581},{"_id":"themes/snippet/.travis.yml","hash":"8b868cf1653a88ff06ebb776d7441c7a0e0f194b","modified":1519809381349},{"_id":"themes/snippet/LICENSE","hash":"c720db99e36a717d9808bf97b736612462e883dd","modified":1519809381353},{"_id":"themes/snippet/README.md","hash":"4c6f1d4892eb6fdb6e375ad5d1cd44b50a61e9e2","modified":1519809381353},{"_id":"themes/snippet/_config.yml","hash":"fc4fafe4adaca405e99afb8238fb7a9689796068","modified":1520577903662},{"_id":"themes/snippet/_config1.yml","hash":"c65b4a58b94b9d53a75d5c46f6548e99c1f4c7d6","modified":1519809381353},{"_id":"themes/snippet/_travis.sh","hash":"6f28564a4a83aed0e5cbe2969a07fa28ada6e1f4","modified":1519809381357},{"_id":"themes/snippet/gulpfile.js","hash":"876e7ff1359e589ec99ad29a7182d076831a6655","modified":1519809381357},{"_id":"themes/snippet/package.json","hash":"2ac1a7806f43b75a7e0111e4f6b89008528a5407","modified":1519809381380},{"_id":"source/_posts/2018年自己动手组装一台矿机吧-显卡矿机教程.md","hash":"3cce1b85ff2e166c3448e10b5ce87d478dedc938","modified":1520417116371},{"_id":"source/_posts/linux下Zcash钱包使用教程.md","hash":"e116c8e8822349f87ac9bf252c17299aca2c832b","modified":1520417128474},{"_id":"source/_posts/zcash矿池之Z-NOMP-Node-Open-Mining-Portal.md","hash":"2362d51c9a5e83d1f0793815aa127f005459a62c","modified":1520417140401},{"_id":"source/_posts/以太坊wiki-设计原理翻译一.md","hash":"feb69ffae810e22d9a5678a73931cd2906f33c93","modified":1520417156271},{"_id":"source/_posts/以太坊wiki-设计原理翻译三.md","hash":"6ff55bf9f269c0fc30252bac2c50d090edf2e036","modified":1520417180277},{"_id":"source/_posts/以太坊wiki-设计原理翻译二.md","hash":"d2b8bb07d94b4df8522336de6d554875e93a0f23","modified":1520417167447},{"_id":"source/_posts/以太坊wiki-设计原理翻译四.md","hash":"25b419139347647d41d372d9bb3f27d022182cf9","modified":1520417189964},{"_id":"source/_posts/以太坊，燃气，燃料-和-费用.md","hash":"b62194fafab6bf48be4204f8ec9da74eca08dbe1","modified":1520417203742},{"_id":"source/_posts/手机钱包常见名词解释.md","hash":"bc343457721a7736d8ba966849927a255f30922f","modified":1520417373394},{"_id":"source/_posts/智能合约最佳实践翻译一.md","hash":"07f30a34dcf99a0e93675ecb939b7788e491ab2b","modified":1520568070544},{"_id":"source/_posts/智能合约最佳实践翻译三.md","hash":"cce26689d1811a60a6cccb40df8d566bc15079b5","modified":1520566361782},{"_id":"source/_posts/智能合约最佳实践翻译二.md","hash":"e92a648a7b2ce78ae34abf474fa02d352fbaf43d","modified":1520417235510},{"_id":"source/_posts/比特币挖矿之Merkle树.md","hash":"d3b26cc1a27b4aaf8d960c95d1ad23936ca25e13","modified":1520417250124},{"_id":"source/_posts/比特币挖矿之全网难度.md","hash":"a7760c3425a2aebf8e9a16ad39b2ed74da17ea0a","modified":1520417264779},{"_id":"source/_posts/比特币挖矿之矿工任务-1.md","hash":"ab4b4656e388af81362bfac6b477db663a345eee","modified":1520417278762},{"_id":"source/_posts/比特币挖矿之随机数.md","hash":"348b5c42994b2098d2212027fb401be218af8ce4","modified":1520417292969},{"_id":"source/images/W2.png","hash":"79b72c31300166b0e42e5c9e997d6dbef1b0400b","modified":1519983070908},{"_id":"source/images/miner.png","hash":"954abbb34b4b051c21e7f10ee4a7f22a69de0a61","modified":1519978919657},{"_id":"source/images/pz.png","hash":"42281741a80165a9ea92c162c2c2e47dff8d3299","modified":1519983083617},{"_id":"themes/snippet/languages/default.yml","hash":"3514b76f1f39009803abe47d1be22d5a6012e398","modified":1519809381357},{"_id":"themes/snippet/languages/zh-CN.yml","hash":"1baa7ea790a0011706bb7eca308b87dd9991ee8d","modified":1519809381357},{"_id":"themes/snippet/languages/zh-TW.yml","hash":"0c7591ce46476677c0903c160817454566f7e978","modified":1519809381357},{"_id":"themes/snippet/layout/archive.ejs","hash":"c42bc18ba370905c813981e3f6681e09b6a5857d","modified":1519809381376},{"_id":"themes/snippet/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1519809381376},{"_id":"themes/snippet/layout/index.ejs","hash":"bc1a4dbde309dfc7618486a6e8ffc59604814124","modified":1519809381380},{"_id":"themes/snippet/layout/layout.ejs","hash":"a8a1c39ca9b0f961690dd0ac0f174475c9f71288","modified":1519809381380},{"_id":"themes/snippet/layout/page.ejs","hash":"3036c21565da3964f472c5867e6acc3453d0d316","modified":1519809381380},{"_id":"themes/snippet/layout/post.ejs","hash":"1778eab011f8d420aacfcac2421109ce0d69b0dd","modified":1520567842794},{"_id":"themes/snippet/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1519809381380},{"_id":"themes/snippet/scripts/helper.js","hash":"836d369cf95ac51de957e09d396e6a8be1e84cf6","modified":1519809381380},{"_id":"themes/snippet/scripts/process.js","hash":"c2f0571899a6dd38bd944aaf47e21fc650f7d52e","modified":1519809381380},{"_id":"themes/snippet/source/favicon.ico","hash":"107ca59f31dbe89dcb4aaeea95b22ead3ffd53bb","modified":1519809381387},{"_id":"source/images/wallet.jpeg","hash":"1faf948f4e494f87c7d118a3f4069aab2a0d95d7","modified":1519980774383},{"_id":"themes/snippet/layout/_partial/archive.ejs","hash":"7bfcfd7cf4db6330f72665ec653af608b7f2e9b9","modified":1520475385485},{"_id":"themes/snippet/layout/_partial/article-meta.ejs","hash":"30cfe18a738b77eaee3d7ace73ce4146ee45b8ac","modified":1520416646828},{"_id":"themes/snippet/layout/_partial/copyright.ejs","hash":"4c35b1071a3b426233190db28f552c50ff71a299","modified":1519809381361},{"_id":"themes/snippet/layout/_partial/footer.ejs","hash":"98bb8b352b0635f8ecd8a3486e63f65212f2af69","modified":1520414720381},{"_id":"themes/snippet/layout/_partial/gallery.ejs","hash":"1b6b7859f395e10a3ecaa900de2d1312dc140def","modified":1519809381361},{"_id":"themes/snippet/layout/_partial/head.ejs","hash":"1aea0e44f11d9f6f3e78f0da7dba0f35b910e6c3","modified":1519809381361},{"_id":"themes/snippet/layout/_partial/header.ejs","hash":"b1ae20eb0901a77faffe338af959da29e17f8dbd","modified":1520416636445},{"_id":"themes/snippet/layout/_partial/nav.ejs","hash":"4276098a03b1392d70cc73bbdbd49d1a299c1344","modified":1519809381361},{"_id":"themes/snippet/layout/_partial/pagination.ejs","hash":"2ec88a22fd29e7cc97ca2a508eee7d168e338969","modified":1519809381364},{"_id":"themes/snippet/layout/_partial/script.ejs","hash":"4deb486529a91e79cf067aeac7befaef79894d75","modified":1519809381364},{"_id":"themes/snippet/layout/_partial/sidebar.ejs","hash":"f2ad132c8a0eae0a8b1f868bf4dda730ebeab82c","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/baidu_sitemap.ejs","hash":"f17db411dc1607e7d1eb133b7b7dfe5b575cabad","modified":1519809381364},{"_id":"themes/snippet/layout/_widget/archive.ejs","hash":"906cc9b37734fd17b9c70d0089fd5a9b8178f6b1","modified":1519809381372},{"_id":"themes/snippet/layout/_widget/category.ejs","hash":"1c6881cd5b6b034ddecda6c85a3337d17a03e9ff","modified":1519809381372},{"_id":"themes/snippet/layout/_widget/friends.ejs","hash":"43b0404d608db1a237b3cf17ec8df7b2d24f9533","modified":1519809381376},{"_id":"themes/snippet/layout/_widget/notification.ejs","hash":"6e75cc9fbee74d7cd4e9b26e62475f6113205585","modified":1519809381376},{"_id":"themes/snippet/layout/_widget/search.ejs","hash":"2b6a0e7d07032920211dedec0be6844728e9b17f","modified":1519809381376},{"_id":"themes/snippet/layout/_widget/social.ejs","hash":"f97313cdc1b495f7602e023b2ade5630acc4b667","modified":1519809381376},{"_id":"themes/snippet/layout/_widget/tagcloud.ejs","hash":"457b6081e2f24afd5c4c3a2d566c1f5940f3f21a","modified":1519809381376},{"_id":"themes/snippet/source/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1519809381380},{"_id":"themes/snippet/source/css/style.css","hash":"e1fc8aa20dede36c08bde6330ab2a7f36e31aa48","modified":1519809381387},{"_id":"themes/snippet/source/img/avatar.jpg","hash":"1e195d1fc20c180d6a54e6f90ce3762ef3f6d9af","modified":1519809381403},{"_id":"themes/snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1519809381403},{"_id":"themes/snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1519809381403},{"_id":"themes/snippet/source/js/app.js","hash":"41fe02b22201e3be72dcebfb05cac8cbfae8d85f","modified":1519809381403},{"_id":"themes/snippet/source/js/search.js","hash":"b806e6ac8b92750113033d4ab0cc598953c3d5ac","modified":1519809381403},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1519809381399},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1519809381403},{"_id":"themes/snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1519809381403},{"_id":"themes/snippet/layout/_partial/_head-sections/IE.ejs","hash":"567494a97ba2db7bb452294a9980b4d63b399ef0","modified":1519809381357},{"_id":"themes/snippet/layout/_partial/_head-sections/seo.ejs","hash":"f80ec948f4f23763a1bf9b71efef6d6ebc6fc5d5","modified":1519809381357},{"_id":"themes/snippet/layout/_partial/_head-sections/style.ejs","hash":"fc4d4fcfdc68719b4fa2b17117dd1a8638ca2299","modified":1519809381357},{"_id":"themes/snippet/layout/_partial/_head-sections/title.ejs","hash":"1482f56c44221cbc0d28ba06e377f4b55cdaacc2","modified":1519809381361},{"_id":"themes/snippet/layout/_vendor/analytics/baidu.ejs","hash":"eb4a75fb5ba9237d93430e727165d98ccda75a02","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/analytics/cnzz.ejs","hash":"8bfc514b178fafd81cc8181880afc5c9cbee02dc","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/analytics/google.ejs","hash":"91844d4521f97517ea9f169ee85b18c9d0d8cf17","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/analytics/index.ejs","hash":"6315abe9c31f4c4de719fa3cbfa2b1c6f294b0de","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/analytics/tencent.ejs","hash":"6a3d3c479ef08b735827caa63791879c6972b2ca","modified":1519809381364},{"_id":"themes/snippet/layout/_vendor/comments/changyan.ejs","hash":"202c94162ac2eeb0c93c8d2667c82b8705de6390","modified":1519809381368},{"_id":"themes/snippet/layout/_vendor/comments/disqus.ejs","hash":"7b5e05154be0408be110893439bfa33e262245de","modified":1519809381368},{"_id":"themes/snippet/layout/_vendor/comments/gitment.ejs","hash":"be5c261ae8a769747704a228aa35758120b814e1","modified":1519809381372},{"_id":"themes/snippet/layout/_vendor/comments/index.ejs","hash":"91ce022b7a379f3d1b53cf3b13612c2645a16139","modified":1519809381372},{"_id":"themes/snippet/layout/_vendor/comments/livere.ejs","hash":"6333308ba24ae6f2a3e73f4cdc1b42e024d19910","modified":1519809381372},{"_id":"themes/snippet/layout/_vendor/comments/uyan.ejs","hash":"34a2664bd0b074df1fdf2cdc6f933bcd7bb156c4","modified":1520333592309},{"_id":"themes/snippet/source/css/less/_highlight.less","hash":"c799cfa32c323c33a09569d326786874026fd1ef","modified":1519809381384},{"_id":"themes/snippet/source/css/less/_mixins.less","hash":"e89dc55772b5ae6bfd4cac3b5c32bf9ce73ac805","modified":1519809381384},{"_id":"themes/snippet/source/css/less/_style.less","hash":"c4bd243fe7470fcf2543c5fa970c359c5e5d45fe","modified":1519809381384},{"_id":"themes/snippet/source/css/less/_variable.less","hash":"b06c46ac56dbb8cd75ac13310479c643d5087d9b","modified":1519809381387},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1519809381391},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1519809381395},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1519809381399},{"_id":"source/images/c5.png","hash":"7cc7417f668cc19608167a5d7c96bed4adf12eff","modified":1519983077888},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1519809381399},{"_id":"public/content.json","hash":"bf2a6012f1ef07b9fde3a4bc202e22daa279717f","modified":1520578800134},{"_id":"public/2018/03/02/2018年自己动手组装一台矿机吧-显卡矿机教程/index.html","hash":"1547d3b4d4645b403936ade035b75d8076bfacbe","modified":1520578800656},{"_id":"public/archives/index.html","hash":"fb97d06b9eabf27d53a63396102b7ea97c849f27","modified":1520578800656},{"_id":"public/archives/page/2/index.html","hash":"03bb90da573ebb5ffb5a96549ec1cdfcd8512e9b","modified":1520578800656},{"_id":"public/archives/2018/index.html","hash":"18cb62bc61ea7f4ec571c6f4dae293f512861310","modified":1520578800656},{"_id":"public/archives/2018/page/2/index.html","hash":"4cfd8226e58158cb784a0b7fe4416d14d9fc6c0d","modified":1520578800657},{"_id":"public/archives/2018/02/index.html","hash":"a42f630d45c5d36b3fa32a81dbaf27a74d59f4b3","modified":1520578800657},{"_id":"public/archives/2018/03/index.html","hash":"c60133da3ef55ee6d5fa3c52468bdaf9f92c2717","modified":1520578800657},{"_id":"public/categories/钱包/index.html","hash":"c444893fbf8b8bf15cf641d5f27f959b979807c8","modified":1520578800657},{"_id":"public/tags/lucas556/index.html","hash":"75ac4bf68a71f8bb2172ac38e620088dc7369843","modified":1520578800657},{"_id":"public/tags/矿机/index.html","hash":"32b2ffe16ca0c0b6ec1f3fae98736dd45f1406ce","modified":1520578800657},{"_id":"public/tags/zcash/index.html","hash":"5a098e717dc9e85973947ae2dc742bd137acc478","modified":1520578800657},{"_id":"public/tags/ethereum/index.html","hash":"5f2aa4c1b46e067157292cb9962256b57906c147","modified":1520578800658},{"_id":"public/tags/区块链/index.html","hash":"70c8203af6f3712a54706736e5248713612d5b74","modified":1520578800658},{"_id":"public/tags/燃料/index.html","hash":"581a81e607a504e3cc3d5ff2981e9e8ca30149ad","modified":1520578800658},{"_id":"public/tags/gas/index.html","hash":"b1fa2491f8da6a5eeef159af1c2794b01145c320","modified":1520578800658},{"_id":"public/tags/翻译/index.html","hash":"cf43d7b7229c1cbcff52a928e0c3af2bafab944e","modified":1520578800658},{"_id":"public/tags/ciscolxh/index.html","hash":"4d9a2a827433311cbf7858ab0b06f2cd2339d0b9","modified":1520578800658},{"_id":"public/tags/钱包/index.html","hash":"b06184e4c91a8fe857b3829ff7f6e4945bca7718","modified":1520578800658},{"_id":"public/tags/智能合约/index.html","hash":"8d85116a66dd7e654b9c2f363fff1d2aaf1b9717","modified":1520578800659},{"_id":"public/tags/安全开发/index.html","hash":"73f1dbe3efbf77177b929f223e13f51ca426f879","modified":1520578800659},{"_id":"public/tags/LeonBCK/index.html","hash":"00daa5a9872f1716836c419d9a76986bd67c548e","modified":1520578800659},{"_id":"public/tags/比特币/index.html","hash":"e6f3cd36abd5bc6aa8425adf15121ab73698f3a5","modified":1520578800659},{"_id":"public/tags/bitcoin/index.html","hash":"c71476e0cf5734d842a3c91d586ca32c7600e7d2","modified":1520578800659},{"_id":"public/2018/03/09/智能合约最佳实践翻译三/index.html","hash":"249c7ffb5ff79b4574c8cb37388684f27e10a835","modified":1520578800659},{"_id":"public/2018/03/09/智能合约最佳实践翻译一/index.html","hash":"adc1c1296ed163a959cdb972c2f0bc72dcbe80db","modified":1520578800659},{"_id":"public/2018/03/02/智能合约最佳实践翻译二/index.html","hash":"b238801fd182f18ba96ca9dfd71b31bf0944dc80","modified":1520578800660},{"_id":"public/2018/03/02/手机钱包常见名词解释/index.html","hash":"3b944a9ed3d17b5257225d00fc03d8550859f699","modified":1520578800660},{"_id":"public/2018/03/02/比特币挖矿之随机数/index.html","hash":"4a6ea74b3b222db20e38b02593e1538eca7119ea","modified":1520578800660},{"_id":"public/2018/03/02/比特币挖矿之Merkle树/index.html","hash":"7568181a27d764d0b5dae4cfa0fd2affddf4defa","modified":1520578800660},{"_id":"public/2018/03/02/zcash矿池之Z-NOMP-Node-Open-Mining-Portal/index.html","hash":"9edc158bfa9f2dc3e1d347c98dc8e17d24f423be","modified":1520578800660},{"_id":"public/2018/03/01/以太坊，燃气，燃料-和-费用/index.html","hash":"2d9fa8bd18e099db2f1efaa22829c57f3dc7ed42","modified":1520578800661},{"_id":"public/2018/02/28/比特币挖矿之矿工任务-1/index.html","hash":"960855b61159031e1b1fa406abff2c433b7f3a67","modified":1520578800661},{"_id":"public/2018/02/24/以太坊wiki-设计原理翻译四/index.html","hash":"a6616dc075b09b845fcac03ff3df41782d21c4e2","modified":1520578800661},{"_id":"public/2018/02/24/以太坊wiki-设计原理翻译三/index.html","hash":"5bda297dcf66572e33814cbd2560d4554f19b9ba","modified":1520578800661},{"_id":"public/2018/02/09/比特币挖矿之全网难度/index.html","hash":"ea5ac032f0c923fd234c52525316831fe76f5ae8","modified":1520578800661},{"_id":"public/2018/02/09/以太坊wiki-设计原理翻译一/index.html","hash":"344c944647d3530c09c978fe80bafcbd283f1ee2","modified":1520578800661},{"_id":"public/2018/02/09/以太坊wiki-设计原理翻译二/index.html","hash":"a9329b79b73c1226234c65cdaa9059da4fa4f9d8","modified":1520578800662},{"_id":"public/2018/02/08/linux下Zcash钱包使用教程/index.html","hash":"c0481a693d2b2b98bceddfad8337381bf4e34097","modified":1520578800662},{"_id":"public/categories/矿池/index.html","hash":"bbe90a7961a0d9c6d258db09d2f1556f7d8920f3","modified":1520578800662},{"_id":"public/categories/区块链/index.html","hash":"be3b92554a889cc3036c1da09e367df8c7e984bd","modified":1520578800662},{"_id":"public/index.html","hash":"cc0c19a740c79032eaf0cf8965d588d23db76dbd","modified":1520578800662},{"_id":"public/page/2/index.html","hash":"64f4e46b6be1ddfd5971c1f5182faf7c6eb0828b","modified":1520578800663},{"_id":"public/tags/矿池/index.html","hash":"ee030113e9eafa4d1f173047c4145a32b6b0544e","modified":1520578800663},{"_id":"public/tags/ZhouFyk/index.html","hash":"1b2d1858127e6078c3fc2987918d09b593fdf8a5","modified":1520578800663},{"_id":"public/tags/以太坊/index.html","hash":"404274056b8f3785c17df2bfd6f9f1c1717bbd57","modified":1520578800663},{"_id":"public/CNAME","hash":"43a3b49dd417de9e9e4707f71089fe943b90337c","modified":1520578800676},{"_id":"public/images/W2.png","hash":"79b72c31300166b0e42e5c9e997d6dbef1b0400b","modified":1520578800677},{"_id":"public/images/miner.png","hash":"954abbb34b4b051c21e7f10ee4a7f22a69de0a61","modified":1520578800677},{"_id":"public/images/pz.png","hash":"42281741a80165a9ea92c162c2c2e47dff8d3299","modified":1520578800677},{"_id":"public/favicon.ico","hash":"107ca59f31dbe89dcb4aaeea95b22ead3ffd53bb","modified":1520578800677},{"_id":"public/img/avatar.jpg","hash":"1e195d1fc20c180d6a54e6f90ce3762ef3f6d9af","modified":1520578800678},{"_id":"public/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1520578800678},{"_id":"public/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1520578800678},{"_id":"public/images/wallet.jpeg","hash":"1faf948f4e494f87c7d118a3f4069aab2a0d95d7","modified":1520578800686},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1520578800686},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1520578800688},{"_id":"public/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1520578800689},{"_id":"public/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1520578800699},{"_id":"public/js/app.js","hash":"41fe02b22201e3be72dcebfb05cac8cbfae8d85f","modified":1520578800699},{"_id":"public/js/search.js","hash":"b806e6ac8b92750113033d4ab0cc598953c3d5ac","modified":1520578800700},{"_id":"public/css/style.css","hash":"e1fc8aa20dede36c08bde6330ab2a7f36e31aa48","modified":1520578800700},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1520578800700},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1520578800700},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1520578800702},{"_id":"public/images/c5.png","hash":"7cc7417f668cc19608167a5d7c96bed4adf12eff","modified":1520578800730},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1520578800743}],"Category":[{"name":"矿池","_id":"cjejlcu600002l8jxzbs776fa"},{"name":"区块链","_id":"cjejlcu70000hl8jxnbzz2w9f"},{"name":"钱包","_id":"cjejlcu7z001bl8jx0yrlvndo"}],"Data":[],"Page":[],"Post":[{"title":"2018年自己动手组装一台矿机吧--显卡矿机教程","comments":0,"date":"2018-03-02T09:31:52.000Z","img":null,"_content":"\n市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。\n\n![](/images/W2.png)\n\n显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.\n\n主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.\n\n操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.\n\n显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.\n\n同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.\n\n![](/images/pz.png)\n\n有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.\n\nN卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.\n\n![](/images/c5.png)\n\n重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.\n例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.\n如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.\n","source":"_posts/2018年自己动手组装一台矿机吧-显卡矿机教程.md","raw":"---\ntitle: 2018年自己动手组装一台矿机吧--显卡矿机教程\ncomments: false\ndate: 2018-03-02 17:31:52\ncategories: 矿池\ntags:\n- lucas556\n- 矿机\nimg:\n---\n\n市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。\n\n![](/images/W2.png)\n\n显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.\n\n主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.\n\n操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.\n\n显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.\n\n同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.\n\n![](/images/pz.png)\n\n有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.\n\nN卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.\n\n![](/images/c5.png)\n\n重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.\n例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.\n如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.\n","slug":"2018年自己动手组装一台矿机吧-显卡矿机教程","published":1,"updated":"2018-03-07T10:05:16.371Z","layout":"post","photos":[],"link":"","_id":"cjejlcu5n0000l8jxjkocz38r","content":"<p>市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。</p>\n<p><img src=\"/images/W2.png\" alt=\"\"></p>\n<p>显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.</p>\n<p>主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.</p>\n<p>操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.</p>\n<p>显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.</p>\n<p>同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.</p>\n<p><img src=\"/images/pz.png\" alt=\"\"></p>\n<p>有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.</p>\n<p>N卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.</p>\n<p><img src=\"/images/c5.png\" alt=\"\"></p>\n<p>重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.<br>例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.<br>如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>市面上一些加密数字货币如ETH,Zcash等挖矿投资收益远远超过了比特币，在2017年造成了一卡难求的局面，即使现在币价有所回落，矿机仍然是供不应求，好多矿工甚至小白依然不能买到称心如意的矿机，那么，我们不如自己动手来组装适合自己的矿机，此处仅限显卡矿机。</p>\n<p><img src=\"/images/W2.png\" alt=\"\"></p>\n<p>显卡矿机和我们通常的电脑是一样的,主要硬件包含:显卡、主板、电源、CPU、内存、硬盘（SSD）、延长线、转接线等.其中显卡决定了挖矿的速度,主板、电源很大程度上决定矿机运行的稳定程度.</p>\n<p>主板建议:显卡挖矿不需要很大的 PCIE 带宽.主板上具备 PCI-E 1X 即可满足带宽要求.一般主板上具有3-5个PCI-E 1X 接口，1个PCI-E 16X接口,此外主板上具有大4PIN供电接口对稳定性有一定的提升.PCI-E1X需要淘宝购买1X转16X延长线.</p>\n<p>操作系统使用Windows 10 1703版最佳,建议使用官方原版.动手能力强的朋友可以使用ETH OS进行挖矿,这里不在赘述.</p>\n<p>显卡建议:目前推荐使用AMD RX580/480/470/570;英伟达GTX1060/1070进行挖矿,建议显存4G以上.</p>\n<p>同时,现在市场上出现了以昂达b250 btc-d8p为首的8卡直插主板,免去了转接线、延长线和驱动的繁琐调试,附图是一套8卡直插GTX 1066显卡矿机配置.</p>\n<p><img src=\"/images/pz.png\" alt=\"\"></p>\n<p>有不熟悉硬件的朋友可以找身边对电子产品了解且动手能力强的帮忙安装调试,同时需要进行超频,以GTX 1066挖以太坊为例,没超频前算力约为20 MH,超频后为23 MH,算力提升约为6%.</p>\n<p>N卡超频设置使用MSI Afterburner,打开MSI Afterburner后可以看到+-按钮进行操作,以我们公司的GTX 1066为例子,目前的调整参数为温度 85 ,核心频率 -90 ,显存频率 +735.</p>\n<p><img src=\"/images/c5.png\" alt=\"\"></p>\n<p>重点来了:在上面图片中可以看到显卡矿机的收益并不高,但是显卡矿机有个好处就是可以切换不同币种之间挖矿.<br>例如,现在挖以太坊收益为每天61元,当新出一个币种A的时候,而A此时还没有交易所可以交易,我们可以进行预挖,一般在预挖的时候是产量是比较高的,这个时候留着币,当币种上线交易所,进行抛售套现,也是一个非常好的收益.<br>如果A的收益偏低我们可以继续挖ETH,ZEC等稳定性的币种,充分利用显卡矿机的优势创造收益最大化.</p>\n"},{"title":"linux下Zcash钱包使用教程","comments":0,"date":"2018-02-08T11:04:15.000Z","img":null,"_content":"\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","source":"_posts/linux下Zcash钱包使用教程.md","raw":"---\ntitle: linux下Zcash钱包使用教程\ncomments: false\ndate: 2018-02-08 19:04:15\ncategories: 矿池\ntags: \n- lucas556 \n- zcash \n- 矿池\nimg:\n---\n\n>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.\n\n>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。\n\n现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。\n\n下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\nhash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a\n\n下载后请务必进行哈希值验证，以保证文件的真实和准确性。\n\ntar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩\nmv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件\n\n\t\t\t\t\t\t\t\t\t\t   现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\n\t\t\t\t\t\t\t\t\t\t   zcash-fetch-params\n\n\t\t\t\t\t\t\t\t\t\t   这里由于国内网络的原因，可能会失败，请多试几次。\n\n\t\t\t\t\t\t\t\t\t\t   验证通过后，我们需要对客户端进行配置。\n\n\t\t\t\t\t\t\t\t\t\t   mkdir ~/.zcash //创建zcash目录\n\n\t\t\t\t\t\t\t\t\t\t   vim zcash.conf \n\n\t\t\t\t\t\t\t\t\t\t   以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n\t\t\t\t\t\t\t\t\t\t   //这是测试链接的配置\n\t\t\t\t\t\t\t\t\t\t   addnode=testnet.z.cash    //节点\n\t\t\t\t\t\t\t\t\t\t   rpcuser=test              //rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=test          //rpc密码\n\t\t\t\t\t\t\t\t\t\t   gen=0                     //屏蔽cpu挖矿\n\t\t\t\t\t\t\t\t\t\t   testnet=1                 //开启测试链\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=100.100.60.10 //允许访问的IP\n\t\t\t\t\t\t\t\t\t\t   rpcport=8333             //rpc端口号\n\t\t\t\t\t\t\t\t\t\t   equihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n\t\t\t\t\t\t\t\t\t\t   好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n\t\t\t\t\t\t\t\t\t\t   下面提供一些zcash节点常用命令：\n\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getinfo                           //显示节点信息\n\t\t\t\t\t\t\t\t\t\t   zcashd -daemon                              //后台启动zcash守护\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnetworkhashps                  //获取全网算力\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getnewaddress                    //生成一个Z-addr\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getnewaddress                      //生成一个t-addr                   \n\t\t\t\t\t\t\t\t\t\t   zcas-cli getblockhash                       //区块高度\n\t\t\t\t\t\t\t\t\t\t   zcash-cli getaddressesbyaccount \"\"         //显示所有t-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_listaddresses                   //显示所有Z-addr钱包\n\t\t\t\t\t\t\t\t\t\t   zcash-cli z_getbalance \"\"                   //z钱包余额\n\n\t\t\t\t\t\t\t\t\t\t   如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n\t\t\t\t\t\t\t\t\t\t   附1：\n\n\t\t\t\t\t\t\t\t\t\t   zcash钱包配置：\n\n\t\t\t\t\t\t\t\t\t\t   //这里是zcash钱包主链配置\n\n\t\t\t\t\t\t\t\t\t\t   rpcuser=rpc用户名\n\t\t\t\t\t\t\t\t\t\t   rpcpassword=rpc密码\n\t\t\t\t\t\t\t\t\t\t   rpcport=rpc端口\n\t\t\t\t\t\t\t\t\t\t   rpcallowip=允许链接rpc ip地址\n\t\t\t\t\t\t\t\t\t\t   server=1        //打开服务\n\t\t\t\t\t\t\t\t\t\t   daemon=1        //后台运行守护\n\t\t\t\t\t\t\t\t\t\t   mainnet=1       //主链\n\t\t\t\t\t\t\t\t\t\t   addnode=mainnet.z.cash //主链节点\n\n\t\t\t\t\t\t\t\t\t\t   附2：\n\n\t\t\t\t\t\t\t\t\t\t   //zcash命令\n\n\t\t\t\t\t\t\t\t\t\t   == Blockchain ==\n\t\t\t\t\t\t\t\t\t\t   getbestblockhash\n\t\t\t\t\t\t\t\t\t\t   getblock \"hash|height\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getblockchaininfo\n\t\t\t\t\t\t\t\t\t\t   getblockcount\n\t\t\t\t\t\t\t\t\t\t   getblockhash index\n\t\t\t\t\t\t\t\t\t\t   getblockheader \"hash\" ( verbose )\n\t\t\t\t\t\t\t\t\t\t   getchaintips\ngetdifficulty\ngetmempoolinfo\ngetrawmempool ( verbose )\n\t\tgettxout \"txid\" n ( includemempool )\n\t\tgettxoutproof [\"txid\",...] ( blockhash )\n\t\tgettxoutsetinfo\n\t\tverifychain ( checklevel numblocks )\n\t\tverifytxoutproof \"proof\"\n\n\t\t== Control ==\n\t\tgetinfo\n\t\thelp ( \"command\" )\n\t\tstop\n\n\t\t== Disclosure ==\n\t\tz_getpaymentdisclosure \"txid\" \"js_index\" \"output_index\" (\"message\") \n\t\tz_validatepaymentdisclosure \"paymentdisclosure\"\n\n\t\t== Generating ==\n\t\tgenerate numblocks\n\t\tgetgenerate\n\t\tsetgenerate generate ( genproclimit )\n\n\t\t== Mining ==\n\t\tgetblocksubsidy height\n\t\tgetblocktemplate ( \"jsonrequestobject\" )\n\t\tgetlocalsolps\n\t\tgetmininginfo\n\t\tgetnetworkhashps ( blocks height )\n\t\tgetnetworksolps ( blocks height )\n\t\tprioritisetransaction <txid> <priority delta> <fee delta>\n\t\tsubmitblock \"hexdata\" ( \"jsonparametersobject\" )\n\n\t\t== Network ==\n\t\taddnode \"node\" \"add|remove|onetry\"\n\t\tclearbanned\n\t\tdisconnectnode \"node\" \n\t\tgetaddednodeinfo dns ( \"node\" )\n\t\tgetconnectioncount\n\t\tgetnettotals\n\t\tgetnetworkinfo\n\t\tgetpeerinfo\n\t\tlistbanned\n\t\tping\n\t\tsetban \"ip(/netmask)\" \"add|remove\" (bantime) (absolute)\n\n\t\t== Rawtransactions ==\n\t\tcreaterawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...}\n\t\tdecoderawtransaction \"hexstring\"\n\t\tdecodescript \"hex\"\n\t\tfundrawtransaction \"hexstring\"\n\t\tgetrawtransaction \"txid\" ( verbose )\n\t\tsendrawtransaction \"hexstring\" ( allowhighfees )\n\t\tsignrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n\n\t\t== Util ==\n\t\tcreatemultisig nrequired [\"key\",...]\n\t\testimatefee nblocks\n\t\testimatepriority nblocks\n\t\tvalidateaddress \"zcashaddress\"\n\t\tverifymessage \"zcashaddress\" \"signature\" \"message\"\n\t\tz_validateaddress \"zaddr\"\n\n\t\t== Wallet ==\n\t\taddmultisigaddress nrequired [\"key\",...] ( \"account\" )\n\t\tbackupwallet \"destination\"\n\t\tdumpprivkey \"zcashaddress\"\n\t\tdumpwallet \"filename\"\n\t\tencryptwallet \"passphrase\"\n\t\tgetaccount \"zcashaddress\"\n\t\tgetaccountaddress \"account\"\n\t\tgetaddressesbyaccount \"account\"\n\t\tgetbalance ( \"account\" minconf includeWatchonly )\n\t\tgetnewaddress ( \"account\" )\n\t\tgetrawchangeaddress\n\t\tgetreceivedbyaccount \"account\" ( minconf )\n\t\tgetreceivedbyaddress \"zcashaddress\" ( minconf )\n\t\tgettransaction \"txid\" ( includeWatchonly )\n\t\tgetunconfirmedbalance\n\t\tgetwalletinfo\n\t\timportaddress \"address\" ( \"label\" rescan )\n\t\timportprivkey \"zcashprivkey\" ( \"label\" rescan )\n\t\timportwallet \"filename\"\n\t\tkeypoolrefill ( newsize )\n\t\tlistaccounts ( minconf includeWatchonly)\n\t\tlistaddressgroupings\n\t\tlistlockunspent\n\t\tlistreceivedbyaccount ( minconf includeempty includeWatchonly)\n\t\tlistreceivedbyaddress ( minconf includeempty includeWatchonly)\n\t\tlistsinceblock ( \"blockhash\" target-confirmations includeWatchonly)\n\t\tlisttransactions ( \"account\" count from includeWatchonly)\n\t\tlistunspent ( minconf maxconf  [\"address\",...] )\n\t\tlockunspent unlock [{\"txid\":\"txid\",\"vout\":n},...]\n\t\tmove \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n\t\tsendfrom \"fromaccount\" \"tozcashaddress\" amount ( minconf \"comment\" \"comment-to\" )\n\t\tsendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n\t\tsendtoaddress \"zcashaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n\t\tsetaccount \"zcashaddress\" \"account\"\n\t\tsettxfee amount\n\t\tsignmessage \"zcashaddress\" \"message\"\n\t\tz_exportkey \"zaddr\"\n\t\tz_exportviewingkey \"zaddr\"\n\t\tz_exportwallet \"filename\"\n\t\tz_getbalance \"address\" ( minconf )\n\t\tz_getnewaddress\n\t\tz_getoperationresult ([\"operationid\", ... ]) \n\t\tz_getoperationstatus ([\"operationid\", ... ]) \n\t\tz_gettotalbalance ( minconf includeWatchonly )\n\t\tz_importkey \"zkey\" ( rescan startHeight )\n\t\tz_importviewingkey \"vkey\" ( rescan startHeight )\n\t\tz_importwallet \"filename\"\n\t\tz_listaddresses ( includeWatchonly )\n\t\tz_listoperationids\n\t\tz_listreceivedbyaddress \"address\" ( minconf )\n\t\tz_sendmany \"fromaddress\" [{\"address\":... ,\"amount\":...},...] ( minconf ) ( fee )\n\t\tz_shieldcoinbase \"fromaddress\" \"tozaddress\" ( fee ) ( limit )\n\t\tzcbenchmark benchmarktype samplecount\n\t\tzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\n\t\tzcrawkeygen\n\t\tzcrawreceive zcsecretkey encryptednote\n\t\tzcsamplejoinsplit\n\n","slug":"linux下Zcash钱包使用教程","published":1,"updated":"2018-03-07T10:05:28.474Z","layout":"post","photos":[],"link":"","_id":"cjejlcu5w0001l8jxjxa784hv","content":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥.  ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的.</p>\n<p>目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。</p>\n</blockquote>\n<p>现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。</p>\n<p>下载地址 ： <a href=\"https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz\" target=\"_blank\" rel=\"noopener\">https://z.cash/downloads/zcash-1.0.14-linux64.tar.gz</a><br>hash     :  352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a</p>\n<p>下载后请务必进行哈希值验证，以保证文件的真实和准确性。</p>\n<p>tar -xvf zcash-1.0.14-linux64.tar.gz       //解压缩<br>mv -t /usr/local/bin/ zcash-1.0.14/bin/*   //移动可执行文件</p>\n<pre><code>现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。\n\nzcash-fetch-params\n\n这里由于国内网络的原因，可能会失败，请多试几次。\n\n验证通过后，我们需要对客户端进行配置。\n\nmkdir ~/.zcash //创建zcash目录\n\nvim zcash.conf \n\n以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。\n\n//这是测试链接的配置\naddnode=testnet.z.cash    //节点\nrpcuser=test              //rpc用户名\nrpcpassword=test          //rpc密码\ngen=0                     //屏蔽cpu挖矿\ntestnet=1                 //开启测试链\nrpcallowip=100.100.60.10 //允许访问的IP\nrpcport=8333             //rpc端口号\nequihashsolver=tromp     //指定算法，非挖矿钱包可以删除\n\n\n好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。\n\n下面提供一些zcash节点常用命令：\n\nzcash-cli getinfo                           //显示节点信息\nzcashd -daemon                              //后台启动zcash守护\nzcash-cli getnetworkhashps                  //获取全网算力\nzcash-cli z_getnewaddress                    //生成一个Z-addr\nzcash-cli getnewaddress                      //生成一个t-addr                   \nzcas-cli getblockhash                       //区块高度\nzcash-cli getaddressesbyaccount &quot;&quot;         //显示所有t-addr钱包\nzcash-cli z_listaddresses                   //显示所有Z-addr钱包\nzcash-cli z_getbalance &quot;&quot;                   //z钱包余额\n\n如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。\n\n\n附1：\n\nzcash钱包配置：\n\n//这里是zcash钱包主链配置\n\nrpcuser=rpc用户名\nrpcpassword=rpc密码\nrpcport=rpc端口\nrpcallowip=允许链接rpc ip地址\nserver=1        //打开服务\ndaemon=1        //后台运行守护\nmainnet=1       //主链\naddnode=mainnet.z.cash //主链节点\n\n附2：\n\n//zcash命令\n\n== Blockchain ==\ngetbestblockhash\ngetblock &quot;hash|height&quot; ( verbose )\ngetblockchaininfo\ngetblockcount\ngetblockhash index\ngetblockheader &quot;hash&quot; ( verbose )\ngetchaintips\n</code></pre><p>getdifficulty<br>getmempoolinfo<br>getrawmempool ( verbose )<br>        gettxout “txid” n ( includemempool )<br>        gettxoutproof [“txid”,…] ( blockhash )<br>        gettxoutsetinfo<br>        verifychain ( checklevel numblocks )<br>        verifytxoutproof “proof”</p>\n<pre><code>== Control ==\ngetinfo\nhelp ( &quot;command&quot; )\nstop\n\n== Disclosure ==\nz_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) \nz_validatepaymentdisclosure &quot;paymentdisclosure&quot;\n\n== Generating ==\ngenerate numblocks\ngetgenerate\nsetgenerate generate ( genproclimit )\n\n== Mining ==\ngetblocksubsidy height\ngetblocktemplate ( &quot;jsonrequestobject&quot; )\ngetlocalsolps\ngetmininginfo\ngetnetworkhashps ( blocks height )\ngetnetworksolps ( blocks height )\nprioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;\nsubmitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )\n\n== Network ==\naddnode &quot;node&quot; &quot;add|remove|onetry&quot;\nclearbanned\ndisconnectnode &quot;node&quot; \ngetaddednodeinfo dns ( &quot;node&quot; )\ngetconnectioncount\ngetnettotals\ngetnetworkinfo\ngetpeerinfo\nlistbanned\nping\nsetban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute)\n\n== Rawtransactions ==\ncreaterawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...}\ndecoderawtransaction &quot;hexstring&quot;\ndecodescript &quot;hex&quot;\nfundrawtransaction &quot;hexstring&quot;\ngetrawtransaction &quot;txid&quot; ( verbose )\nsendrawtransaction &quot;hexstring&quot; ( allowhighfees )\nsignrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype )\n\n== Util ==\ncreatemultisig nrequired [&quot;key&quot;,...]\nestimatefee nblocks\nestimatepriority nblocks\nvalidateaddress &quot;zcashaddress&quot;\nverifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot;\nz_validateaddress &quot;zaddr&quot;\n\n== Wallet ==\naddmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )\nbackupwallet &quot;destination&quot;\ndumpprivkey &quot;zcashaddress&quot;\ndumpwallet &quot;filename&quot;\nencryptwallet &quot;passphrase&quot;\ngetaccount &quot;zcashaddress&quot;\ngetaccountaddress &quot;account&quot;\ngetaddressesbyaccount &quot;account&quot;\ngetbalance ( &quot;account&quot; minconf includeWatchonly )\ngetnewaddress ( &quot;account&quot; )\ngetrawchangeaddress\ngetreceivedbyaccount &quot;account&quot; ( minconf )\ngetreceivedbyaddress &quot;zcashaddress&quot; ( minconf )\ngettransaction &quot;txid&quot; ( includeWatchonly )\ngetunconfirmedbalance\ngetwalletinfo\nimportaddress &quot;address&quot; ( &quot;label&quot; rescan )\nimportprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan )\nimportwallet &quot;filename&quot;\nkeypoolrefill ( newsize )\nlistaccounts ( minconf includeWatchonly)\nlistaddressgroupings\nlistlockunspent\nlistreceivedbyaccount ( minconf includeempty includeWatchonly)\nlistreceivedbyaddress ( minconf includeempty includeWatchonly)\nlistsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)\nlisttransactions ( &quot;account&quot; count from includeWatchonly)\nlistunspent ( minconf maxconf  [&quot;address&quot;,...] )\nlockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...]\nmove &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )\nsendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )\nsendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] )\nsendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount )\nsetaccount &quot;zcashaddress&quot; &quot;account&quot;\nsettxfee amount\nsignmessage &quot;zcashaddress&quot; &quot;message&quot;\nz_exportkey &quot;zaddr&quot;\nz_exportviewingkey &quot;zaddr&quot;\nz_exportwallet &quot;filename&quot;\nz_getbalance &quot;address&quot; ( minconf )\nz_getnewaddress\nz_getoperationresult ([&quot;operationid&quot;, ... ]) \nz_getoperationstatus ([&quot;operationid&quot;, ... ]) \nz_gettotalbalance ( minconf includeWatchonly )\nz_importkey &quot;zkey&quot; ( rescan startHeight )\nz_importviewingkey &quot;vkey&quot; ( rescan startHeight )\nz_importwallet &quot;filename&quot;\nz_listaddresses ( includeWatchonly )\nz_listoperationids\nz_listreceivedbyaddress &quot;address&quot; ( minconf )\nz_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee )\nz_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit )\nzcbenchmark benchmarktype samplecount\nzcrawjoinsplit rawtx inputs outputs vpub_old vpub_new\nzcrawkeygen\nzcrawreceive zcsecretkey encryptednote\nzcsamplejoinsplit\n</code></pre>"},{"title":"zcash矿池之Z-NOMP(Node Open Mining Portal)","comments":0,"date":"2018-03-02T05:00:28.000Z","img":null,"_content":"\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\nz-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n  \n1.安装z-nomp依赖：\n  \n``` shell\n    sudo apt-get install update\n    sudo apt-get install build-essential libsodium-dev npm git\n    sudo npm install n -g\n    sudo n 8.9.4\n```\n\n2.下载和安装z-nomp：\n\n``` shell\n\tgit clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\tcd /pool\n\tnpm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\tnpm update\n\tsudo npm install   #就算root账户也一定要加sudo\n```\n\n3.矿池配置文件：\n修改示例文件config_example.json。\n\n``` shell\n\tmv config_example.json config.json\n\tvim config.json\n```\n\n下面提供一些主要配置说明：\n``` json\n\t\"redis\": {\n\t\t\"host\": \"127.0.0.1\",   #redis地址\n\t\t\"port\": 6379,          #redis端口\n\t\t\"password\": \"\"      #redis密码\n\t}\n    },\n\t    \n\t\"website\": {\n\t\t\"enabled\": true,\n\t\t\"host\": \"0.0.0.0\",                 #website地址\n\t\t\"port\": 8080,                      #website端口\n\t\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\"stats\": {\n\t\t\t\"updateInterval\": 30,\n\t\t\t\"historicalRetention\": 14400,\n\t\t\t\"hashrateWindow\": 300\n\t\t},\n\t\t\t\t\t\t\t           \n\t\t\"tlsOptions\" : {\n\t\t\t\"enabled\": false,          #ssl挖矿\n\t\t\t\"cert\": \"\",                #ssl公钥地址\n\t\t\t\"key\": \"\"                  #ssl私钥地址\n\t\t}\n\t},\n```\n\n4.数字货币配置：\n\n进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\n``` shell\n\tcd pool_config\n\tmv zcash_example.json zcash.json\n\tvim zcash.json\n```\n\n主要配置文件说明：\n\n``` json\n\t\"enabled\": true,         #设置打开coin\n\t\"coin\": \"zcash.json\",    #coin配置文件\n\t\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\"zAddress\": \"\",          #Z地址\n\t\"tAddress\": \"\",          #T地址\n\n\t\"rewardRecipients\": {\n\t\t\"\": 0.2,             #手续费和接收手续费地址\n\t},\n\n\t\"paymentProcessing\": {\n\t\t\"minConf\": 10,\n\t\t\"enabled\": false,             #支付进程\n\t\t\"paymentMode\": \"prop\",        #挖矿模式\n\t\t\"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\"paymentInterval\": 20, \n\t\t\"minimumPayment\": 0.1,         #最低支付额\n\t\t\"maxBlocksPerPayment\": 1,     \n\t\t\"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\"host\": \"127.0.0.1\",       \n\t\t\t\"port\": 19332,\n\t\t\t\"user\": \"testuser\",\n\t\t\t\"password\": \"testpass\"\n\t\t}\n\t},\n\t\n\t\"ports\": {                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\"3032\": {\n\t\t\"diff\": 0.05,\n\t\t\"tls\": false,\n\t\t\"varDiff\": {\n\t\t\t\"minDiff\": 0.04,\n\t\t\t\"maxDiff\": 16,\n\t\t\t\"targetTime\": 15,\n\t\t\t\"retargetTime\": 60,\n\t\t\t\"variancePercent\": 30\n\t\t}\n\t}\n\t},\n\t\n\t\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t{\n\t\t\t\"host\": \"127.0.0.1\",\n\t\t\t\"port\": 18232,\n\t\t\t\"user\": \"rpcuser\",\n\t\t\t\"password\": \"rpcpassword\"\n\t\t}\n    ],\n```\n\n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","source":"_posts/zcash矿池之Z-NOMP-Node-Open-Mining-Portal.md","raw":"---\ntitle: zcash矿池之Z-NOMP(Node Open Mining Portal)\ncomments: false\ndate: 2018-03-02 13:00:28\ncategories: 矿池\ntags: \n- lucas556 \n- 矿池 \n- zcash\nimg:\n---\n\n**Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.**\n\nz-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。\n\n**警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.**\n\n首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。\n  \n1.安装z-nomp依赖：\n  \n``` shell\n    sudo apt-get install update\n    sudo apt-get install build-essential libsodium-dev npm git\n    sudo npm install n -g\n    sudo n 8.9.4\n```\n\n2.下载和安装z-nomp：\n\n``` shell\n\tgit clone https://github.com/joshuayabut/node-open-mining-portal.git /pool\n\tcd /pool\n\tnpm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像\n\tnpm update\n\tsudo npm install   #就算root账户也一定要加sudo\n```\n\n3.矿池配置文件：\n修改示例文件config_example.json。\n\n``` shell\n\tmv config_example.json config.json\n\tvim config.json\n```\n\n下面提供一些主要配置说明：\n``` json\n\t\"redis\": {\n\t\t\"host\": \"127.0.0.1\",   #redis地址\n\t\t\"port\": 6379,          #redis端口\n\t\t\"password\": \"\"      #redis密码\n\t}\n    },\n\t    \n\t\"website\": {\n\t\t\"enabled\": true,\n\t\t\"host\": \"0.0.0.0\",                 #website地址\n\t\t\"port\": 8080,                      #website端口\n\t\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    \n\t\t\"stats\": {\n\t\t\t\"updateInterval\": 30,\n\t\t\t\"historicalRetention\": 14400,\n\t\t\t\"hashrateWindow\": 300\n\t\t},\n\t\t\t\t\t\t\t           \n\t\t\"tlsOptions\" : {\n\t\t\t\"enabled\": false,          #ssl挖矿\n\t\t\t\"cert\": \"\",                #ssl公钥地址\n\t\t\t\"key\": \"\"                  #ssl私钥地址\n\t\t}\n\t},\n```\n\n4.数字货币配置：\n\n进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.\n\n``` shell\n\tcd pool_config\n\tmv zcash_example.json zcash.json\n\tvim zcash.json\n```\n\n主要配置文件说明：\n\n``` json\n\t\"enabled\": true,         #设置打开coin\n\t\"coin\": \"zcash.json\",    #coin配置文件\n\t\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 \n\t\"zAddress\": \"\",          #Z地址\n\t\"tAddress\": \"\",          #T地址\n\n\t\"rewardRecipients\": {\n\t\t\"\": 0.2,             #手续费和接收手续费地址\n\t},\n\n\t\"paymentProcessing\": {\n\t\t\"minConf\": 10,\n\t\t\"enabled\": false,             #支付进程\n\t\t\"paymentMode\": \"prop\",        #挖矿模式\n\t\t\"_comment_paymentMode\":\"prop, pplnt\",\n\t\t\"paymentInterval\": 20, \n\t\t\"minimumPayment\": 0.1,         #最低支付额\n\t\t\"maxBlocksPerPayment\": 1,     \n\t\t\"daemon\": {                    #节点信息 这里为支付节点\n\t\t\t\"host\": \"127.0.0.1\",       \n\t\t\t\"port\": 19332,\n\t\t\t\"user\": \"testuser\",\n\t\t\t\"password\": \"testpass\"\n\t\t}\n\t},\n\t\n\t\"ports\": {                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\"3032\": {\n\t\t\"diff\": 0.05,\n\t\t\"tls\": false,\n\t\t\"varDiff\": {\n\t\t\t\"minDiff\": 0.04,\n\t\t\t\"maxDiff\": 16,\n\t\t\t\"targetTime\": 15,\n\t\t\t\"retargetTime\": 60,\n\t\t\t\"variancePercent\": 30\n\t\t}\n\t}\n\t},\n\t\n\t\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致\n\t\t{\n\t\t\t\"host\": \"127.0.0.1\",\n\t\t\t\"port\": 18232,\n\t\t\t\"user\": \"rpcuser\",\n\t\t\t\"password\": \"rpcpassword\"\n\t\t}\n    ],\n```\n\n5.coin配置：\n\n进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。\n\nok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。\n","slug":"zcash矿池之Z-NOMP-Node-Open-Mining-Portal","published":1,"updated":"2018-03-07T10:05:40.401Z","layout":"post","photos":[],"link":"","_id":"cjejlcu650004l8jx97foepq8","content":"<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<p><strong>警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.</strong></p>\n<p>首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。</p>\n<p>1.安装z-nomp依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\">sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n<p>2.下载和安装z-nomp：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\">cd /pool</span><br><span class=\"line\">npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">npm update</span><br><span class=\"line\">sudo npm install   #就算root账户也一定要加sudo</span><br></pre></td></tr></table></figure>\n<p>3.矿池配置文件：<br>修改示例文件config_example.json。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv config_example.json config.json</span><br><span class=\"line\">vim config.json</span><br></pre></td></tr></table></figure>\n<p>下面提供一些主要配置说明：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"redis\": &#123;</span><br><span class=\"line\">\t\"host\": \"127.0.0.1\",   #redis地址</span><br><span class=\"line\">\t\"port\": 6379,          #redis端口</span><br><span class=\"line\">\t\"password\": \"\"      #redis密码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\"website\": &#123;</span><br><span class=\"line\">\t\"enabled\": true,</span><br><span class=\"line\">\t\"host\": \"0.0.0.0\",                 #website地址</span><br><span class=\"line\">\t\"port\": 8080,                      #website端口</span><br><span class=\"line\">\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    </span><br><span class=\"line\">\t\"stats\": &#123;</span><br><span class=\"line\">\t\t\"updateInterval\": 30,</span><br><span class=\"line\">\t\t\"historicalRetention\": 14400,</span><br><span class=\"line\">\t\t\"hashrateWindow\": 300</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t\t           </span><br><span class=\"line\">\t\"tlsOptions\" : &#123;</span><br><span class=\"line\">\t\t\"enabled\": false,          #ssl挖矿</span><br><span class=\"line\">\t\t\"cert\": \"\",                #ssl公钥地址</span><br><span class=\"line\">\t\t\"key\": \"\"                  #ssl私钥地址</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>4.数字货币配置：</p>\n<p>进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pool_config</span><br><span class=\"line\">mv zcash_example.json zcash.json</span><br><span class=\"line\">vim zcash.json</span><br></pre></td></tr></table></figure>\n<p>主要配置文件说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"enabled\": true,         #设置打开coin</span><br><span class=\"line\">\"coin\": \"zcash.json\",    #coin配置文件</span><br><span class=\"line\">\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 </span><br><span class=\"line\">\"zAddress\": \"\",          #Z地址</span><br><span class=\"line\">\"tAddress\": \"\",          #T地址</span><br><span class=\"line\"></span><br><span class=\"line\">\"rewardRecipients\": &#123;</span><br><span class=\"line\">\t\"\": 0.2,             #手续费和接收手续费地址</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"paymentProcessing\": &#123;</span><br><span class=\"line\">\t\"minConf\": 10,</span><br><span class=\"line\">\t\"enabled\": false,             #支付进程</span><br><span class=\"line\">\t\"paymentMode\": \"prop\",        #挖矿模式</span><br><span class=\"line\">\t\"_comment_paymentMode\":\"prop, pplnt\",</span><br><span class=\"line\">\t\"paymentInterval\": 20, </span><br><span class=\"line\">\t\"minimumPayment\": 0.1,         #最低支付额</span><br><span class=\"line\">\t\"maxBlocksPerPayment\": 1,     </span><br><span class=\"line\">\t\"daemon\": &#123;                    #节点信息 这里为支付节点</span><br><span class=\"line\">\t\t\"host\": \"127.0.0.1\",       </span><br><span class=\"line\">\t\t\"port\": 19332,</span><br><span class=\"line\">\t\t\"user\": \"testuser\",</span><br><span class=\"line\">\t\t\"password\": \"testpass\"</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"ports\": &#123;                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         </span><br><span class=\"line\">\t\"3032\": &#123;</span><br><span class=\"line\">\t\"diff\": 0.05,</span><br><span class=\"line\">\t\"tls\": false,</span><br><span class=\"line\">\t\"varDiff\": &#123;</span><br><span class=\"line\">\t\t\"minDiff\": 0.04,</span><br><span class=\"line\">\t\t\"maxDiff\": 16,</span><br><span class=\"line\">\t\t\"targetTime\": 15,</span><br><span class=\"line\">\t\t\"retargetTime\": 60,</span><br><span class=\"line\">\t\t\"variancePercent\": 30</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"host\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"port\"</span>: <span class=\"number\">18232</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"user\"</span>: <span class=\"string\">\"rpcuser\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"password\"</span>: <span class=\"string\">\"rpcpassword\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   ],</span><br></pre></td></tr></table></figure>\n<p>5.coin配置：</p>\n<p>进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。</p>\n<p>ok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Zcash作为采用零知识证明（zk-SNARKS）实现完全隐私保护的加密货币,在技术地位上成为竞争币一哥指日可待.</strong></p>\n<p>z-classic在github发布的矿池Z-NOMP，是基于Node Open Mining Portal的Equihash矿池，可以部署的币种有zen，zcl和zec等使用Equihash算法的矿池。</p>\n<p><strong>警告:请勿直接用于生产环境使用该软件,任何内容的修改都会对矿池造成损失.</strong></p>\n<p>首先，部署环境，我们使用的是ubuntu server 16.04 x64的系统。</p>\n<p>1.安装z-nomp依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install update</span><br><span class=\"line\">sudo apt-get install build-essential libsodium-dev npm git</span><br><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">sudo n 8.9.4</span><br></pre></td></tr></table></figure>\n<p>2.下载和安装z-nomp：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/joshuayabut/node-open-mining-portal.git /pool</span><br><span class=\"line\">cd /pool</span><br><span class=\"line\">npm config set registry https://registry.npm.taobao.org  #使用淘宝npm镜像</span><br><span class=\"line\">npm update</span><br><span class=\"line\">sudo npm install   #就算root账户也一定要加sudo</span><br></pre></td></tr></table></figure>\n<p>3.矿池配置文件：<br>修改示例文件config_example.json。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv config_example.json config.json</span><br><span class=\"line\">vim config.json</span><br></pre></td></tr></table></figure>\n<p>下面提供一些主要配置说明：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"redis\": &#123;</span><br><span class=\"line\">\t\"host\": \"127.0.0.1\",   #redis地址</span><br><span class=\"line\">\t\"port\": 6379,          #redis端口</span><br><span class=\"line\">\t\"password\": \"\"      #redis密码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\"website\": &#123;</span><br><span class=\"line\">\t\"enabled\": true,</span><br><span class=\"line\">\t\"host\": \"0.0.0.0\",                 #website地址</span><br><span class=\"line\">\t\"port\": 8080,                      #website端口</span><br><span class=\"line\">\t\"stratumHost\": \"cryppit.com\",      #挖矿域名    </span><br><span class=\"line\">\t\"stats\": &#123;</span><br><span class=\"line\">\t\t\"updateInterval\": 30,</span><br><span class=\"line\">\t\t\"historicalRetention\": 14400,</span><br><span class=\"line\">\t\t\"hashrateWindow\": 300</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t\t           </span><br><span class=\"line\">\t\"tlsOptions\" : &#123;</span><br><span class=\"line\">\t\t\"enabled\": false,          #ssl挖矿</span><br><span class=\"line\">\t\t\"cert\": \"\",                #ssl公钥地址</span><br><span class=\"line\">\t\t\"key\": \"\"                  #ssl私钥地址</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>4.数字货币配置：</p>\n<p>进入pool_config，重新命名zcash_example.json为zcash.json并修改示例内容.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd pool_config</span><br><span class=\"line\">mv zcash_example.json zcash.json</span><br><span class=\"line\">vim zcash.json</span><br></pre></td></tr></table></figure>\n<p>主要配置文件说明：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"enabled\": true,         #设置打开coin</span><br><span class=\"line\">\"coin\": \"zcash.json\",    #coin配置文件</span><br><span class=\"line\">\"address\": \"\",           #coinbase地址，即挖到块后保存的地址，且该地址一定要在节点中 </span><br><span class=\"line\">\"zAddress\": \"\",          #Z地址</span><br><span class=\"line\">\"tAddress\": \"\",          #T地址</span><br><span class=\"line\"></span><br><span class=\"line\">\"rewardRecipients\": &#123;</span><br><span class=\"line\">\t\"\": 0.2,             #手续费和接收手续费地址</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"paymentProcessing\": &#123;</span><br><span class=\"line\">\t\"minConf\": 10,</span><br><span class=\"line\">\t\"enabled\": false,             #支付进程</span><br><span class=\"line\">\t\"paymentMode\": \"prop\",        #挖矿模式</span><br><span class=\"line\">\t\"_comment_paymentMode\":\"prop, pplnt\",</span><br><span class=\"line\">\t\"paymentInterval\": 20, </span><br><span class=\"line\">\t\"minimumPayment\": 0.1,         #最低支付额</span><br><span class=\"line\">\t\"maxBlocksPerPayment\": 1,     </span><br><span class=\"line\">\t\"daemon\": &#123;                    #节点信息 这里为支付节点</span><br><span class=\"line\">\t\t\"host\": \"127.0.0.1\",       </span><br><span class=\"line\">\t\t\"port\": 19332,</span><br><span class=\"line\">\t\t\"user\": \"testuser\",</span><br><span class=\"line\">\t\t\"password\": \"testpass\"</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"ports\": &#123;                 #支付端口和难度\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         </span><br><span class=\"line\">\t\"3032\": &#123;</span><br><span class=\"line\">\t\"diff\": 0.05,</span><br><span class=\"line\">\t\"tls\": false,</span><br><span class=\"line\">\t\"varDiff\": &#123;</span><br><span class=\"line\">\t\t\"minDiff\": 0.04,</span><br><span class=\"line\">\t\t\"maxDiff\": 16,</span><br><span class=\"line\">\t\t\"targetTime\": 15,</span><br><span class=\"line\">\t\t\"retargetTime\": 60,</span><br><span class=\"line\">\t\t\"variancePercent\": 30</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\"daemons\": [                #节点  这里为挖矿节点 可与支付节点一致</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">\"host\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"port\"</span>: <span class=\"number\">18232</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"user\"</span>: <span class=\"string\">\"rpcuser\"</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">\"password\"</span>: <span class=\"string\">\"rpcpassword\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   ],</span><br></pre></td></tr></table></figure>\n<p>5.coin配置：</p>\n<p>进入coins目录可以看到开发者提供了zclassic和zcash等coin的配置文件，同时zcash_testnet.json为zcash的testnet方便测试，使用testnet进行测试时请保证节点一定在testnet模式。如果需要加增加coin请参考开发者提供的其他coin信息进行修改，同时在pool_config里增加池信息，以后我们在进行陆续说明。</p>\n<p>ok，现在已经配置完成，我们返回/pool目录 ，使用npm start 来启动z-nomp 矿池，就可以把矿机接入来进行挖矿了。</p>\n"},{"title":"以太坊wiki-设计原理翻译一","comments":0,"date":"2018-02-09T03:22:26.000Z","img":null,"_content":"## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","source":"_posts/以太坊wiki-设计原理翻译一.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译一\ncomments: false\ndate: 2018-02-09 11:22:26\ncategories: 区块链\ntags: \n- ZhouFyk \n- 以太坊 \n- ethereum\nimg:\n---\n## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)\n\n尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。\n\n## 原则\n\n以太坊协议的设计过程遵循了下列原则：\n\n1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。\n\n2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。\n\n3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。\n\n4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。\n\n5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。\n\n这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。\n\n## 区块链层次的协议\n\n这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。\n\n### 账户和非 `UTXOs`\n\n比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：\n\n1. 每一个被引用的输入必须是合法的并且没有被花费过\n2. 交易中的每一个输入都必须有一个符合该输入的主人的签名\n3. 所有的输入必须大于等于所有的输出\n\n因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。\n\n![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)\n\n(图片来自 `https://bitcoin.org/en/developer-guide`)\n\n以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。\n\n`UTXOs` 的好处：\n\n1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。\n2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。\n\n账户的好处：\n\n1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。\n2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。\n3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。\n4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。\n\n我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。\n\n账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。\n","slug":"以太坊wiki-设计原理翻译一","published":1,"updated":"2018-03-07T10:05:56.271Z","layout":"post","photos":[],"link":"","_id":"cjejlcu690005l8jxlf1sgrrx","content":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计原理原文链接\"><a href=\"#设计原理原文链接\" class=\"headerlink\" title=\"设计原理原文链接\"></a><a href=\"https://github.com/ethereum/wiki/wiki/Design-Rationale\" target=\"_blank\" rel=\"noopener\">设计原理原文链接</a></h2><p>尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>以太坊协议的设计过程遵循了下列原则：</p>\n<ol>\n<li><p><strong>三明治复杂模型</strong>：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，<code>leveldb</code>存储接口和有线协议等。但是，这种偏好并不是绝对的。</p>\n</li>\n<li><p><strong>自由</strong>：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 <code>OP_RETURN</code> 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 <code>Ethereum</code> 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（<code>bloat-producing</code>）的方式内部化其活动成本（即 <code>Pigovian</code> 税）。</p>\n</li>\n<li><p><strong>概念</strong>：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 <code>LOG</code> 操作码作为向（特别是轻客户端）<code>dapps</code> 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。</p>\n</li>\n<li><p><strong>我们没有特征</strong>：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。</p>\n</li>\n<li><p><strong>非风险规避</strong>：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。</p>\n</li>\n</ol>\n<p>这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。</p>\n<h2 id=\"区块链层次的协议\"><a href=\"#区块链层次的协议\" class=\"headerlink\" title=\"区块链层次的协议\"></a>区块链层次的协议</h2><p>这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。</p>\n<h3 id=\"账户和非-UTXOs\"><a href=\"#账户和非-UTXOs\" class=\"headerlink\" title=\"账户和非 UTXOs\"></a>账户和非 <code>UTXOs</code></h3><p>比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 <code>unspent transaction outputs(UTXOs)</code> 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：</p>\n<ol>\n<li>每一个被引用的输入必须是合法的并且没有被花费过</li>\n<li>交易中的每一个输入都必须有一个符合该输入的主人的签名</li>\n<li>所有的输入必须大于等于所有的输出</li>\n</ol>\n<p>因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。</p>\n<p><img src=\"https://bitcoin.org/img/dev/en-transaction-propagation.svg\" alt=\"\"></p>\n<p>(图片来自 <code>https://bitcoin.org/en/developer-guide</code>)</p>\n<p>以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。</p>\n<p><code>UTXOs</code> 的好处：</p>\n<ol>\n<li><strong>高度的隐私性</strong>：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 <code>dapps</code> 就不是那么合适了，因为 <code>dapps</code> 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。</li>\n<li><strong>潜在的可扩展性范例</strong>：<code>UTXO</code> 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 <code>Merkle</code> 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 <code>Merkle</code> 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 <code>UTXO</code> 依赖的可伸缩性范例确实存在。</li>\n</ol>\n<p>账户的好处：</p>\n<ol>\n<li><strong>节省了大量空间</strong>：例如，如果一个账户有 5 个 <code>UTXO</code>，然后将一个 <code>UTXO</code> 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 <code>txid</code>，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 <code>nonce</code>)。实际上，要求的存储空间没有这么大，因为账户需要存储在 <code>Patricia</code> 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。</li>\n<li><strong>更好的可替代性</strong>：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。</li>\n<li><strong>简单</strong>：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 <code>UTXO</code> 模型来实现 <code>dapp</code>，但本质上是通过赋予脚本能力，来限制给定的 <code>UTXO</code> 可以以哪种 <code>UTXO</code> 类型来花费，并且需要花费包括根据脚本评估的 <code>Merkle</code> 树中的应用程序状态改变的证明的 <code>Merkle</code> 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。</li>\n<li><strong>持久的轻客户端引用</strong>：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 <code>UTXO</code> 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 <code>UTXO</code> 状态传播机制的长期运行的 <code>dapps</code> 来说，这是一个特别麻烦的问题。</li>\n</ol>\n<p>我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 <code>dapps</code> 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。</p>\n<p>账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 <code>nonce</code> 值，这样账户就可以对使用的 <code>nonce</code> 进行跟踪，并且只接受当前 <code>nonce</code> 值比之前的 <code>nonce</code> 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 <code>nonce</code>。矿工或者其他用户会对账户进行 <code>ping</code> 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 <code>1.0</code> 的发展; <code>1.1</code> 及以后可能会使用这样一个系统。</p>\n"},{"title":"以太坊wiki-设计原理翻译三","comments":0,"date":"2018-02-24T02:39:17.000Z","img":null,"_content":"[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","source":"_posts/以太坊wiki-设计原理翻译三.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译三\ncomments: false\ndate: 2018-02-24 10:39:17\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊\nimg:\n---\n[以太坊wiki-设计原理翻译二](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/)\n\n## 树的使用方式\n\n警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:[http://en.wikipedia.org/wiki/Bloom_filter](http://en.wikipedia.org/wiki/Bloom_filter)\n\n以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 `key 0`:第一笔要执行的交易，`key 1`:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 `RLP` 编码的数据结构：\n\n\t[ medstate, gas_used, logbloom, logs ]\n\n对应的：\n* `medstate` 是处理交易之后的状态树的根。\n* `gas_used` 是处理该笔交易之后消耗的燃料数量。\n* `logs` 是交易执行过程中由 `LOG0 ... LOG4` 操作码生成的 `[address, [topic1, topic2...], data]`形式的项目列表（包括主调用和次调用）。`address` 是产生日志的合约的地址，`topics` 最多为 4 个 32 字节值，`data` 是任意大小的字节数组。\n* `logbloom` 是交易中所有的日志的 `topics` 和地址组成的布隆过滤器。\n\t区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:[light client page (principles section)](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)。\n\n## 叔块激励\n\n“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月[首次](http://eprint.iacr.org/2013/881.pdf)推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。`GHOST` 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。\n\n正如 Sompolinsky 和 Zohar 所描述的那样，`GHOST` 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。\n\n为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。\n\n在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 `GHOST` 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。\n\n* 这里有一个可用的衡量集中化风险的仿真器:[https://github.com/ethereum/economic-modeling/blob/master/ghost.py](https://github.com/ethereum/economic-modeling/blob/master/ghost.py)\n* 一个更高级的讨论:[https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/](https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/)\n\n我们的区块时间算法中的设计决定包含：\n\n* **12 秒出块时间**：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的[一篇文章](http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf)测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。\n* **7 个区块祖先限制**：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。\n* **一个区块后代限制**（如，`c(c(p(p(p(head)))))`，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。\n* **叔块验证要求**：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 `DAG`）。 要求叔块的块合法也是一个有效的方法。\n\n## 难度调整算法\n\n以太坊目前的难度调整规则如下：\n\n```\ndiff(genesis) = 2^32\n\ndiff(block) = diff.block.parent + floor(diff.block.parent / 1024) *\n\t1 if block.timestamp - block.parent.timestamp < 9 else\n\t-1 if block.timestamp - block.parent.timestamp >= 9\n```\n\n难度调整规则的设计目标是：\n\n* **快速更新**：区块之间的时间的调整要快。\n\n* **稳定**：如果算力不变，难度不应该过大。\n\n* **简单**：算法实现要简单。\n\n* **占用内存低**：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。\n\n* **非开发性**：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。\n\n我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于[`https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p`](https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py)（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。\n","slug":"以太坊wiki-设计原理翻译三","published":1,"updated":"2018-03-07T10:06:20.277Z","layout":"post","photos":[],"link":"","_id":"cjejlcu6c0006l8jxtq0dq8q5","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译二</a></p>\n<h2 id=\"树的使用方式\"><a href=\"#树的使用方式\" class=\"headerlink\" title=\"树的使用方式\"></a>树的使用方式</h2><p>警告：本节内容假设你已经了解了布隆过滤器是如何工作的。详情可见:<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Bloom_filter</a></p>\n<p>以太坊区块链中的每个区块都包含了 3 个指针指向 3 个 树：状态树（the state trie），代表连接区块之后的全部状态，交易树，代表区块中索引关联的所有交易（即 <code>key 0</code>:第一笔要执行的交易，<code>key 1</code>:第二笔要执行的交易，等等），以及收据树，代表了符合每笔交易的收据（receipts）。对应于一笔交易的收据是一个经过 <code>RLP</code> 编码的数据结构：</p>\n<pre><code>[ medstate, gas_used, logbloom, logs ]\n</code></pre><p>对应的：</p>\n<ul>\n<li><code>medstate</code> 是处理交易之后的状态树的根。</li>\n<li><code>gas_used</code> 是处理该笔交易之后消耗的燃料数量。</li>\n<li><code>logs</code> 是交易执行过程中由 <code>LOG0 ... LOG4</code> 操作码生成的 <code>[address, [topic1, topic2...], data]</code>形式的项目列表（包括主调用和次调用）。<code>address</code> 是产生日志的合约的地址，<code>topics</code> 最多为 4 个 32 字节值，<code>data</code> 是任意大小的字节数组。</li>\n<li><code>logbloom</code> 是交易中所有的日志的 <code>topics</code> 和地址组成的布隆过滤器。<br>  区块头中也有一个布隆（bloom），它是区块中所有交易的布隆的“或”结果。这个结构的目的是使以太坊的轻客户端尽可能的友好。更多以太坊轻客户端和它们的使用实例，见:<a href=\"https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles\" target=\"_blank\" rel=\"noopener\">light client page (principles section)</a>。</li>\n</ul>\n<h2 id=\"叔块激励\"><a href=\"#叔块激励\" class=\"headerlink\" title=\"叔块激励\"></a>叔块激励</h2><p>“贪婪的最重观察子树（Greedy Heaviest Observed Subtree）”（GHOST）协议是 Yonatan Sompolinsky 和 Aviv Zohar 于 2013 年 12 月<a href=\"http://eprint.iacr.org/2013/881.pdf\" target=\"_blank\" rel=\"noopener\">首次</a>推出的一项创新，也是第一次有人认真尝试解决“阻塞越来越快”的问题。<code>GHOST</code> 背后的动机是，目前区块链通过最快确认次数来确认区块的方案，由于过高的陈旧率而降低了安全性 - 因为区块在网络中传播需要一定的时间，如果矿工 A 挖出一个块，然后在矿工 A 的块传播到 B 之前矿工 B 恰巧挖出另一个块 ，矿工 B 的块将会浪费掉（“陈旧”），并且对于网络安全没有任何帮助。此外，还有一个集中化问题：如果矿工 A 是一个拥有3 0％ 算力的矿池，而 B 拥有 10％ 的算力，那么 A 将有 70％ 的时间产生陈旧块的风险（因为另外 30％ 的时间 A 产生了最后一个块，因此将立即获取挖掘数据），而 B 将有 90％ 的时间产生陈旧块的风险。因此，如果区块间隔足够短而导致陈旧率较高，那么凭借其算力，明显地，A 将更高效。将这两种效应结合起来，快速生成区块的区块链很可能导致一个具有足够算力的矿池对挖矿产生垄断。</p>\n<p>正如 Sompolinsky 和 Zohar 所描述的那样，<code>GHOST</code> 通过在计算哪个链是“最长”时包含陈旧块来解决网络安全损失的第一个问题; 也就是说，在计算最长链的工作量证明中，除了该区块的直系祖先区块，还包含了该区块之前被废弃的叔块。</p>\n<p>为了解决可能的中心化问题，我们采用了一个不同的策略：我们对叔块进行奖励：一个叔块会获得它的基本奖励的 7/8(87.5%)，而该叔块的下一个区块会获得基本奖励的 1/32(3.125%)。当然交易费不会作为奖励。</p>\n<p>在以太坊中，一个陈旧的块只能被当做一个叔块，然后从它的兄弟区块往下最多被直系区块包含 7 代，除此之外叔块和其他任何区块都没有关系。这么做的原因如下：首先，不受限制的 <code>GHOST</code> 会在计算哪个叔块对于当前的区块是合法的时候出现大量的困难。其次，在以太坊中使用无限制的叔块激励，会导致矿工对于是否在主链挖矿不再关心，而这可能导致主链被公共攻击。最后，计算表明，限制到七个级别时利大于弊。</p>\n<ul>\n<li>这里有一个可用的衡量集中化风险的仿真器:<a href=\"https://github.com/ethereum/economic-modeling/blob/master/ghost.py\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/economic-modeling/blob/master/ghost.py</a></li>\n<li>一个更高级的讨论:<a href=\"https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/\" target=\"_blank\" rel=\"noopener\">https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time/</a></li>\n</ul>\n<p>我们的区块时间算法中的设计决定包含：</p>\n<ul>\n<li><strong>12 秒出块时间</strong>：选择 12 秒作为尽可能快的时间，但同时比网络等待时间长得多。2013年，Decker和Wattenhofer在苏黎世的<a href=\"http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdf\" target=\"_blank\" rel=\"noopener\">一篇文章</a>测量了比特币的网络延迟，并确定了 12.6 秒是一个新块传播到95％的节点所花费的时间。然而，论文还指出，大部分的传播时间与块的大小成正比，因此越快的货币传播时间越少（in a faster currency we can expect the propagation time to be drastically reduced）。传播间隔的恒定部分约为 2 秒，但是，为了安全起见，我们假设块在我们的分析中需要 12 秒才能传播。</li>\n<li><strong>7 个区块祖先限制</strong>：这是一个设计目标的一部分，希望在块数很少的情况下很快就可以使块的历史被“遗忘”，并且已经证明 7 块已经提供了大部分预期的效果。</li>\n<li><strong>一个区块后代限制</strong>（如，<code>c(c(p(p(p(head)))))</code>，其中 c = child，p = parent，是不合法的）：这是简洁的设计目标的一部分，上面的模拟器显示它不会带来很大的集中化风险。</li>\n<li><strong>叔块验证要求</strong>：叔块必须包含一个有效的头部，而不是区块。这是为了简单起见，并将区块链模型保持为线性数据结构（而不是 Sompolinsky 和 Zohar 的新模型中的块 <code>DAG</code>）。 要求叔块的块合法也是一个有效的方法。</li>\n</ul>\n<h2 id=\"难度调整算法\"><a href=\"#难度调整算法\" class=\"headerlink\" title=\"难度调整算法\"></a>难度调整算法</h2><p>以太坊目前的难度调整规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff(genesis) = 2^32</span><br><span class=\"line\"></span><br><span class=\"line\">diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *</span><br><span class=\"line\">\t1 if block.timestamp - block.parent.timestamp &lt; 9 else</span><br><span class=\"line\">\t-1 if block.timestamp - block.parent.timestamp &gt;= 9</span><br></pre></td></tr></table></figure>\n<p>难度调整规则的设计目标是：</p>\n<ul>\n<li><p><strong>快速更新</strong>：区块之间的时间的调整要快。</p>\n</li>\n<li><p><strong>稳定</strong>：如果算力不变，难度不应该过大。</p>\n</li>\n<li><p><strong>简单</strong>：算法实现要简单。</p>\n</li>\n<li><p><strong>占用内存低</strong>：算法不应依赖太多历史区块，并尽可能少地使用内存。假设最后十个块，加上最后十个块的块头中的所有内存变量，这就足够算法运行了。</p>\n</li>\n<li><p><strong>非开发性</strong>：该算法不应该过度鼓励矿工修改时间戳，或者矿池频繁地增加和移除算力，以试图最大化他们的收入。</p>\n</li>\n</ul>\n<p>我们已经确定，我们目前的算法在稳定性和不可利用性方面非常不理想，然后我们打算至少将时间戳相对于父母和祖父母进行切换，这样当矿工挖矿时，他们只会修改时间戳。另一个更强大的仿真器公式位于<a href=\"https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py\" target=\"_blank\" rel=\"noopener\"><code>https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.p</code></a>（仿真器使用比特币的挖矿能力，但只使用当天的均值;它在一天的时间内，在某个点模拟 95% 的崩溃）。</p>\n"},{"title":"以太坊wiki-设计原理翻译二","comments":0,"date":"2018-02-08T18:10:31.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","source":"_posts/以太坊wiki-设计原理翻译二.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译二\ncomments: false\ndate: 2018-02-09 02:10:31\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊 \n- ethereum\nimg:\n---\n\n[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)\n\n## 默克尔帕夏里克树\n\n默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：\n\n1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）\n2. 在对数时间内进行修改，添加和删除键值对。\n\n这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)\n\n`MPT` 中详细的设计决定包括：\n\n1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。\n2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。\n3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。\n4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。\n5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。\n\n## RLP\n\n`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)\n\n`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。\n\n`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。\n\n## 压缩算法\n\n有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：\n\n```\n>>> compress('horse')\n'horse'\n>>> compress('donkey dragon 1231231243')\n'donkey dragon 1231231243'\n>>> compress('\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97')\n'\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe{b\\xd5\\xcd\\x8d\\x87\\x97'\n>>> compress(\"\\xc5\\xd2F\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\")'\\xfe\\x01'\n\t\t\t```\n\n在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。\n","slug":"以太坊wiki-设计原理翻译二","published":1,"updated":"2018-03-07T10:06:07.447Z","layout":"post","photos":[],"link":"","_id":"cjejlcu6i0009l8jxivdky4cf","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译一</a></p>\n<h2 id=\"默克尔帕夏里克树\"><a href=\"#默克尔帕夏里克树\" class=\"headerlink\" title=\"默克尔帕夏里克树\"></a>默克尔帕夏里克树</h2><p>默克尔帕夏里克树（<code>Merkle Patricia tree/trie</code>），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。<code>MPT</code> 是 <code>Merkle tree</code> 和 <code>Patricia tree</code> 的结合，以两者的元素来创建具有以下两个属性的结构：</p>\n<ol>\n<li>每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）</li>\n<li>在对数时间内进行修改，添加和删除键值对。</li>\n</ol>\n<p>这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 <code>MPT</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/Patricia-Tree\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>\n<p><code>MPT</code> 中详细的设计决定包括：</p>\n<ol>\n<li><strong>拥有两种节点类别</strong>：<code>kv</code> 节点和分叉节点（从 <code>MPT</code> 详解中获得更多信息）。<code>kv</code> 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，<code>kv</code> 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。</li>\n<li><strong>使分叉节点为 6 而不是 2</strong>：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 <code>1.1</code>。</li>\n<li><strong>空值和“没有成员”之间没有区别</strong>：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。</li>\n<li><strong>终止和非终止节点之间的区别</strong>：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 <code>MPT</code> 的实现方式。</li>\n<li><strong>使用 <code>sha3(k)</code> 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）</strong>：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 <code>SLOAD</code> 和 <code>SSTORE</code>」这样的方式，对树进行 <code>DoS</code> 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 <code>sha3（k） - &gt; k</code>。</li>\n</ol>\n<h2 id=\"RLP\"><a href=\"#RLP\" class=\"headerlink\" title=\"RLP\"></a>RLP</h2><p><code>RLP</code>（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。<code>RLP</code> 的正式描述如下：<a href=\"https://github.com/ethereum/wiki/wiki/RLP\" target=\"_blank\" rel=\"noopener\">https://github.com/ethereum/wiki/wiki/RLP</a></p>\n<p><code>RLP</code> 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 <a href=\"https://developers.google.com/protocol-buffers/docs/pythontutorial\" target=\"_blank\" rel=\"noopener\"><code>protobuf</code></a>，<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\"><code>BSON</code></a> 和其他解决方式，<code>RLP</code> 并不想定义任何具体的数据类型，如 <code>booleans, floats, doubles</code> 或者 <code>integers</code>，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为<code>[[k1，v1]，[k2，v2]，...]</code>，其中 <code>k1，k2 ...</code> 使用字符串的标准排序来排序。</p>\n<p><code>RLP</code> 的备选方案可以使用已经存在的算法如 <code>protobuf</code> 或者 <code>BSON</code>，但我们更青睐 <code>RLP</code> 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 <code>VM</code>）。注意 <code>BitTorrent</code> 使用的 <code>bencode</code>，可能为 <code>RLP</code> 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 <code>RLP</code> 相比稍微不太理想。</p>\n<h2 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h2><p>有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（<code>run-length-encoding zeroes</code>），并保留其他值，除了像 <code>sha3（&#39;&#39;）</code> 这样的常见值的一些特殊情况例外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; compress(&apos;horse&apos;)</span><br><span class=\"line\">&apos;horse&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)</span><br><span class=\"line\">&apos;donkey dragon 1231231243&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)</span><br><span class=\"line\">&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;</span><br><span class=\"line\">&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos;</span><br></pre></td></tr></table></figure>\n<p>在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，<code>sha3</code> 常常被覆盖，这样 <code>sha3(&#39;&#39;)=&#39;&#39;</code>，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。</p>\n"},{"title":"以太坊wiki-设计原理翻译四","comments":0,"date":"2018-02-24T03:01:05.000Z","img":null,"_content":"\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","source":"_posts/以太坊wiki-设计原理翻译四.md","raw":"---\ntitle: 以太坊wiki-设计原理翻译四\ncomments: false\ndate: 2018-02-24 11:01:05\ncategories: 区块链\ntags: \n- ZhouFyk \n- 区块链 \n- 以太坊\nimg:\n---\n\n[以太坊wiki-设计原理翻译三](https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/)\n\n## 燃料和手续费\n\n比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。\n\n交易手续费的基本机制如下：\n* 每笔交易都需要指定一定数量愿意被花费的燃料（被称作 `startgas`），以及愿意为每单位燃料支付的价格（`gasprice`）。在执行之初，`startgas * gasprice` 这么多的 `ether` 会从交易发送者的账户中被扣除。\n* 交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。\n* 如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 `gas_rem`。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 `gas_rem * gasprice`，矿工会收到一笔 `(startgas - gas_rem) * gasprice` 的奖励。\n* 如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 `startgas * gasprice` 会被转给矿工。\n* 当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。\n\n以上的每个部分都是必要的。例如：\n* 如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。\n* 将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。\n* 整个值 `startgas * gasprice` 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。\n* 如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。\n* 如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。\n* 要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。\n\n注意燃料消耗的特定的特性：\n* 21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。\n* 一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。\n* `SSTORE` 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。\n* 合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。\n* 内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。\n* 一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1...x^255 = 2 燃料，x^256...x^65535 = 3 燃料 等等），而复制操作码（`CALLDATACOPY, CODECOPY, EXTCODECOPY`）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（`LOG` 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 `CALLDATACOPY` 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）\n* 如果值非零，那么`CALL` 操作码（和对称的 `CALLCODE`）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。\n\n燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。\n\n目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。\n\n## 虚拟机\n\n以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 *虚拟机* 和 *合约* 与 *消息模型* 分别看待，比如， `SIGNEXTEND` 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：\n\n* **简单**：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。\n* **完全明确**：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。\n* **节省空间**：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。\n* **期望的应用的专业能力（Specialization to expected applications）**：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。\n* **简单的安全**：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。\n* **优化友好**：应该很容易优化，以便可以构建 `JIT` 编译的和其他速度更快的 `VM` 版本。\n\n一些特殊的设计决定如下：\n* **临时/永久存储的区别** - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 `B.S[0] = 5`，`B.M[0] = 9`，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 `B.S[0]`，它会获取到之前存储在 B 中的值，但是 B 树读取 `B.M[0]`，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 `B.M[0] = 13` 和 `B.S[0] = 17`，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 `B.M[0] = 9`(自上次设置此值在同一个 VM 执行实例中) 和 `B.S[0] = 17`。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 `B.M[0] = 0` 和 `B.S[0] = 17`。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。\n* **栈/内存模型** - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 `ADD R1 R2 R3:M[R1] = M[R2] + M[R3]`。选择堆栈范例的原因很明显，它使代码缩小了四倍。\n* **32 字节字大小** - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。\n* **拥有我们自己的虚拟机** - 替代方案是使用 `Java`，或者一些 `Lisp dialect`，或者 `Lua`。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。\n* **使用可变的可扩展内存大小** - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。\n* **不限制堆栈大小** - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。\n* **有一个 1024 层级深度的调用限制** - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。\n* **没有类型** - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 `DIV, SDIV, MOD, SMOD`（事实证明，对于 `ADD` 和 `MUL`，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，`a * b -> (a * b) / 2^32`，`a / b -> a * 2^32 / b` 以及 +，- 和 * 在整数情况下保持不变。\n\n虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：\n* **`ADDMOD, MULMOD`**：在大多数情况下，`addmod(a, b, c) = a * b % c`。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 `a * b % c` 实际上是 `((a * b) % 2 ^ 256) % c`，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 `a * b % c` 的公式是十分普通和臃肿的。\n* **SIGNEXTEND**：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。\n* **SHA3**： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。\n* **ORIGIN**：提供交易发送人的 `ORIGIN` 操作码的主要用途是允许合约对燃料进行退款支付。\n* **COINBASE**：`COINBASE` 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。\n* **PREVHASH**：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。\n* **EXTCODESIZE, EXTCODECOPY**：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的[http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/](http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/)\n* **JUMPDEST**：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。\n* **LOG**：LOG 表示记录事件，可见上面树的使用部分。\n* **CALLCODE**：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。\n* **SELFDESTRUCT**：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。\n* **PC**：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。\n","slug":"以太坊wiki-设计原理翻译四","published":1,"updated":"2018-03-07T10:06:29.964Z","layout":"post","photos":[],"link":"","_id":"cjejlcu6m000al8jxsoy8kfkv","content":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xingyunbite.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">以太坊wiki-设计原理翻译三</a></p>\n<h2 id=\"燃料和手续费\"><a href=\"#燃料和手续费\" class=\"headerlink\" title=\"燃料和手续费\"></a>燃料和手续费</h2><p>比特币中的交易大致相同，因此它们在网络上的成本可以抽象成一个模型，而以太坊中的交易则更复杂，交易费用系统需要考虑许多因素，包括带宽成本 ，存储成本和计算成本。特别重要的是，以太坊编程语言是图灵完备的，因此交易可以使用任意数量的带宽，存储和计算，并且因为不能提前可靠地预估暂停的问题，算力可能被大量使用。所以防止通过无限循环进行的拒绝服务攻击是一个关键目标。</p>\n<p>交易手续费的基本机制如下：</p>\n<ul>\n<li>每笔交易都需要指定一定数量愿意被花费的燃料（被称作 <code>startgas</code>），以及愿意为每单位燃料支付的价格（<code>gasprice</code>）。在执行之初，<code>startgas * gasprice</code> 这么多的 <code>ether</code> 会从交易发送者的账户中被扣除。</li>\n<li>交易执行期间的所有操作，包括数据库的读写，消息，和虚拟机中的每个计算步骤，都会消耗一定数量的燃料。</li>\n<li>如果一笔交易执行被完整地处理，消耗的燃料比它限定的燃料少，那么该剩余的燃料被称作 <code>gas_rem</code>。一笔交易首先会正常执行，然后在交易执行的最后，交易发送者会收到一笔退款 <code>gas_rem * gasprice</code>，矿工会收到一笔 <code>(startgas - gas_rem) * gasprice</code> 的奖励。</li>\n<li>如果在交易执行过程中，燃料耗尽，那么所有的执行都会被回滚，而交易也依旧未被验证。该交易的唯一影响是 <code>startgas * gasprice</code> 会被转给矿工。</li>\n<li>当一个合约发送一个消息给另一个合约，它也可以设置一个燃料限定值来指定由该消息引起的子执行操作。如果该执行耗尽燃料，那么一切回滚，而燃料也会被消耗。</li>\n</ul>\n<p>以上的每个部分都是必要的。例如：</p>\n<ul>\n<li>如果交易不需要指定燃料限制，那么恶意用户可以发送一笔进行数十亿循环的交易，因为处理这样的交易将花费比块间隔更长的时间，所以没有人能够处理它， 但矿工们无法预知该交易的存在，那么就会导致拒绝服务漏洞。</li>\n<li>将时间限制替代燃料限制，并不会起作用，因为这太主观了（有些机器比其他机器更快，甚至在相同的机器中也总是存在闭合调用）。</li>\n<li>整个值 <code>startgas * gasprice</code> 必须在开始时即作为押金取出，这样就不会出现账户在执行中“破产”并且无法支付燃料的情况。 请注意，余额检查是不够的，因为帐户可以在其他地方发送余额。</li>\n<li>如果在燃料不足的错误下，执行没有回滚，那么合约就需要采取强有力但是困难的安全措施，以防止自身被交易或消息利用而提供只能运行到一半的燃料，从而导致当前正在执行的合约发生一些变化。</li>\n<li>如果子限制不存在，那么敌对账户可以通过与其签订协议来制定对其他合同的拒绝服务攻击，然后在计算开始时插入无限循环，这样受害者合约中的任何企图补偿攻击合约（any attempts by the victim contract to compensate the attack contract）或向其发送消息的行为都会使整个交易执行陷于瘫痪。</li>\n<li>要求交易发送者支付燃料而不是合约来支付，大大提高了开发者的可用性。以太坊的早期版本有支付燃料的合约，但是这导致了一个相当丑的问题，即每个合约都必须实施“守卫”代码，以确保每一个传入的消息都足以补偿合约以足以支付燃料的消耗。</li>\n</ul>\n<p>注意燃料消耗的特定的特性：</p>\n<ul>\n<li>21000 单位的燃料是一笔交易的基本手续费。这涵盖了从签名中恢复发件人地址以及存储交易的空间和带宽空间的椭圆曲线操作的成本。</li>\n<li>一笔交易可以包括无限的数据，虚拟机提供了操作码使得合约接受交易来访问数据。固定燃料手续费为，每个 0 字节 4 单位燃料，每个非 0 字节 68 单位燃料。这个公式是因为我们注意到用户写的合约中的大多数交易数据都被组织成一系列 32 字节的参数，其中大部分都有前导 0 字节，虽然这样的构造看起来似乎没有效率，但是由于压缩算法的存在，这样反而十分有效率，我们希望鼓励使用它们来代替更复杂的机制，以便根据预期的字节数来压缩参数，从而在编译器级别增加复杂性。这是三明治复杂性模型的一个例外，但是由于成本与收益的比例，这是合理的。</li>\n<li><code>SSTORE</code> 操作符会在账户的存储空间中设置变量，它的消耗如下：(i) 将一个为零的变量改为非零时，为 20000 单位的燃料，(ii) 将一个零变量改为零变量，将一个非零变量改为非零变量时，为 5000 单位燃料，(iii) 将非零变量改为零变量时，为 5000 单位燃料，加上在成功交易执行结束时提供的 20000 单位燃料退款。（plus a 20000 gas refund to be given at the end of successful transaction execution）（即不是执行导致的燃料耗尽异常）。退款最高为交易花费的全部燃料的一半。这提供了一个小小的激励来清空存储空间，因为我们注意到，没有这样的激励的话，很多合约都会留下一些未使用的存储空间，导致快速膨胀增加体积，为存储“收取租金”提供了很多好处，同时也没有风险，一个被放置好的合同将永远存在。延迟退款机制对于防止拒绝服务攻击是必要的，攻击者会发送具有少量燃料的交易，在一个运行很长时间的循环中频繁清空大量的存储空间，这样会很快耗尽燃料，也会消耗验证者大量的算力，但这个操作实际上却并没有清空存储空间或者花费大量的燃料。50% 的上限是为了确保一个矿工在获得具有一定数量燃料的交易后仍然可以确定执行交易的计算时间的上限。</li>\n<li>合约提供的消息中的数据不会消耗燃料。这是因为在消息调用期间不需要真正“复制”任何数据，因为调用数据可以简单地看作是指向父合约的内存的指针，它在子进程执行期间不会改变。</li>\n<li>内存是一个无限可扩展的阵列。 但是，每 32 字节的内存扩展会消耗一个单位的燃料，这里会四舍五入。</li>\n<li>一些计算时间高度依赖于参数的操作码，拥有不同的燃料消耗值。比如，指数的燃料消耗为 10 加上指数中的每字节的 10 单位（即 x^0 = 1 燃料，x^1…x^255 = 2 燃料，x^256…x^65535 = 3 燃料 等等），而复制操作码（<code>CALLDATACOPY, CODECOPY, EXTCODECOPY</code>）的燃料消耗为 1 加上每 32 字节的一单位燃料，这里四舍五入（<code>LOG</code> 拥有类似的规则）。内存膨胀的燃料成本不足以弥补这一缺陷，因为它打开了一次二次攻击（50000 轮的 50000 单位燃料的 <code>CALLDATACOPY</code> 约为 50000 ^ 2 的计算量，但在引入可变燃料成本之前只有约 50000 单位燃料）</li>\n<li>如果值非零，那么<code>CALL</code> 操作码（和对称的 <code>CALLCODE</code>）花费额外的 9000 单位燃料。这是因为任意值转移都会导致存档节点的历史存储空间严重膨胀。注意，实际的手续费为 6700；在这之上我们强制增加了一个最低为 2300 单位的燃料用来自动给收据。这是为了确保收到交易的钱包至少有足额的燃料来记录该交易。</li>\n</ul>\n<p>燃料机制的另一个重要的部分是燃料价格本身的经济性。比特币中使用的默认方法是完全自愿的手续费，依靠矿工设置动态的最低值来扮演一个守门人的角色；与之相对的，在以太坊中，允许交易发送者设置任意的燃料消耗。这种方式在比特币社区中十分受欢迎，因为它是基于市场的，允许矿工和交易发送者之间的供需关系决定价格。然而这里存在一个问题，交易处理并不是市场；尽管将交易处理作为矿工提供给发送方的服务具有直接的吸引力，但实际上，矿工打包的每笔交易都需要被网络上的每个节点处理，因此绝大多数交易处理成本由第三方承担，而不是决定是否打包该交易的矿工。因此，很可能会发生普遍灾难（tragedy-of-the-commons）的问题。</p>\n<p>目前，由于缺少关于矿工实际上是如何处理的详细信息，我们实施了一个相当简单的方法：一个投票系统。矿工拥有权力对当前的区块设置燃料限制，该限制与上一个区块的燃料限制可以有大约 0.0975%（1/1024）的浮动，因此产生的燃料限制应该为矿工偏好的中位数。我们希望将来能够将其分解为更精确的算法。</p>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><p>以太坊虚拟机是交易码执行的引擎，也是以太坊和其他系统不同的核心特性。注意，将 <em>虚拟机</em> 和 <em>合约</em> 与 <em>消息模型</em> 分别看待，比如， <code>SIGNEXTEND</code> 操作码是虚拟机的一个特性，而合约可以调用其他合约，指定子调用的燃料限制是合约和消息的一部分。以太坊虚拟机的设计目的包括：</p>\n<ul>\n<li><strong>简单</strong>：尽可能少的底层操作码，尽可能少的数据类型，以及尽可能少的虚拟机层次的结构。</li>\n<li><strong>完全明确</strong>：在虚拟机的说明中绝对不允许存在模棱两可的情况，并且结果必须是完全确定的。另外，应该有一个精确的计算步骤的概念，可以测量计算燃料的消耗。</li>\n<li><strong>节省空间</strong>：以太坊虚拟机组件应尽可能紧凑（例如，默认 C 程序的 4000 字节基本大小是不可接受的）。</li>\n<li><strong>期望的应用的专业能力（Specialization to expected applications）</strong>：有能力处理 20 字节地址 和自定义的32 字节变量的加密，自定义加密中的模块化算法，读取区块和交易数据，与状态交互等等。</li>\n<li><strong>简单的安全</strong>：应该很容易就能够想出操作符的燃料消耗模型，该模型使得虚拟机无法被利用。</li>\n<li><strong>优化友好</strong>：应该很容易优化，以便可以构建 <code>JIT</code> 编译的和其他速度更快的 <code>VM</code> 版本。</li>\n</ul>\n<p>一些特殊的设计决定如下：</p>\n<ul>\n<li><strong>临时/永久存储的区别</strong> - 存在于虚拟机的每个实例内并在虚拟机执行完成时消失的临时存储与基于每个账户的存在于区块链状态级别上的永久存储之间存在区别。比如，假设执行下列执行树（使用 S 代表永久存储，M 代表临时存储）：（i） A 调用 B，（ii） B 设置 <code>B.S[0] = 5</code>，<code>B.M[0] = 9</code>，（iii） B 调用 C，（iv）C 调用 B。在此时，如果 B 树读取 <code>B.S[0]</code>，它会获取到之前存储在 B 中的值，但是 B 树读取 <code>B.M[0]</code>，它回返回 0，因为在虚拟机的临时存储中这个一个新的实例。如果 B 在这个内部调用中设置 <code>B.M[0] = 13</code> 和 <code>B.S[0] = 17</code>，然后这个内部调用和 C 的调用终止，使得执行回到 B 的外部调用，然后 B 读取 M，将会看到 <code>B.M[0] = 9</code>(自上次设置此值在同一个 VM 执行实例中) 和 <code>B.S[0] = 17</code>。如果 B 的外部调用终止，A 再次调用 B，然后 B 会看到 <code>B.M[0] = 0</code> 和 <code>B.S[0] = 17</code>。这种区别的目的是（1）为每个执行实例提供自己的内存，这些内存不会受到递归调用的破坏，使安全编程变得更加容易，并且（2）提供一种可以非常快地操作的内存形式， 因为需要修改树，所以存储更新的速度一定很慢。</li>\n<li><strong>栈/内存模型</strong> - 早期做出的决定有三种计算状态（除了指向下一条指令的程序计数器外）：栈（一种标准的先进后出的 32 字节变量栈），内存（一种无限可扩展的临时字节数组）和存储（永久存储）。在临时存储方面，堆栈和内存的替代方案是一个仅限内存的范例，或者是寄存器和内存的混合（不是很不相同，因为从根本上说寄存器也是一种内存）。在这个例子中，每个命令会有三个参数，如 <code>ADD R1 R2 R3:M[R1] = M[R2] + M[R3]</code>。选择堆栈范例的原因很明显，它使代码缩小了四倍。</li>\n<li><strong>32 字节字大小</strong> - 与其他大多数架构一样，替代方案是 4 或 8 个字节的字，或者像比特币一样是无限的字。4 字节或 8 字节字太严格，无法存储加密计算的地址和很大的值，而无限的值则很难根据其建立一个安全的燃料模型。32 字节是理想的，因为它足够大以存储许多加密实现中常见的 32 字节值，以及地址（并提供将地址和值打包到单个存储索引中的优化能力），但又不会太大以至于效率变得极低。</li>\n<li><strong>拥有我们自己的虚拟机</strong> - 替代方案是使用 <code>Java</code>，或者一些 <code>Lisp dialect</code>，或者 <code>Lua</code>。我们认为拥有一个专门的虚拟机是合适的，因为（i）我们的虚拟机规格比许多其他虚拟机简单得多，因为其他虚拟机必须为复杂性付出更低的成本，而在我们的情况下，每次增加复杂性都是朝着创建开发集中化和可能存在包括共识失败的安全漏洞这样的高门槛迈出的一步（whereas in our case every additional unit of complexity is a step toward high barriers of entry creating development centralization and potential for security flaws including consensus failures,），（ii）它使我们能够更专业化虚拟机，例如，通过具有 32 字节的字大小，（iii）它使我们不会有非常复杂的可能导致安装困难的外部依赖性，以及（iv）针对以太坊的特殊安全需求的安全审查，无论如何都需要对外部虚拟机进行安全审查，因此节省的工作量并不大。</li>\n<li><strong>使用可变的可扩展内存大小</strong> - 我们认为，如果规模很小，或者规模很大，都没有必要限定一个固定的内存大小，并且注意如果内存访问的语句在任何情况下都需要检查越界访问，那么固定大小就不会使执行效率更高。</li>\n<li><strong>不限制堆栈大小</strong> - 没有任何特别的理由; 请注意，在许多情况下，限制并非绝对必要，因为燃料消耗和区块级燃料限制的组合总是作为每种资源消耗的上限。</li>\n<li><strong>有一个 1024 层级深度的调用限制</strong> - 许多编程语言在很高的堆栈深度时会比在很高的内存使用率或计算负载时突然崩溃的速度快得多，因此区块燃料限制的隐含限制可能不足。</li>\n<li><strong>没有类型</strong> - 为了简单。相反，取而代之的是使用有符号或无符号的操作码如 <code>DIV, SDIV, MOD, SMOD</code>（事实证明，对于 <code>ADD</code> 和 <code>MUL</code>，有符号和无符号操作码的行为是等同的），以及定点数运算（高深度定点运算是 32 字节字的另一个好处）在任何情况下都很简单，如 32 位深度，<code>a * b -&gt; (a * b) / 2^32</code>，<code>a / b -&gt; a * 2^32 / b</code> 以及 +，- 和 * 在整数情况下保持不变。</li>\n</ul>\n<p>虚拟机中的一些方法和操作码的目的是显而易见的，但也不全是。一些特殊解释给出如下：</p>\n<ul>\n<li><strong><code>ADDMOD, MULMOD</code></strong>：在大多数情况下，<code>addmod(a, b, c) = a * b % c</code>。然而，在许多类椭圆曲线密码学的特定情况下，使用 32 字节模块化算术，因此直接做 <code>a * b % c</code> 实际上是 <code>((a * b) % 2 ^ 256) % c</code>，这就是一个完全不同的结果。在 32 字节的空间中使用 32 字节的值计算 <code>a * b % c</code> 的公式是十分普通和臃肿的。</li>\n<li><strong>SIGNEXTEND</strong>：SIGNEXTEND 的目的是促进从更大的有符号整数到更小的有符号整数的类型转换。 小的带符号整数很有用，因为 JIT 编译的虚拟机将来可以检测长时间运行的代码块，这些代码块主要处理 32 字节整数，并大大加快速度。</li>\n<li><strong>SHA3</strong>： SHA3 在以太坊代码中十分使用，因为使用存储的安全无限大小散列映射可能需要使用安全散列函数，以防止恶意冲突，以及验证默克尔树，甚至是验证类以太坊的数据结构。一个关键点是它的朋友 SHA256，ECRECOVER 和 RIPEMD160不是作为操作码而是伪协议被包含其中。这样做的目的是将它们放入一个单独的类别中，以便在之后我们提出适当的“本机扩展”系统时，可以添加更多此类合约而不是填充操作码的空间。</li>\n<li><strong>ORIGIN</strong>：提供交易发送人的 <code>ORIGIN</code> 操作码的主要用途是允许合约对燃料进行退款支付。</li>\n<li><strong>COINBASE</strong>：<code>COINBASE</code> 操作码的主要用途是（i）允许子货币选择为网络安全做出贡献;以及（ii）开放矿工的使用权，作为分布式经济集合，用于基于次级共识的应用程序，如 Schellingcoin。</li>\n<li><strong>PREVHASH</strong>：用作半安全随机源，并允许合约评估前一个区块中 Merkle 树状态的树状证明，而不需要高度复杂的递归“以太坊中的以太坊轻客户端”构造。</li>\n<li><strong>EXTCODESIZE, EXTCODECOPY</strong>：这里的主要用途是允许合约在与其他合约进行交互之前，根据模板检查其他合约的代码，甚至模拟它们。见应用的<a href=\"http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/\" target=\"_blank\" rel=\"noopener\">http://lesswrong.com/lw/aq9/decision_theories_a_less_wrong_primer/</a></li>\n<li><strong>JUMPDEST</strong>：JIT 编译的虚拟机在跳转目标受限于几个索引时变得更容易实现（具体的说，可变目标跳转的计算复杂度大致为 O(log(有效跳转目标的数量))，尽管静态跳转总是常量时间）。因此，我们需要（i）对有效变量跳转目标的限制，（ii）激励使用静态跳转。为了达到这些目的，我们有以下规则（i）在被推送紧接着的跳转可以跳转到任意地方，但是不能跳转到另一个跳转，（ii）其他跳转尽能跳到 JUMPDEST。限制跳转到跳转是必要的，这样查看一个跳转是动态还是静态的可以很容易的根据代码中在它之前的操作判断。对静态跳转缺乏 JUMPDEST 操作的需求是使用它们的动机。禁止跳入推送数据也会加速 JIT VM 的编译和执行。</li>\n<li><strong>LOG</strong>：LOG 表示记录事件，可见上面树的使用部分。</li>\n<li><strong>CALLCODE</strong>：这个操作符的目的是允许合约以存储在其他合约中的代码的形式调用“函数”，这样具有单独的堆栈和内存，但是使用该合约自己的存储。这使得在区块链上可扩展地实现代码的“标准库”变得更加容易。</li>\n<li><strong>SELFDESTRUCT</strong>：如果不再需要一个合约可以通过此操作符来销毁该合约。SELFDESTRUCT 在交易执行结束时被处理，而不是立即处理，这是因为拥有回滚早已执行的 SELFDESTRUCT 的能力会大大增加一个高效的虚拟机实现中所需的高速缓存的复杂度。</li>\n<li><strong>PC</strong>：尽管在理论上不是必需的，因为 PC 操作码的所有实例都可以通过简单地将实际的程序计数器放在该索引处作为推动来替换，使用代码中的 PC 允许创建与位置无关的代码（即编译的可复制/粘贴到其他合同中的函数，并且如果它们以不同的索引结束就不会中断）。</li>\n</ul>\n"},{"title":"以太坊，燃气，燃料 和 费用（翻译）","comments":0,"date":"2018-03-01T08:20:06.000Z","img":null,"_content":"\n[来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel & Fees](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc)\n\n以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。\n\n使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。\n\n##  燃气（gas）是什么？\n\n燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。\n\nEVM 中的每个操作都会消耗燃气。例如，一个乘法（`MUL`）消耗 5 燃气而一个加法（`ADD`）消耗 3 燃气。[以太坊操作的燃气消耗表格](https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit)\n\n**将燃气看做是燃料的代名词**\n\n计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。\n\n了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 `(开始燃气 - 剩余燃气) * 燃气价格`。\n\n这里是一个关于交易燃料和交易费用的影响的总结：\n\n|    |燃料|费用|\n|------|-----|------|\n|通常|EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。|每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）|\n|交易开始时|交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。|交易发起人必须支付所有燃料。放置 `初始燃气 * 燃气价格 = 以太币` 在托管中。|\n|每个操作|剩余燃气会由于操作消耗而减少|知道交易完成（不论成功不成功），才会有后续的操作。|\n|不成功的交易|剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销|所有托管的费用都会被支付给矿工|\n|成功的交易|所有剩余的燃气会回退给交易发起人|`（初始燃气 - 剩余燃气） * 燃气价格 = 费用` 支付给矿工；`剩余燃气 * 燃气价格` = 回退给交易发起人的费用。|\n\n在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。\n\n## 简单的例子\n\n在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：\n\n|   |操作消耗的燃气|剩余燃气|\n|------|------|-------|\n|交易开始||150|\n|存储 31|45|105|\n|两个数相加|10|95|\n|存储和|45|50|\n|交易结束|数字 31 和 加法的和-|-已经被存储写入区块链|\n\n交易发起人支付给矿工的费用是：\n\n**（150–50) × 0.02µETH = 2µETH = 0.000002 ETH**\n\n## 燃料与费用\n\n交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：\n\n||燃料|费用|\n|---|---|---|\n|太低|不会广播给矿工（错误：`intrinsic gas too low`）|矿工不会执行计算|\n|低|少量计算或者燃料耗尽|之后会打包进区块|\n|中等|通常是理想的|通常是理想的|\n|高|可能导致打包被延迟|尽快被打包入区块|\n|太高|不会广播给矿工（错误：`exceeds block gas limit`）|如果交易发起人没有足够的以太币，则不会广播给矿工|\n\n尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 *高初始燃气可能会导致延迟* 部分。\n\n## 初始燃气\n\n让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：\n* [以太坊白皮书](https://github.com/ethereum/wiki/wiki/White-Paper)中使用了 初始燃气\n* [以太坊黄皮书](https://github.com/ethereum/yellowpaper)中使用了燃料限制\n* [Geth](https://github.com/ethereum/go-ethereum/releases) 和 [web3.js](https://github.com/ethereum/web3.js/releases) 等软件中，简单地使用了 “燃气”。\n\n因为在通常情况下，不真正运行计算（关联 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。\n\n## 燃料耗尽异常\n\n一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和[日志](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)的写入）都会回滚。\n\n让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：\n\n||操作的燃料消耗|剩余燃料|\n|-----|-----|-----|\n|交易开始||90|\n|存储 31|45|45|\n|求和|10|35|\n|保存和|45|燃料耗尽|\n|交易结束|因为燃料耗尽，存储的 31 会回滚|耗尽|\n\n在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：\n\n**90 × 0.02µETH = 1.8µETH**\n\n当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。\n\n## 燃气回退\n\nEVM 中有两个负值燃气的操作：\n* 清空合约是 -24000\n* 清空存储是 -15000\n\n当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。\n\n一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。\n\n退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。\n\n## 区块燃气限制（Block gas limit:BGL）\n\n回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。\n\n## 高初始燃气可能存在的延迟\n\n既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？\n\n答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。\n\n如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非[内在气体](https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177)也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。\n\n## 绕过交易所\n\n以太坊有两种类型的账户：\n* 用户账户（由私钥控制）\n* 合约（由代码控制）\n\n发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。\n\n## 计量和费用\n\n关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。\n\n比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。\n\n## 结论\n\n燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括[估计燃气](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas)，内在燃气（intrinsic gas），[燃气价格预告（gas price oracle）](https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle)，[交易大小的影响](https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size)，读者可以在本文的基础上进一步地探索和理解。\n","source":"_posts/以太坊，燃气，燃料-和-费用.md","raw":"---\ntitle: 以太坊，燃气，燃料 和 费用（翻译）\ncomments: false\ndate: 2018-03-01 16:20:06\ncategories: 区块链\ntags:\n- ZhouFyk \n- 区块链 \n- 以太坊 \n- 燃料 \n- gas \n- 翻译\nimg:\n---\n\n[来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel & Fees](https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc)\n\n以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。\n\n使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。\n\n##  燃气（gas）是什么？\n\n燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。\n\nEVM 中的每个操作都会消耗燃气。例如，一个乘法（`MUL`）消耗 5 燃气而一个加法（`ADD`）消耗 3 燃气。[以太坊操作的燃气消耗表格](https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit)\n\n**将燃气看做是燃料的代名词**\n\n计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。\n\n了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 `(开始燃气 - 剩余燃气) * 燃气价格`。\n\n这里是一个关于交易燃料和交易费用的影响的总结：\n\n|    |燃料|费用|\n|------|-----|------|\n|通常|EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。|每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）|\n|交易开始时|交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。|交易发起人必须支付所有燃料。放置 `初始燃气 * 燃气价格 = 以太币` 在托管中。|\n|每个操作|剩余燃气会由于操作消耗而减少|知道交易完成（不论成功不成功），才会有后续的操作。|\n|不成功的交易|剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销|所有托管的费用都会被支付给矿工|\n|成功的交易|所有剩余的燃气会回退给交易发起人|`（初始燃气 - 剩余燃气） * 燃气价格 = 费用` 支付给矿工；`剩余燃气 * 燃气价格` = 回退给交易发起人的费用。|\n\n在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。\n\n## 简单的例子\n\n在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：\n\n|   |操作消耗的燃气|剩余燃气|\n|------|------|-------|\n|交易开始||150|\n|存储 31|45|105|\n|两个数相加|10|95|\n|存储和|45|50|\n|交易结束|数字 31 和 加法的和-|-已经被存储写入区块链|\n\n交易发起人支付给矿工的费用是：\n\n**（150–50) × 0.02µETH = 2µETH = 0.000002 ETH**\n\n## 燃料与费用\n\n交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：\n\n||燃料|费用|\n|---|---|---|\n|太低|不会广播给矿工（错误：`intrinsic gas too low`）|矿工不会执行计算|\n|低|少量计算或者燃料耗尽|之后会打包进区块|\n|中等|通常是理想的|通常是理想的|\n|高|可能导致打包被延迟|尽快被打包入区块|\n|太高|不会广播给矿工（错误：`exceeds block gas limit`）|如果交易发起人没有足够的以太币，则不会广播给矿工|\n\n尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 *高初始燃气可能会导致延迟* 部分。\n\n## 初始燃气\n\n让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：\n* [以太坊白皮书](https://github.com/ethereum/wiki/wiki/White-Paper)中使用了 初始燃气\n* [以太坊黄皮书](https://github.com/ethereum/yellowpaper)中使用了燃料限制\n* [Geth](https://github.com/ethereum/go-ethereum/releases) 和 [web3.js](https://github.com/ethereum/web3.js/releases) 等软件中，简单地使用了 “燃气”。\n\n因为在通常情况下，不真正运行计算（关联 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。\n\n## 燃料耗尽异常\n\n一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和[日志](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)的写入）都会回滚。\n\n让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：\n\n||操作的燃料消耗|剩余燃料|\n|-----|-----|-----|\n|交易开始||90|\n|存储 31|45|45|\n|求和|10|35|\n|保存和|45|燃料耗尽|\n|交易结束|因为燃料耗尽，存储的 31 会回滚|耗尽|\n\n在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：\n\n**90 × 0.02µETH = 1.8µETH**\n\n当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。\n\n## 燃气回退\n\nEVM 中有两个负值燃气的操作：\n* 清空合约是 -24000\n* 清空存储是 -15000\n\n当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。\n\n一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。\n\n退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。\n\n## 区块燃气限制（Block gas limit:BGL）\n\n回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。\n\n## 高初始燃气可能存在的延迟\n\n既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？\n\n答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。\n\n如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非[内在气体](https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177)也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。\n\n## 绕过交易所\n\n以太坊有两种类型的账户：\n* 用户账户（由私钥控制）\n* 合约（由代码控制）\n\n发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。\n\n## 计量和费用\n\n关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。\n\n比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。\n\n## 结论\n\n燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括[估计燃气](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas)，内在燃气（intrinsic gas），[燃气价格预告（gas price oracle）](https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle)，[交易大小的影响](https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size)，读者可以在本文的基础上进一步地探索和理解。\n","slug":"以太坊，燃气，燃料-和-费用","published":1,"updated":"2018-03-07T10:06:43.742Z","layout":"post","photos":[],"link":"","_id":"cjejlcu6w000el8jxigjvplbr","content":"<p><a href=\"https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc\" target=\"_blank\" rel=\"noopener\">来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel &amp; Fees</a></p>\n<p>以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。</p>\n<p>使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。</p>\n<h2 id=\"燃气（gas）是什么？\"><a href=\"#燃气（gas）是什么？\" class=\"headerlink\" title=\"燃气（gas）是什么？\"></a>燃气（gas）是什么？</h2><p>燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。</p>\n<p>EVM 中的每个操作都会消耗燃气。例如，一个乘法（<code>MUL</code>）消耗 5 燃气而一个加法（<code>ADD</code>）消耗 3 燃气。<a href=\"https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit\" target=\"_blank\" rel=\"noopener\">以太坊操作的燃气消耗表格</a></p>\n<p><strong>将燃气看做是燃料的代名词</strong></p>\n<p>计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。</p>\n<p>了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 <code>(开始燃气 - 剩余燃气) * 燃气价格</code>。</p>\n<p>这里是一个关于交易燃料和交易费用的影响的总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通常</td>\n<td>EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。</td>\n<td>每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）</td>\n</tr>\n<tr>\n<td>交易开始时</td>\n<td>交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。</td>\n<td>交易发起人必须支付所有燃料。放置 <code>初始燃气 * 燃气价格 = 以太币</code> 在托管中。</td>\n</tr>\n<tr>\n<td>每个操作</td>\n<td>剩余燃气会由于操作消耗而减少</td>\n<td>知道交易完成（不论成功不成功），才会有后续的操作。</td>\n</tr>\n<tr>\n<td>不成功的交易</td>\n<td>剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销</td>\n<td>所有托管的费用都会被支付给矿工</td>\n</tr>\n<tr>\n<td>成功的交易</td>\n<td>所有剩余的燃气会回退给交易发起人</td>\n<td><code>（初始燃气 - 剩余燃气） * 燃气价格 = 费用</code> 支付给矿工；<code>剩余燃气 * 燃气价格</code> = 回退给交易发起人的费用。</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作消耗的燃气</th>\n<th>剩余燃气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>150</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>105</td>\n</tr>\n<tr>\n<td>两个数相加</td>\n<td>10</td>\n<td>95</td>\n</tr>\n<tr>\n<td>存储和</td>\n<td>45</td>\n<td>50</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>数字 31 和 加法的和-</td>\n<td>-已经被存储写入区块链</td>\n</tr>\n</tbody>\n</table>\n<p>交易发起人支付给矿工的费用是：</p>\n<p><strong>（150–50) × 0.02µETH = 2µETH = 0.000002 ETH</strong></p>\n<h2 id=\"燃料与费用\"><a href=\"#燃料与费用\" class=\"headerlink\" title=\"燃料与费用\"></a>燃料与费用</h2><p>交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>太低</td>\n<td>不会广播给矿工（错误：<code>intrinsic gas too low</code>）</td>\n<td>矿工不会执行计算</td>\n</tr>\n<tr>\n<td>低</td>\n<td>少量计算或者燃料耗尽</td>\n<td>之后会打包进区块</td>\n</tr>\n<tr>\n<td>中等</td>\n<td>通常是理想的</td>\n<td>通常是理想的</td>\n</tr>\n<tr>\n<td>高</td>\n<td>可能导致打包被延迟</td>\n<td>尽快被打包入区块</td>\n</tr>\n<tr>\n<td>太高</td>\n<td>不会广播给矿工（错误：<code>exceeds block gas limit</code>）</td>\n<td>如果交易发起人没有足够的以太币，则不会广播给矿工</td>\n</tr>\n</tbody>\n</table>\n<p>尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 <em>高初始燃气可能会导致延迟</em> 部分。</p>\n<h2 id=\"初始燃气\"><a href=\"#初始燃气\" class=\"headerlink\" title=\"初始燃气\"></a>初始燃气</h2><p>让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/wiki/wiki/White-Paper\" target=\"_blank\" rel=\"noopener\">以太坊白皮书</a>中使用了 初始燃气</li>\n<li><a href=\"https://github.com/ethereum/yellowpaper\" target=\"_blank\" rel=\"noopener\">以太坊黄皮书</a>中使用了燃料限制</li>\n<li><a href=\"https://github.com/ethereum/go-ethereum/releases\" target=\"_blank\" rel=\"noopener\">Geth</a> 和 <a href=\"https://github.com/ethereum/web3.js/releases\" target=\"_blank\" rel=\"noopener\">web3.js</a> 等软件中，简单地使用了 “燃气”。</li>\n</ul>\n<p>因为在通常情况下，不真正运行计算（关联 <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" target=\"_blank\" rel=\"noopener\">停机问题</a>），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。</p>\n<h2 id=\"燃料耗尽异常\"><a href=\"#燃料耗尽异常\" class=\"headerlink\" title=\"燃料耗尽异常\"></a>燃料耗尽异常</h2><p>一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和<a href=\"https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e\" target=\"_blank\" rel=\"noopener\">日志</a>的写入）都会回滚。</p>\n<p>让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作的燃料消耗</th>\n<th>剩余燃料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>90</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>45</td>\n</tr>\n<tr>\n<td>求和</td>\n<td>10</td>\n<td>35</td>\n</tr>\n<tr>\n<td>保存和</td>\n<td>45</td>\n<td>燃料耗尽</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>因为燃料耗尽，存储的 31 会回滚</td>\n<td>耗尽</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：</p>\n<p><strong>90 × 0.02µETH = 1.8µETH</strong></p>\n<p>当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。</p>\n<h2 id=\"燃气回退\"><a href=\"#燃气回退\" class=\"headerlink\" title=\"燃气回退\"></a>燃气回退</h2><p>EVM 中有两个负值燃气的操作：</p>\n<ul>\n<li>清空合约是 -24000</li>\n<li>清空存储是 -15000</li>\n</ul>\n<p>当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。</p>\n<p>一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。</p>\n<p>退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。</p>\n<h2 id=\"区块燃气限制（Block-gas-limit-BGL）\"><a href=\"#区块燃气限制（Block-gas-limit-BGL）\" class=\"headerlink\" title=\"区块燃气限制（Block gas limit:BGL）\"></a>区块燃气限制（Block gas limit:BGL）</h2><p>回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。</p>\n<h2 id=\"高初始燃气可能存在的延迟\"><a href=\"#高初始燃气可能存在的延迟\" class=\"headerlink\" title=\"高初始燃气可能存在的延迟\"></a>高初始燃气可能存在的延迟</h2><p>既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？</p>\n<p>答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。</p>\n<p>如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非<a href=\"https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177\" target=\"_blank\" rel=\"noopener\">内在气体</a>也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。</p>\n<h2 id=\"绕过交易所\"><a href=\"#绕过交易所\" class=\"headerlink\" title=\"绕过交易所\"></a>绕过交易所</h2><p>以太坊有两种类型的账户：</p>\n<ul>\n<li>用户账户（由私钥控制）</li>\n<li>合约（由代码控制）</li>\n</ul>\n<p>发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。</p>\n<h2 id=\"计量和费用\"><a href=\"#计量和费用\" class=\"headerlink\" title=\"计量和费用\"></a>计量和费用</h2><p>关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。</p>\n<p>比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas\" target=\"_blank\" rel=\"noopener\">估计燃气</a>，内在燃气（intrinsic gas），<a href=\"https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle\" target=\"_blank\" rel=\"noopener\">燃气价格预告（gas price oracle）</a>，<a href=\"https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size\" target=\"_blank\" rel=\"noopener\">交易大小的影响</a>，读者可以在本文的基础上进一步地探索和理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://media.consensys.net/ethereum-gas-fuel-and-fees-3333e17fe1dc\" target=\"_blank\" rel=\"noopener\">来自 BTC Relay 的首席开发人员 Joseph Chow ：Ethereum,Gas,Fuel &amp; Fees</a></p>\n<p>以太坊是分布式和诚实的应用程序的平台，可在没有任何管理员或单点故障的全球点对点网络上运行。这些应用程序没有停机时间，任何人都可以创建它们：这是无许可的创新。这些应用是诚实的，不可改变的，并且在编码时总是互操作。从这个角度来说，智能合约的术语是合理的，因为它们是始终遵循其创建时所设定的条款的最终合约。</p>\n<p>使这成为可能的核心实际上是世界计算机。在技术上称为以太坊虚拟机（EVM），它包括用于计算和数据存储的操作。交易代表世界计算机内的单个会话，它是交互的单位，类似于句子如何作为语法意义的单位，尽管单个句子可以包含很多单词。</p>\n<h2 id=\"燃气（gas）是什么？\"><a href=\"#燃气（gas）是什么？\" class=\"headerlink\" title=\"燃气（gas）是什么？\"></a>燃气（gas）是什么？</h2><p>燃气是世界计算机使用的计量单位。做一个类比，电量按千瓦小时计量，而在以太坊中使用更多的算力和存储代表着会使用更多的燃气。计量的一个基本原因是它可以激励人们（矿工）操作世界计算机。这些矿工对交易的处理会收取费用，费用则取决于计量方案：燃气。</p>\n<p>EVM 中的每个操作都会消耗燃气。例如，一个乘法（<code>MUL</code>）消耗 5 燃气而一个加法（<code>ADD</code>）消耗 3 燃气。<a href=\"https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit\" target=\"_blank\" rel=\"noopener\">以太坊操作的燃气消耗表格</a></p>\n<p><strong>将燃气看做是燃料的代名词</strong></p>\n<p>计量与费用不同，而燃气和以太币也不同。为了帮助说清楚这个，将燃气看做是燃料的代名词。一笔交易必须提供足够的燃料，或者初始燃气，来支持 EVM 的计算和存储的使用。所有的剩余燃气会回退给交易的发起人：初始化该笔交易的用户。一笔燃料耗尽的交易会回滚，但是依旧包含在区块中，并且相关的费用依旧支付给矿工。</p>\n<p>了解了燃料角度的概述，让我们来看看费用相关的概述。在 EVM 中，每个操作都会消耗已经预定义数量的燃气（比如，一个乘法操作总是消耗 5 燃气），用户在每笔交易中都可以指定燃气价格。当前的燃气价格是 0.02μ 以太币，或者 0.00000002 ETH。交易发起人支付给矿工的费用是交易的 <code>(开始燃气 - 剩余燃气) * 燃气价格</code>。</p>\n<p>这里是一个关于交易燃料和交易费用的影响的总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通常</td>\n<td>EVM 中的每个操作都会消耗一定数量预先已经设定好的燃料；用户不能更改它。每笔交易都有一个用户指定的初始燃气。</td>\n<td>每笔交易都有用户指定的燃料价格（当前默认为每单位燃气 0.02μ ETH）</td>\n</tr>\n<tr>\n<td>交易开始时</td>\n<td>交易发起人应该提供足够的燃料：初始燃气。剩余燃气 = 初始燃气。</td>\n<td>交易发起人必须支付所有燃料。放置 <code>初始燃气 * 燃气价格 = 以太币</code> 在托管中。</td>\n</tr>\n<tr>\n<td>每个操作</td>\n<td>剩余燃气会由于操作消耗而减少</td>\n<td>知道交易完成（不论成功不成功），才会有后续的操作。</td>\n</tr>\n<tr>\n<td>不成功的交易</td>\n<td>剩余燃气为零，还有未完成的操作。这导致一个燃气耗尽的异常，而所有的操作都会被撤销</td>\n<td>所有托管的费用都会被支付给矿工</td>\n</tr>\n<tr>\n<td>成功的交易</td>\n<td>所有剩余的燃气会回退给交易发起人</td>\n<td><code>（初始燃气 - 剩余燃气） * 燃气价格 = 费用</code> 支付给矿工；<code>剩余燃气 * 燃气价格</code> = 回退给交易发起人的费用。</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，被要求用来作为初始燃气的以太币会被搁置，然后剩余燃气值会被设置为初始燃气值。随着交易中的每个操作，燃气会被消耗，剩余燃气逐渐变少。如果发生燃气耗尽的异常，所有的操作都会回滚，而之前搁置的所有的以太币都会被支付给矿工。如果交易成功执行完毕，所有的剩余部分的燃气会回退给交易发起人，而已经消耗的燃气则支付给矿工。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>在下面的情景模拟中，假设存储消耗 45 燃气，一个加法操作消耗 10 燃气。这个场景涉及到在 EVM 中存储数字 31，将两个数相加，然后存储它们的和。让我们假设交易发起人指定了 150 的初始燃气，和 0.02μ 以太币的燃气价格。下面是 EVM 处理该笔交易的描述：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作消耗的燃气</th>\n<th>剩余燃气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>150</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>105</td>\n</tr>\n<tr>\n<td>两个数相加</td>\n<td>10</td>\n<td>95</td>\n</tr>\n<tr>\n<td>存储和</td>\n<td>45</td>\n<td>50</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>数字 31 和 加法的和-</td>\n<td>-已经被存储写入区块链</td>\n</tr>\n</tbody>\n</table>\n<p>交易发起人支付给矿工的费用是：</p>\n<p><strong>（150–50) × 0.02µETH = 2µETH = 0.000002 ETH</strong></p>\n<h2 id=\"燃料与费用\"><a href=\"#燃料与费用\" class=\"headerlink\" title=\"燃料与费用\"></a>燃料与费用</h2><p>交易发起人提供足够的燃料与提供足够的费用是有区别的。以下是对交易的可能影响：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>燃料</th>\n<th>费用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>太低</td>\n<td>不会广播给矿工（错误：<code>intrinsic gas too low</code>）</td>\n<td>矿工不会执行计算</td>\n</tr>\n<tr>\n<td>低</td>\n<td>少量计算或者燃料耗尽</td>\n<td>之后会打包进区块</td>\n</tr>\n<tr>\n<td>中等</td>\n<td>通常是理想的</td>\n<td>通常是理想的</td>\n</tr>\n<tr>\n<td>高</td>\n<td>可能导致打包被延迟</td>\n<td>尽快被打包入区块</td>\n</tr>\n<tr>\n<td>太高</td>\n<td>不会广播给矿工（错误：<code>exceeds block gas limit</code>）</td>\n<td>如果交易发起人没有足够的以太币，则不会广播给矿工</td>\n</tr>\n</tbody>\n</table>\n<p>尽管提供了费用，但是一笔燃料很低的交易甚至可能不会到达矿工处。如果一笔交易提供了足够的燃料，但是费用很低，即使该交易到达矿工处，当矿工看到这个费用之后也不会对其进行计算处理。费用决定了交易将被打包进入区块的顺序。而提供高燃料会导致交易打包时间更长的原因在本文中 <em>高初始燃气可能会导致延迟</em> 部分。</p>\n<h2 id=\"初始燃气\"><a href=\"#初始燃气\" class=\"headerlink\" title=\"初始燃气\"></a>初始燃气</h2><p>让我们讨论一下交易开始时的燃料需求。抽象地说，在被允许使用世界计算机的计算和存储之前，世界计算机需要知道交易发起人是否有能力支付费用。具体地说，在处理交易之前，矿工需要知道自己是否可以获得报酬。一笔交易需要指定它愿意花费的最大燃料值。对于本文的目的来说，这个需求被称作初始燃气。初始燃气是交易的重要部分。不幸的是，不同的文档使用了不同的词来描述这个关键部分：</p>\n<ul>\n<li><a href=\"https://github.com/ethereum/wiki/wiki/White-Paper\" target=\"_blank\" rel=\"noopener\">以太坊白皮书</a>中使用了 初始燃气</li>\n<li><a href=\"https://github.com/ethereum/yellowpaper\" target=\"_blank\" rel=\"noopener\">以太坊黄皮书</a>中使用了燃料限制</li>\n<li><a href=\"https://github.com/ethereum/go-ethereum/releases\" target=\"_blank\" rel=\"noopener\">Geth</a> 和 <a href=\"https://github.com/ethereum/web3.js/releases\" target=\"_blank\" rel=\"noopener\">web3.js</a> 等软件中，简单地使用了 “燃气”。</li>\n</ul>\n<p>因为在通常情况下，不真正运行计算（关联 <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" target=\"_blank\" rel=\"noopener\">停机问题</a>），矿工是不知道到底需要多少计算量的，所以初始燃气使事情变得更加简单（而不用 “燃气作为支付的消耗方式”（away from say a pay as gas is consumed approach） 这种说法）。作为一个以太坊应用的用户，必须提供初始燃气似乎很复杂，但开发人员可以使用一些工具来估计初始燃气并隐藏用户的详细信息。</p>\n<h2 id=\"燃料耗尽异常\"><a href=\"#燃料耗尽异常\" class=\"headerlink\" title=\"燃料耗尽异常\"></a>燃料耗尽异常</h2><p>一笔交易提供了它愿意消耗的最大燃料值。该燃气会被 EVM 中的每个操作消耗。如果燃料消耗完毕，而交易还未完成，那么一个燃料耗尽的异常就会发生。交易发起人为已经执行的操作支付，而交易也被打包进区块，但是所有的状态改变（比如合约的创建，值的存储，和<a href=\"https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e\" target=\"_blank\" rel=\"noopener\">日志</a>的写入）都会回滚。</p>\n<p>让我们还是使用第一个例子作为场景，但是这次交易发起人指定初始燃气为 90（而不是 150）。这里是执行的示意图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>操作的燃料消耗</th>\n<th>剩余燃料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易开始</td>\n<td></td>\n<td>90</td>\n</tr>\n<tr>\n<td>存储 31</td>\n<td>45</td>\n<td>45</td>\n</tr>\n<tr>\n<td>求和</td>\n<td>10</td>\n<td>35</td>\n</tr>\n<tr>\n<td>保存和</td>\n<td>45</td>\n<td>燃料耗尽</td>\n</tr>\n<tr>\n<td>交易结束</td>\n<td>因为燃料耗尽，存储的 31 会回滚</td>\n<td>耗尽</td>\n</tr>\n</tbody>\n</table>\n<p>在交易开始时，交易发起人需要拿出所有燃料的资金： 初始燃气 * 燃气价格 = 存放在柜台的以太币。柜台中的以太币数量为：</p>\n<p><strong>90 × 0.02µETH = 1.8µETH</strong></p>\n<p>当每个操作执行时，燃气会消耗，而在存储和时产生了燃料耗尽异常。这会导致所有的操作撤销，代表数字 31 会被回滚到它之前存储的值，但是交易依旧被打包进入区块链，而且矿工获得所有的酬金：1.8μ ETH。</p>\n<h2 id=\"燃气回退\"><a href=\"#燃气回退\" class=\"headerlink\" title=\"燃气回退\"></a>燃气回退</h2><p>EVM 中有两个负值燃气的操作：</p>\n<ul>\n<li>清空合约是 -24000</li>\n<li>清空存储是 -15000</li>\n</ul>\n<p>当 EVM 执行了这样的一个操作，它将被记录在单独的退款计数器中。燃气退款仅在交易结束时提供。 此外，最高返还金额等于一半已经消耗的燃气。</p>\n<p>一个关键点在于，一笔交易的燃料永远不会增加。当 EVM 执行操作时，燃料总是减少（当一些合约或者存储被清空，退款计数器会增加）。如果燃料到零或者负数，那么立马会产生一个燃料耗尽异常：退款计数器中有多少燃气并不重要。一笔交易为了能够使用燃气退款，它必须避免燃料耗尽异常。假设一笔交易有足够的燃气，然后它就能使用退款计数器中的燃气。</p>\n<p>退款的燃气值最多为消耗的燃气值的一半。例如，如果一笔交易使用了 60000 燃气，然后清空了 2 个合约而获得 48000 的一笔退款（每笔 24000），交易发起人还是需要支付给矿工 30000 燃气。这激励了矿工使用负值燃气操作处理交易，因为这给了他们收入，并确保了矿工不可能为他人的计算付款。</p>\n<h2 id=\"区块燃气限制（Block-gas-limit-BGL）\"><a href=\"#区块燃气限制（Block-gas-limit-BGL）\" class=\"headerlink\" title=\"区块燃气限制（Block gas limit:BGL）\"></a>区块燃气限制（Block gas limit:BGL）</h2><p>回顾一下，初始燃气由用户指定，是一笔交易将要消耗的燃料最大值。那么一个区块中能够容纳多少交易呢？答案是直到所有交易的初始燃气总和达到区块燃气限制（BGL）为止。当前(2016/6/23)的 BGL 是 4,712,388 （1.5π 的数字形式），表示能够在一个区块（平均出块时间 15 秒）中容纳 224 笔初始燃气为 21000 的交易。为了防止像比特币一样对区块是否变大产生分歧，以太坊协议允许矿工对自己的区块往任意方向进行 1/1024(0.0976%) 幅度的 BGL 调整。与协议不同的是默认的采矿策略，其最小 BGL 为 4,712,388。</p>\n<h2 id=\"高初始燃气可能存在的延迟\"><a href=\"#高初始燃气可能存在的延迟\" class=\"headerlink\" title=\"高初始燃气可能存在的延迟\"></a>高初始燃气可能存在的延迟</h2><p>既然燃料耗尽异常对交易发起人来说几乎是在浪费金钱，那么将初始燃气设置得更高总是更好的。所以，交易发起人为什么不总是将初始燃气指定为 4,000,000 呢？</p>\n<p>答案在于交易的初始燃气和它实际消耗的燃气之间的差异。矿工只会获得一笔交易实际消耗的燃气；所有未使用的燃气会被回退给交易发起人。</p>\n<p>如果同时存在一笔初始燃气为 4M 的交易和 100 笔初始燃气为 40,000 的交易，矿工可能会选择后者，因为这 100 笔交易的收入有更高的预测性。如果一笔初始燃气为 4M 的交易实际只消耗了 1M 燃气，那么矿工将损失 3M 的潜在燃气收入。所以，矿工更愿意优先考虑一些“小”交易，而不是拥有高初始燃气（除非<a href=\"https://github.com/ethereum/pyethereum/blob/3841e9a406f4ca9452afa45035fb07b5ce6314d9/ethereum/transactions.py#L177\" target=\"_blank\" rel=\"noopener\">内在气体</a>也十分高）的一笔交易。这会导致高初始燃气的交易在被打包之前存在延迟，并且也解释了过高的初始燃气可能会是有害的。</p>\n<h2 id=\"绕过交易所\"><a href=\"#绕过交易所\" class=\"headerlink\" title=\"绕过交易所\"></a>绕过交易所</h2><p>以太坊有两种类型的账户：</p>\n<ul>\n<li>用户账户（由私钥控制）</li>\n<li>合约（由代码控制）</li>\n</ul>\n<p>发送以太币到一个用户账户需要 21000 的燃气费用，而发送以太币到合约则需要更高的费用，这个费用取决于合约代码和交易中发送的数据。一些交易所会对他们所有的交易都只提供 21000 燃气，这表示在用户想要从交易所发送以太币到他们 Mist（以太坊钱包） 中的合约钱包时，交易会耗尽燃料，以太币永远也不会发送到用户的合约钱包。</p>\n<h2 id=\"计量和费用\"><a href=\"#计量和费用\" class=\"headerlink\" title=\"计量和费用\"></a>计量和费用</h2><p>关于计量和费用之间的区别还有一点需要注意。在比特币中，计量是根据字节来的：交易中的字节数。在以太坊中，计算也需要计量，因为少量的代码也可能被编码成永远执行。计量计算量也是使用燃气的一个原因。但是拥有燃气不代表需要费用。</p>\n<p>比如，在一个私链上，每个账户每天可以拥有 X 燃气，或者是每笔交易 Y 燃气，或者其他方案。另一方面，有费用不代表需要燃气：费用可以基于不同的计量，如字节。对于公有链上的安全性来说，燃气和费用两者都需要，而替代方案可能更适合私有链（比如，对于任何人都可以创建账户的公有链来说，每个账户每天有 X 燃气，可以被“女巫攻击”（Sybil-attacked））。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>燃气是使用世界计算机的计量方式和燃料，与使用世界计算机所支付的以太币费用是不同的。提供足够的燃料和足够的费用，两者之间是有区别的。运行时燃料耗尽会花费钱，而提供更多的燃气会使得更加安全，反正所有的未使用的燃气都会被回退。燃气是以太坊的核心部分，它的大多数话题已经被讨论过。这里有更多关于它的信息，包括<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas\" target=\"_blank\" rel=\"noopener\">估计燃气</a>，内在燃气（intrinsic gas），<a href=\"https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle\" target=\"_blank\" rel=\"noopener\">燃气价格预告（gas price oracle）</a>，<a href=\"https://ethereum.stackexchange.com/questions/1106/is-there-a-limit-for-transaction-size\" target=\"_blank\" rel=\"noopener\">交易大小的影响</a>，读者可以在本文的基础上进一步地探索和理解。</p>\n"},{"title":"手机钱包常见名词解释","comments":0,"date":"2018-03-02T08:44:06.000Z","img":null,"_content":"\n在使用imtoken的时候创建一个钱包的的流程如下\n\n![](/images/wallet.jpeg)\n这里涉及到的几个名词:\n* **用户名**、\n* **密码**、\n* **钱包地址**、\n* **私钥**、\n* **Keystore**、\n* **助记词**\n\n这些分别是什么呢？又有些什么作用呢?\n\n### 1.用户名：\n\n首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。\n\n### 2.密码：\n\n密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。\n\t\t\t\t\t    \n用途：\n1.导出私钥时候使用，\n2.导入导出keystore时使用，\n3.导出助记词时候使用，\n4.转账的时候使用\n\t\t\t\t\t\t\t\t\t\t    \n*注意*：\n\n密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。\n\n### 3.钱包地址：\n钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n用途：\n1：你给别人转账的时候就是通过对方的钱包地址。\n2：查询转账记录也是通过钱包地址来查询的。\n\n### 4.私钥：\n私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。\n\n*注意：*\n通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。\n\n### 5.Keystore:\n文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。\n\n### 6.助记词：\n\n助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。\n\n**注意**：\n\n私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。\n","source":"_posts/手机钱包常见名词解释.md","raw":"---\ntitle: 手机钱包常见名词解释\ncomments: false\ndate: 2018-03-02 16:44:06\ncategories: 钱包\ntags: \n- ciscolxh \n- 钱包\nimg:\n---\n\n在使用imtoken的时候创建一个钱包的的流程如下\n\n![](/images/wallet.jpeg)\n这里涉及到的几个名词:\n* **用户名**、\n* **密码**、\n* **钱包地址**、\n* **私钥**、\n* **Keystore**、\n* **助记词**\n\n这些分别是什么呢？又有些什么作用呢?\n\n### 1.用户名：\n\n首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。\n\n### 2.密码：\n\n密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。\n\t\t\t\t\t    \n用途：\n1.导出私钥时候使用，\n2.导入导出keystore时使用，\n3.导出助记词时候使用，\n4.转账的时候使用\n\t\t\t\t\t\t\t\t\t\t    \n*注意*：\n\n密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。\n\n### 3.钱包地址：\n钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n用途：\n1：你给别人转账的时候就是通过对方的钱包地址。\n2：查询转账记录也是通过钱包地址来查询的。\n\n### 4.私钥：\n私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。\n\n*注意：*\n通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。\n\n### 5.Keystore:\n文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。\n\n### 6.助记词：\n\n助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。\n\n**注意**：\n\n私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。\n","slug":"手机钱包常见名词解释","published":1,"updated":"2018-03-07T10:09:33.394Z","layout":"post","photos":[],"link":"","_id":"cjejlcu6z000gl8jxzwhcu9yj","content":"<p>在使用imtoken的时候创建一个钱包的的流程如下</p>\n<p><img src=\"/images/wallet.jpeg\" alt=\"\"><br>这里涉及到的几个名词:</p>\n<ul>\n<li><strong>用户名</strong>、</li>\n<li><strong>密码</strong>、</li>\n<li><strong>钱包地址</strong>、</li>\n<li><strong>私钥</strong>、</li>\n<li><strong>Keystore</strong>、</li>\n<li><strong>助记词</strong></li>\n</ul>\n<p>这些分别是什么呢？又有些什么作用呢?</p>\n<h3 id=\"1-用户名：\"><a href=\"#1-用户名：\" class=\"headerlink\" title=\"1.用户名：\"></a>1.用户名：</h3><p>首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。</p>\n<h3 id=\"2-密码：\"><a href=\"#2-密码：\" class=\"headerlink\" title=\"2.密码：\"></a>2.密码：</h3><p>密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。</p>\n<p>用途：<br>1.导出私钥时候使用，<br>2.导入导出keystore时使用，<br>3.导出助记词时候使用，<br>4.转账的时候使用</p>\n<p><em>注意</em>：</p>\n<p>密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。</p>\n<h3 id=\"3-钱包地址：\"><a href=\"#3-钱包地址：\" class=\"headerlink\" title=\"3.钱包地址：\"></a>3.钱包地址：</h3><p>钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。</p>\n<p>用途：<br>1：你给别人转账的时候就是通过对方的钱包地址。<br>2：查询转账记录也是通过钱包地址来查询的。</p>\n<h3 id=\"4-私钥：\"><a href=\"#4-私钥：\" class=\"headerlink\" title=\"4.私钥：\"></a>4.私钥：</h3><p>私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。</p>\n<p><em>注意：</em><br>通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。</p>\n<h3 id=\"5-Keystore\"><a href=\"#5-Keystore\" class=\"headerlink\" title=\"5.Keystore:\"></a>5.Keystore:</h3><p>文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。</p>\n<h3 id=\"6-助记词：\"><a href=\"#6-助记词：\" class=\"headerlink\" title=\"6.助记词：\"></a>6.助记词：</h3><p>助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。</p>\n<p><strong>注意</strong>：</p>\n<p>私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用imtoken的时候创建一个钱包的的流程如下</p>\n<p><img src=\"/images/wallet.jpeg\" alt=\"\"><br>这里涉及到的几个名词:</p>\n<ul>\n<li><strong>用户名</strong>、</li>\n<li><strong>密码</strong>、</li>\n<li><strong>钱包地址</strong>、</li>\n<li><strong>私钥</strong>、</li>\n<li><strong>Keystore</strong>、</li>\n<li><strong>助记词</strong></li>\n</ul>\n<p>这些分别是什么呢？又有些什么作用呢?</p>\n<h3 id=\"1-用户名：\"><a href=\"#1-用户名：\" class=\"headerlink\" title=\"1.用户名：\"></a>1.用户名：</h3><p>首先从用户名说起，用户名就是我们给不同钱包起的一个名字，如果没有用户名的话区分不同钱包就应该是用地址来区分了，地址是一个以0x开头的，42位的16进制数，相对来说是不好记忆更不方便我们区分钱包。</p>\n<h3 id=\"2-密码：\"><a href=\"#2-密码：\" class=\"headerlink\" title=\"2.密码：\"></a>2.密码：</h3><p>密码的作用是保护钱包安全的。所有的敏感操作都要使用密码才能进行。</p>\n<p>用途：<br>1.导出私钥时候使用，<br>2.导入导出keystore时使用，<br>3.导出助记词时候使用，<br>4.转账的时候使用</p>\n<p><em>注意</em>：</p>\n<p>密码只是存在本地的，也就是说同一个钱包在A手机上设置了一个密码，导入B手机中并不需要设置和A手机中的密码一样。</p>\n<h3 id=\"3-钱包地址：\"><a href=\"#3-钱包地址：\" class=\"headerlink\" title=\"3.钱包地址：\"></a>3.钱包地址：</h3><p>钱包地址是一个以0x开头的十六进制的四十二位数。一个钱包只有一个地址。就相当于银行卡的银行卡号。</p>\n<p>用途：<br>1：你给别人转账的时候就是通过对方的钱包地址。<br>2：查询转账记录也是通过钱包地址来查询的。</p>\n<h3 id=\"4-私钥：\"><a href=\"#4-私钥：\" class=\"headerlink\" title=\"4.私钥：\"></a>4.私钥：</h3><p>私钥是在创建钱包时候生成的。他是一个64 位 16 进制的哈希值字符串，例如：“ad025560b0db0bef204a12f67407d485661737698c62b345a84fc1aedf9ce7f9”。一个钱包对应一个私钥并且不能修改。私钥决定了钱包的所有权，可以通过密码导出私钥，也可以通过私钥把钱包导入另一个手机中去。</p>\n<p><em>注意：</em><br>通过A手机把私钥导出，然后再导入B手机中设置密码，密码不需要和A手机中的密码相同，就可以操作对应的钱包，所以私钥不要随便暴露给别人。</p>\n<h3 id=\"5-Keystore\"><a href=\"#5-Keystore\" class=\"headerlink\" title=\"5.Keystore:\"></a>5.Keystore:</h3><p>文件是以太坊钱包存储私钥的一种文件格式 (JSON)，keystore相当于加密后的私钥，和私钥的用途是相同的，在A手机通过密码导出keystore，然后通过密码和keystore可以把钱包导入B手机中。但是使用方法有些许不同，通过秘钥导入可以在B手机随便设置密码，而通过keystore导入的时候必须使用导出时候用到的密码。也就是生成的keystore和生成时候的密码相匹配。如果密码丢失你也失去了对keystore的控制权。</p>\n<h3 id=\"6-助记词：\"><a href=\"#6-助记词：\" class=\"headerlink\" title=\"6.助记词：\"></a>6.助记词：</h3><p>助记词，可以在第一次创建账户后导出，助记词是私钥的另一种表现形式，助记词一般由12、15、18、21个单词构成，他的作用和私钥是一样的。拿到助记词可以把钱包导入手机，操作钱包。</p>\n<p><strong>注意</strong>：</p>\n<p>私钥=助记词=keystory+密码，私钥，助记词，keystory一定要妥善保管，可以通过他们三个任何一个都可以把钱包备份到另一个设备导入另一个设备，如果丢失只能尽快把钱包中的币转入安全的钱包中。</p>\n"},{"title":"智能合约最佳实践翻译一","comments":0,"date":"2018-03-09T03:06:28.000Z","img":null,"_content":"\n[原文链接](https://consensys.github.io/smart-contract-best-practices/general_philosophy/)\n\n## 常规理念\n\n以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。\n\n智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：\n\n### 做好失败的准备\n\n任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。\n\n* 当出现错误时暂停该合约（“电路中断者”） \n* 管理风险金额（限制比例，设置最大使用量）\n* 为错误修正和改进提供有效的升级途径\n\n### 小心地推出\n\n在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。\n\n### 保持合约简单\n\n复杂性增加错误的可能性。\n\n* 确定合约的逻辑简单\n* 通过模块化使得合约和函数小巧\n* 在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）\n* 只要有可能，请尽量保持清晰\n* 只对你的系统中需要去中心化的部分使用区块链\n\n### 保持更新\n\n使用下一节中列出的资源跟踪新的安全开发。\n\n* 检测你的合同是否有任何新发现的 bug\n* 尽可能快的将工具或者类库更新到最新的版本\n* 接受新的使用的安全技术\n\n### 注意区块链的属性\n\n虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。\n* 要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。\n* 了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。\n* 记住燃料的消耗和区块燃料的限制。\n\n### 基本权衡：简单与复杂的实例\n\n在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。\n\n从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。\n\n但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：\n\n* 静态 与 可升级\n* 整体 与 模块化\n* 重复 与 复用\n\n### 静态和可升级\n\n尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。\n\n根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。\n\n### 单一整体和模块化\n\n一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。\n\n与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。\n\n### 复制与复用\n\n从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。\n\n在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。\n","source":"_posts/智能合约最佳实践翻译一.md","raw":"---\ntitle: 智能合约最佳实践翻译一\ncomments: false\ndate: 2018-03-09 11:06:28\ncategories: 区块链\ntags: \n- ZhouFyk\n- 以太坊\n- 智能合约\n- 安全开发\nimg:\n---\n\n[原文链接](https://consensys.github.io/smart-contract-best-practices/general_philosophy/)\n\n## 常规理念\n\n以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。\n\n智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：\n\n### 做好失败的准备\n\n任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。\n\n* 当出现错误时暂停该合约（“电路中断者”） \n* 管理风险金额（限制比例，设置最大使用量）\n* 为错误修正和改进提供有效的升级途径\n\n### 小心地推出\n\n在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。\n\n### 保持合约简单\n\n复杂性增加错误的可能性。\n\n* 确定合约的逻辑简单\n* 通过模块化使得合约和函数小巧\n* 在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）\n* 只要有可能，请尽量保持清晰\n* 只对你的系统中需要去中心化的部分使用区块链\n\n### 保持更新\n\n使用下一节中列出的资源跟踪新的安全开发。\n\n* 检测你的合同是否有任何新发现的 bug\n* 尽可能快的将工具或者类库更新到最新的版本\n* 接受新的使用的安全技术\n\n### 注意区块链的属性\n\n虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。\n* 要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。\n* 了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。\n* 记住燃料的消耗和区块燃料的限制。\n\n### 基本权衡：简单与复杂的实例\n\n在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。\n\n从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。\n\n但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：\n\n* 静态 与 可升级\n* 整体 与 模块化\n* 重复 与 复用\n\n### 静态和可升级\n\n尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。\n\n根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。\n\n### 单一整体和模块化\n\n一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。\n\n与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。\n\n### 复制与复用\n\n从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。\n\n在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。\n","slug":"智能合约最佳实践翻译一","published":1,"updated":"2018-03-09T04:01:10.544Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7a000ll8jxs52zonmm","content":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/general_philosophy/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"常规理念\"><a href=\"#常规理念\" class=\"headerlink\" title=\"常规理念\"></a>常规理念</h2><p>以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。</p>\n<p>智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：</p>\n<h3 id=\"做好失败的准备\"><a href=\"#做好失败的准备\" class=\"headerlink\" title=\"做好失败的准备\"></a>做好失败的准备</h3><p>任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。</p>\n<ul>\n<li>当出现错误时暂停该合约（“电路中断者”） </li>\n<li>管理风险金额（限制比例，设置最大使用量）</li>\n<li>为错误修正和改进提供有效的升级途径</li>\n</ul>\n<h3 id=\"小心地推出\"><a href=\"#小心地推出\" class=\"headerlink\" title=\"小心地推出\"></a>小心地推出</h3><p>在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。</p>\n<h3 id=\"保持合约简单\"><a href=\"#保持合约简单\" class=\"headerlink\" title=\"保持合约简单\"></a>保持合约简单</h3><p>复杂性增加错误的可能性。</p>\n<ul>\n<li>确定合约的逻辑简单</li>\n<li>通过模块化使得合约和函数小巧</li>\n<li>在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）</li>\n<li>只要有可能，请尽量保持清晰</li>\n<li>只对你的系统中需要去中心化的部分使用区块链</li>\n</ul>\n<h3 id=\"保持更新\"><a href=\"#保持更新\" class=\"headerlink\" title=\"保持更新\"></a>保持更新</h3><p>使用下一节中列出的资源跟踪新的安全开发。</p>\n<ul>\n<li>检测你的合同是否有任何新发现的 bug</li>\n<li>尽可能快的将工具或者类库更新到最新的版本</li>\n<li>接受新的使用的安全技术</li>\n</ul>\n<h3 id=\"注意区块链的属性\"><a href=\"#注意区块链的属性\" class=\"headerlink\" title=\"注意区块链的属性\"></a>注意区块链的属性</h3><p>虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。</p>\n<ul>\n<li>要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。</li>\n<li>了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。</li>\n<li>记住燃料的消耗和区块燃料的限制。</li>\n</ul>\n<h3 id=\"基本权衡：简单与复杂的实例\"><a href=\"#基本权衡：简单与复杂的实例\" class=\"headerlink\" title=\"基本权衡：简单与复杂的实例\"></a>基本权衡：简单与复杂的实例</h3><p>在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。</p>\n<p>从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。</p>\n<p>但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：</p>\n<ul>\n<li>静态 与 可升级</li>\n<li>整体 与 模块化</li>\n<li>重复 与 复用</li>\n</ul>\n<h3 id=\"静态和可升级\"><a href=\"#静态和可升级\" class=\"headerlink\" title=\"静态和可升级\"></a>静态和可升级</h3><p>尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。</p>\n<p>根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。</p>\n<h3 id=\"单一整体和模块化\"><a href=\"#单一整体和模块化\" class=\"headerlink\" title=\"单一整体和模块化\"></a>单一整体和模块化</h3><p>一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。</p>\n<p>与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。</p>\n<h3 id=\"复制与复用\"><a href=\"#复制与复用\" class=\"headerlink\" title=\"复制与复用\"></a>复制与复用</h3><p>从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。</p>\n<p>在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/general_philosophy/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"常规理念\"><a href=\"#常规理念\" class=\"headerlink\" title=\"常规理念\"></a>常规理念</h2><p>以太坊和复杂的区块链编程是崭新的和高度实验性的。 因此，随着新 bug 和安全风险的发现，您应该预期到安全形势会不断发生变化，并制定新的最佳实践。 因此，遵循本文档中的安全措施只是作为智能合约开发人员需要做的安全工作的开始。</p>\n<p>智能合约编程需要一个与您过往习惯不同的工程思维。失败的代价可能很高，并且更改可能很困难，使得它在某些方面更像硬件编程或金融服务编程，而不是 Web 或移动开发。因此，防御已知的漏洞是不够的。相反，你需要学习一种新的开发理念：</p>\n<h3 id=\"做好失败的准备\"><a href=\"#做好失败的准备\" class=\"headerlink\" title=\"做好失败的准备\"></a>做好失败的准备</h3><p>任何不平凡的（non-trivial）合约中都有错误。因此你的代码必须能够优雅地反馈 Bug 和漏洞。</p>\n<ul>\n<li>当出现错误时暂停该合约（“电路中断者”） </li>\n<li>管理风险金额（限制比例，设置最大使用量）</li>\n<li>为错误修正和改进提供有效的升级途径</li>\n</ul>\n<h3 id=\"小心地推出\"><a href=\"#小心地推出\" class=\"headerlink\" title=\"小心地推出\"></a>小心地推出</h3><p>在完整的产品发布前捕获错误总是更好。彻底地测试合约，并在每次发现新的攻击媒介时添加新的测试 - 从 alpha 测试网络起就提供 Bug 悬赏 - 随着每个阶段的使用和测试推出。</p>\n<h3 id=\"保持合约简单\"><a href=\"#保持合约简单\" class=\"headerlink\" title=\"保持合约简单\"></a>保持合约简单</h3><p>复杂性增加错误的可能性。</p>\n<ul>\n<li>确定合约的逻辑简单</li>\n<li>通过模块化使得合约和函数小巧</li>\n<li>在可以使用的地方使用已经存在的工具或者代码（比如，不要使用你自己写的随机数生成器）</li>\n<li>只要有可能，请尽量保持清晰</li>\n<li>只对你的系统中需要去中心化的部分使用区块链</li>\n</ul>\n<h3 id=\"保持更新\"><a href=\"#保持更新\" class=\"headerlink\" title=\"保持更新\"></a>保持更新</h3><p>使用下一节中列出的资源跟踪新的安全开发。</p>\n<ul>\n<li>检测你的合同是否有任何新发现的 bug</li>\n<li>尽可能快的将工具或者类库更新到最新的版本</li>\n<li>接受新的使用的安全技术</li>\n</ul>\n<h3 id=\"注意区块链的属性\"><a href=\"#注意区块链的属性\" class=\"headerlink\" title=\"注意区块链的属性\"></a>注意区块链的属性</h3><p>虽然你的编程经验大部分将与以太坊编程相关，但有一些陷阱需要注意。</p>\n<ul>\n<li>要非常小心外部合约的调用，这可能会执行恶意代码并更改控制流。</li>\n<li>了解你的公共函数是公开的，可能会被恶意地调用。任何人都可以查看您的私人数据。</li>\n<li>记住燃料的消耗和区块燃料的限制。</li>\n</ul>\n<h3 id=\"基本权衡：简单与复杂的实例\"><a href=\"#基本权衡：简单与复杂的实例\" class=\"headerlink\" title=\"基本权衡：简单与复杂的实例\"></a>基本权衡：简单与复杂的实例</h3><p>在评估智能合约系统的结构和安全性时，需要考虑多个基本的权衡。任何智能合约系统的常规建议是在这些基本的权衡之间找到合适的平衡点。</p>\n<p>从软件工程来说，理想的智能合约系统是模块化的，复用代码而不是复制代码，并且支持组建可升级。从安全架构来看，一个理想的智能合约要分享它的观念模式，特别是复杂的智能合约系统。</p>\n<p>但是，也存在着软件工程和安全不能保持一致的重要的例外。在这些情况下，通过顺着合约系统的维度的最佳组合获得合适的平衡点，比如：</p>\n<ul>\n<li>静态 与 可升级</li>\n<li>整体 与 模块化</li>\n<li>重复 与 复用</li>\n</ul>\n<h3 id=\"静态和可升级\"><a href=\"#静态和可升级\" class=\"headerlink\" title=\"静态和可升级\"></a>静态和可升级</h3><p>尽管包括这个在内的多种资源强调拓展特性，例如可删除，可升级或者可修改的模式，但在可塑性和安全性之间还是需要一个基本的平衡。</p>\n<p>根据定义，可塑性模式增加了复杂性和潜在的被攻击可能性。在智能合约系统在预定义的有限时间段内执行非常有限的一组功能的情况下，简单性比复杂性更有效率，例如，无管理的有限时间帧令牌销售合约系统。</p>\n<h3 id=\"单一整体和模块化\"><a href=\"#单一整体和模块化\" class=\"headerlink\" title=\"单一整体和模块化\"></a>单一整体和模块化</h3><p>一个单一的只有自身的合约保证了所有的内容都可以在自身被识别与读取。尽管几乎很少有被高度重视的智能合约系统作为一个庞然大物单独存在，但是也有一个理由极端地要求数据和流程在本地 - 例如，优化代码审查效率的情况下。</p>\n<p>与在此考虑的其他平衡一样，安全最佳实践趋向于在简单短期合约中的使用软件工程最佳实践，以及在更复杂更长久的合约系统中趋向于软件工程最佳实践。</p>\n<h3 id=\"复制与复用\"><a href=\"#复制与复用\" class=\"headerlink\" title=\"复制与复用\"></a>复制与复用</h3><p>从软件工程的角度看，智能合约系统希望在合理的情况下最大限度地提高重用率。在 Solidity 中有很多方法可以重用合约代码。使用自己拥有的经过验证的已经被部署了的合约通常是实现代码复用的最安全方式。</p>\n<p>在自己之前已经部署的合约不可用的情况下，通常就会依赖复制。Live Libs 和 Zeppelin Solidity 等努力试图提供一些模式，一遍复用安全代码而不是复制。任何合约安全分析必须包含之前没有建立与目标智能合约系统中的资金风险相当的信任等级的任何复用的代码。</p>\n"},{"title":"智能合约最佳实践翻译三","comments":0,"date":"2018-03-09T03:17:08.000Z","img":null,"_content":"\n## 已知攻击\n\n以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。\n\n### [竞争条件](https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology)(Race Conditions)\n\n调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。\n\n#### 重入(Reentrancy)\n\n这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call's code is executed, and can call withdrawBalance again\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。\n\n在给出的例子中，避免这个问题的最好的办法是通过 [使用 `send()` 代替 `call.value()()`](https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value)。这会防止执行中的任何外部代码。\n\n然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：\n```\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\tuserBalances[msg.sender] = 0;\n\trequire(msg.sender.call.value(amountToWithdraw)());\n}\n```\n\n注意，如果你有另一个调用了 `withdrawBalance()`的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。\n\n#### 函数交叉竞争条件(Cross-function Race Conditions)\n\n一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。\n\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction transfer(address to, uint amount) {\n\tif (userBalances[msg.sender] >= amount) {\n\t\tuserBalance[to] += amount;\n\t\tuserBalance[msg.sender] -= amount;\n\t}\n}\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n在这个例子中，当攻击者的代码在 `withdrawBalance()` 中的外部调用中被执行，攻击者会调用 `transfer()`。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。\n\n在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。\n\n#### 竞争条件解决方案中的陷阱\n\n因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。\n\n相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：\n```\n// insecure\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction withdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction getFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\trewardsForA[recipient] += 100;\n\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n\tclaimedBonus[recipient] = true;\n}\n```\n\n即使 `getFirstWithdrawalBonus()` 没有直接调用外部合约，`withdraw()` 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 `withdraw()` 函数。\n```\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction untrustedWithdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction untrustedGetFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\tclaimedBonus[recipient] = true;\n\trewardsForA[recipient] += 100;\n\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible\n}\n```\n\n除了修复重入的问题，[不受信任的函数也被标记了](https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts)。这个模式在每个层级都被重复使用：既然 `untrustedGetFirstWithdrawalBonus()` 调用了调用了外部合约的 `untrustedWithdraw()`，那么你就必须将 `untrustedGetFirstWithdrawalBonus()` 视作不安全的。\n\n另一个经常建议的解决方案是一个 [互斥](https://en.wikipedia.org/wiki/Mutual_exclusion)。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：\n```\n// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\nmapping(address => uint) private balance;\nbool private lockBalances;\n\nfunction deposit() payable public returns (bool) {\n\trequire(!lockBalances);\n\tlockBalances = true;\n\tbalances[msg.sender] += msg.value;\n\tlockBalances = false;\n\treturn true;\n}\n\nfunction withdraw(uint amount) payable public returns (bool) {\n\trequire(!lockBalances && amount > 0 && balances[msg.sender] >= amount);\n\tlockBalances = true;\n\n\tif (msg.sender.call(amount)()) {\n\t\tbalances[msg.sender] -= amount;\n\t}\n\n\tlockBalances = false;\n\treturn true;\n}\n```\n\n如果用户试图在第一个调用结束前再次调用 `withdraw()`，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：\n```\n// insecure\n\ncontract StateHolder {\n\tuint private n;\n\taddress private lockHolder;\n\n\tfunction getLock() {\n\t\trequire(lockHolder == 0);\n\t\tlockHolder = msg.sender;\n\t}\n\n\tfunction releaseLock() {\n\t\trequire(msg.sender == lockHolder);\n\t\tlockHolder = 0;\n\t}\n\n\tfunction set(uint newState) {\n\t\trequire(msg.sender == lockHolder);\n\t\tn = newState;\n\t}\n}\n```\n\n一个攻击者可以调用 `getLock()`，之后就永远不用调用 `releaseLock()`。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）\n\n###### 有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\n\n### 交易顺序依赖（TOD）/ 前台运行\n\n以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。\n\n在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。\n\n### 时间戳依赖\n\n注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。\n\n有关与时间戳相关的设计注意事项，请参阅 [建议](https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence) 部分。\n\n### 整数溢出和下溢\n\n考虑一个简单的 token 转移：\n```\nmapping(address => uint256) public balanceOf;\n\n// insecure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance\n\trequire(balanceOf[msg.sender] >= _value);\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n\n// secure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance and for overflows\n\trequire(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);\n\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n```\n\n如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。\n\n对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。\n\n对 uint8, uint16, uint24... 等更小的数据类型要小心：它们会更容易的达到它们的最大值。\n\n注意这里有大约 [20 个关于溢出和下溢的例子](https://github.com/ethereum/solidity/issues/796#issuecomment-253578925)\n\n### （不期望的）回滚导致的 DoS\n\n考虑一个简单的拍卖合约：\n```\n// insecure\n\ncontract Auction {\n\taddress currentLeader;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value > highestBid);\n\n\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n\t\tcurrentLeader = msg.sender;\n\t\thighestBid = msg.value;;\n\t}\n}\n```\n\n当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款*总是*失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 `bid()` 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 [拉取支付系统](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls) 来替代。\n\n另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。\n\n```\naddress[] private refundAddresses;\nmapping(address => uint) public refunds;\n\n// bad\nfunction refundAll() public {\n\tfor (uint x; x < refundAddresses.length; x++) { // // arbitrary length iteration based on how many addresses participated\n\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds\n\t}\n}\n```\n\n再一次，推荐的解决方法是 [赞成拉推支付](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)。\n\n### 区块燃料限制导致的 DoS\n\n你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。\n\n即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。\n\n这是另一个 [赞成推拉支付](https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls) 的原因。\n\n如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：\n```\nstruct Payee {\n\taddress addr;\n\tuint256 value;\n}\n\nPayee[] payees;\nuint256 nextPayeeIndex;\n\nfunction payOut() {\n\tuint256 i = nextPayeeIndex;\n\twhile (i < payees.length && msg.gas > 200000) {\n\t\tpayees[i].addr.send(payees[i].value);\n\t\ti++;\n\t}\n\tnextPayeeIndex = i;\n}\n```\n\n你会需要确认在等待 `payOut()` 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。\n\n### 强制将 ETH 发送到合约\n\n可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：\n```\ncontract Vulnerable {\n\tfunction () payable {\n\t\trevert();\n\t}\n\n\tfunction somethingBad() {\n\t\trequire(this.balance > 0);\n\t\t// do something bad\n\t}\n}\n```\n\n合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。\n\n合约方法 `selfdestruct` 允许用户指定一个受益人发送多余的 ETH。`selfdestruct` [不会触发合约的 fallback 函数](https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether)。\n\n也可以[预先计算](https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo)合约的地址，然后在合约部署之前给那个地址发送 ETH。\n\n合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。\n\n### 废弃的 / 历史的攻击\n\n这些攻击由于协议的改变或固体的改进而不再可能发生。\n\n#### 调用深度攻击（废弃）\n\n在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。\n","source":"_posts/智能合约最佳实践翻译三.md","raw":"---\ntitle: 智能合约最佳实践翻译三\ncomments: false\ndate: 2018-03-09 11:17:08\ncategories: 区块链\ntags:\n- ZhouFyk\n- 以太坊\n- 智能合约\n- 安全开发\nimg:\n---\n\n## 已知攻击\n\n以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。\n\n### [竞争条件](https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology)(Race Conditions)\n\n调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。\n\n#### 重入(Reentrancy)\n\n这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call's code is executed, and can call withdrawBalance again\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。\n\n在给出的例子中，避免这个问题的最好的办法是通过 [使用 `send()` 代替 `call.value()()`](https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value)。这会防止执行中的任何外部代码。\n\n然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：\n```\nmapping(address => uint) private userBalances;\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\tuserBalances[msg.sender] = 0;\n\trequire(msg.sender.call.value(amountToWithdraw)());\n}\n```\n\n注意，如果你有另一个调用了 `withdrawBalance()`的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。\n\n#### 函数交叉竞争条件(Cross-function Race Conditions)\n\n一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。\n\n```\n// insecure\n\nmapping(address => uint) private userBalances;\n\nfunction transfer(address to, uint amount) {\n\tif (userBalances[msg.sender] >= amount) {\n\t\tuserBalance[to] += amount;\n\t\tuserBalance[msg.sender] -= amount;\n\t}\n}\n\nfunction withdrawBalance() public {\n\tuint amountToWithdraw = userBalances[msg.sender];\n\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()\n\tuserBalances[msg.sender] = 0;\n}\n```\n\n在这个例子中，当攻击者的代码在 `withdrawBalance()` 中的外部调用中被执行，攻击者会调用 `transfer()`。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。\n\n在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。\n\n#### 竞争条件解决方案中的陷阱\n\n因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。\n\n相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：\n```\n// insecure\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction withdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction getFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\trewardsForA[recipient] += 100;\n\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n\tclaimedBonus[recipient] = true;\n}\n```\n\n即使 `getFirstWithdrawalBonus()` 没有直接调用外部合约，`withdraw()` 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 `withdraw()` 函数。\n```\nmapping(address => uint) private userBalances;\nmapping(address => bool) private claimedBonus;\nmapping(address => uint) private rewardsForA;\n\nfunction untrustedWithdraw(address recipient) public {\n\tuint amountToWithdraw = userBalances[recipient];\n\trewardsForA[recipient] = 0;\n\trequire(recipient.call.value(amountToWithdraw)());\n}\n\nfunction untrustedGetFirstWithdrawalBonus(address recipient) public {\n\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n\tclaimedBonus[recipient] = true;\n\trewardsForA[recipient] += 100;\n\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible\n}\n```\n\n除了修复重入的问题，[不受信任的函数也被标记了](https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts)。这个模式在每个层级都被重复使用：既然 `untrustedGetFirstWithdrawalBonus()` 调用了调用了外部合约的 `untrustedWithdraw()`，那么你就必须将 `untrustedGetFirstWithdrawalBonus()` 视作不安全的。\n\n另一个经常建议的解决方案是一个 [互斥](https://en.wikipedia.org/wiki/Mutual_exclusion)。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：\n```\n// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\nmapping(address => uint) private balance;\nbool private lockBalances;\n\nfunction deposit() payable public returns (bool) {\n\trequire(!lockBalances);\n\tlockBalances = true;\n\tbalances[msg.sender] += msg.value;\n\tlockBalances = false;\n\treturn true;\n}\n\nfunction withdraw(uint amount) payable public returns (bool) {\n\trequire(!lockBalances && amount > 0 && balances[msg.sender] >= amount);\n\tlockBalances = true;\n\n\tif (msg.sender.call(amount)()) {\n\t\tbalances[msg.sender] -= amount;\n\t}\n\n\tlockBalances = false;\n\treturn true;\n}\n```\n\n如果用户试图在第一个调用结束前再次调用 `withdraw()`，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：\n```\n// insecure\n\ncontract StateHolder {\n\tuint private n;\n\taddress private lockHolder;\n\n\tfunction getLock() {\n\t\trequire(lockHolder == 0);\n\t\tlockHolder = msg.sender;\n\t}\n\n\tfunction releaseLock() {\n\t\trequire(msg.sender == lockHolder);\n\t\tlockHolder = 0;\n\t}\n\n\tfunction set(uint newState) {\n\t\trequire(msg.sender == lockHolder);\n\t\tn = newState;\n\t}\n}\n```\n\n一个攻击者可以调用 `getLock()`，之后就永远不用调用 `releaseLock()`。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）\n\n###### 有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\n\n### 交易顺序依赖（TOD）/ 前台运行\n\n以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。\n\n在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。\n\n### 时间戳依赖\n\n注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。\n\n有关与时间戳相关的设计注意事项，请参阅 [建议](https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence) 部分。\n\n### 整数溢出和下溢\n\n考虑一个简单的 token 转移：\n```\nmapping(address => uint256) public balanceOf;\n\n// insecure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance\n\trequire(balanceOf[msg.sender] >= _value);\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n\n// secure\nfunction transfer(address _to, uint256 _value) {\n\t// check if sender has balance and for overflows\n\trequire(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);\n\n\t// add and subtract new balances\n\tbalanceOf[msg.sender] -= _value;\n\tbalanceOf[_to] += _value;\n}\n```\n\n如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。\n\n对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。\n\n对 uint8, uint16, uint24... 等更小的数据类型要小心：它们会更容易的达到它们的最大值。\n\n注意这里有大约 [20 个关于溢出和下溢的例子](https://github.com/ethereum/solidity/issues/796#issuecomment-253578925)\n\n### （不期望的）回滚导致的 DoS\n\n考虑一个简单的拍卖合约：\n```\n// insecure\n\ncontract Auction {\n\taddress currentLeader;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value > highestBid);\n\n\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n\t\tcurrentLeader = msg.sender;\n\t\thighestBid = msg.value;;\n\t}\n}\n```\n\n当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款*总是*失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 `bid()` 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 [拉取支付系统](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls) 来替代。\n\n另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。\n\n```\naddress[] private refundAddresses;\nmapping(address => uint) public refunds;\n\n// bad\nfunction refundAll() public {\n\tfor (uint x; x < refundAddresses.length; x++) { // // arbitrary length iteration based on how many addresses participated\n\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds\n\t}\n}\n```\n\n再一次，推荐的解决方法是 [赞成拉推支付](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)。\n\n### 区块燃料限制导致的 DoS\n\n你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。\n\n即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。\n\n这是另一个 [赞成推拉支付](https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls) 的原因。\n\n如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：\n```\nstruct Payee {\n\taddress addr;\n\tuint256 value;\n}\n\nPayee[] payees;\nuint256 nextPayeeIndex;\n\nfunction payOut() {\n\tuint256 i = nextPayeeIndex;\n\twhile (i < payees.length && msg.gas > 200000) {\n\t\tpayees[i].addr.send(payees[i].value);\n\t\ti++;\n\t}\n\tnextPayeeIndex = i;\n}\n```\n\n你会需要确认在等待 `payOut()` 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。\n\n### 强制将 ETH 发送到合约\n\n可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：\n```\ncontract Vulnerable {\n\tfunction () payable {\n\t\trevert();\n\t}\n\n\tfunction somethingBad() {\n\t\trequire(this.balance > 0);\n\t\t// do something bad\n\t}\n}\n```\n\n合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。\n\n合约方法 `selfdestruct` 允许用户指定一个受益人发送多余的 ETH。`selfdestruct` [不会触发合约的 fallback 函数](https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether)。\n\n也可以[预先计算](https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo)合约的地址，然后在合约部署之前给那个地址发送 ETH。\n\n合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。\n\n### 废弃的 / 历史的攻击\n\n这些攻击由于协议的改变或固体的改进而不再可能发生。\n\n#### 调用深度攻击（废弃）\n\n在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。\n","slug":"智能合约最佳实践翻译三","published":1,"updated":"2018-03-09T03:32:41.782Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7c000ml8jxtpymxerh","content":"<h2 id=\"已知攻击\"><a href=\"#已知攻击\" class=\"headerlink\" title=\"已知攻击\"></a>已知攻击</h2><p>以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。</p>\n<h3 id=\"竞争条件-Race-Conditions\"><a href=\"#竞争条件-Race-Conditions\" class=\"headerlink\" title=\"竞争条件(Race Conditions)\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology\" target=\"_blank\" rel=\"noopener\">竞争条件</a>(Race Conditions)</h3><p>调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。</p>\n<h4 id=\"重入-Reentrancy\"><a href=\"#重入-Reentrancy\" class=\"headerlink\" title=\"重入(Reentrancy)\"></a>重入(Reentrancy)</h4><p>这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call&apos;s code is executed, and can call withdrawBalance again</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。</p>\n<p>在给出的例子中，避免这个问题的最好的办法是通过 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value\" target=\"_blank\" rel=\"noopener\">使用 <code>send()</code> 代替 <code>call.value()()</code></a>。这会防止执行中的任何外部代码。</p>\n<p>然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果你有另一个调用了 <code>withdrawBalance()</code>的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。</p>\n<h4 id=\"函数交叉竞争条件-Cross-function-Race-Conditions\"><a href=\"#函数交叉竞争条件-Cross-function-Race-Conditions\" class=\"headerlink\" title=\"函数交叉竞争条件(Cross-function Race Conditions)\"></a>函数交叉竞争条件(Cross-function Race Conditions)</h4><p>一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint amount) &#123;</span><br><span class=\"line\">\tif (userBalances[msg.sender] &gt;= amount) &#123;</span><br><span class=\"line\">\t\tuserBalance[to] += amount;</span><br><span class=\"line\">\t\tuserBalance[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller&apos;s code is executed, and can call transfer()</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，当攻击者的代码在 <code>withdrawBalance()</code> 中的外部调用中被执行，攻击者会调用 <code>transfer()</code>。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。</p>\n<p>在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。</p>\n<h4 id=\"竞争条件解决方案中的陷阱\"><a href=\"#竞争条件解决方案中的陷阱\" class=\"headerlink\" title=\"竞争条件解决方案中的陷阱\"></a>竞争条件解决方案中的陷阱</h4><p>因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。</p>\n<p>相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.</span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使 <code>getFirstWithdrawalBonus()</code> 没有直接调用外部合约，<code>withdraw()</code> 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 <code>withdraw()</code> 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedWithdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedGetFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了修复重入的问题，<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts\" target=\"_blank\" rel=\"noopener\">不受信任的函数也被标记了</a>。这个模式在每个层级都被重复使用：既然 <code>untrustedGetFirstWithdrawalBonus()</code> 调用了调用了外部合约的 <code>untrustedWithdraw()</code>，那么你就必须将 <code>untrustedGetFirstWithdrawalBonus()</code> 视作不安全的。</p>\n<p>另一个经常建议的解决方案是一个 <a href=\"https://en.wikipedia.org/wiki/Mutual_exclusion\" target=\"_blank\" rel=\"noopener\">互斥</a>。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state</span><br><span class=\"line\">mapping(address =&gt; uint) private balance;</span><br><span class=\"line\">bool private lockBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\">\tbalances[msg.sender] += msg.value;</span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(uint amount) payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (msg.sender.call(amount)()) &#123;</span><br><span class=\"line\">\t\tbalances[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户试图在第一个调用结束前再次调用 <code>withdraw()</code>，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract StateHolder &#123;</span><br><span class=\"line\">\tuint private n;</span><br><span class=\"line\">\taddress private lockHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction getLock() &#123;</span><br><span class=\"line\">\t\trequire(lockHolder == 0);</span><br><span class=\"line\">\t\tlockHolder = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releaseLock() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tlockHolder = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction set(uint newState) &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tn = newState;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个攻击者可以调用 <code>getLock()</code>，之后就永远不用调用 <code>releaseLock()</code>。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）</p>\n<h6 id=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"><a href=\"#有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\" class=\"headerlink\" title=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"></a>有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。</h6><h3 id=\"交易顺序依赖（TOD）-前台运行\"><a href=\"#交易顺序依赖（TOD）-前台运行\" class=\"headerlink\" title=\"交易顺序依赖（TOD）/ 前台运行\"></a>交易顺序依赖（TOD）/ 前台运行</h3><p>以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。</p>\n<p>在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。</p>\n<p>有关与时间戳相关的设计注意事项，请参阅 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence\" target=\"_blank\" rel=\"noopener\">建议</a> 部分。</p>\n<h3 id=\"整数溢出和下溢\"><a href=\"#整数溢出和下溢\" class=\"headerlink\" title=\"整数溢出和下溢\"></a>整数溢出和下溢</h3><p>考虑一个简单的 token 转移：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint256) public balanceOf;</span><br><span class=\"line\"></span><br><span class=\"line\">// insecure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value);</span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// secure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance and for overflows</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。</p>\n<p>对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。</p>\n<p>对 uint8, uint16, uint24… 等更小的数据类型要小心：它们会更容易的达到它们的最大值。</p>\n<p>注意这里有大约 <a href=\"https://github.com/ethereum/solidity/issues/796#issuecomment-253578925\" target=\"_blank\" rel=\"noopener\">20 个关于溢出和下溢的例子</a></p>\n<h3 id=\"（不期望的）回滚导致的-DoS\"><a href=\"#（不期望的）回滚导致的-DoS\" class=\"headerlink\" title=\"（不期望的）回滚导致的 DoS\"></a>（不期望的）回滚导致的 DoS</h3><p>考虑一个简单的拍卖合约：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract Auction &#123;</span><br><span class=\"line\">\taddress currentLeader;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt; highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcurrentLeader = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款<em>总是</em>失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 <code>bid()</code> 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">拉取支付系统</a> 来替代。</p>\n<p>另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address[] private refundAddresses;</span><br><span class=\"line\">mapping(address =&gt; uint) public refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">// bad</span><br><span class=\"line\">function refundAll() public &#123;</span><br><span class=\"line\">\tfor (uint x; x &lt; refundAddresses.length; x++) &#123; // // arbitrary length iteration based on how many addresses participated</span><br><span class=\"line\">\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再一次，推荐的解决方法是 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成拉推支付</a>。</p>\n<h3 id=\"区块燃料限制导致的-DoS\"><a href=\"#区块燃料限制导致的-DoS\" class=\"headerlink\" title=\"区块燃料限制导致的 DoS\"></a>区块燃料限制导致的 DoS</h3><p>你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。</p>\n<p>即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。</p>\n<p>这是另一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成推拉支付</a> 的原因。</p>\n<p>如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Payee &#123;</span><br><span class=\"line\">\taddress addr;</span><br><span class=\"line\">\tuint256 value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Payee[] payees;</span><br><span class=\"line\">uint256 nextPayeeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">function payOut() &#123;</span><br><span class=\"line\">\tuint256 i = nextPayeeIndex;</span><br><span class=\"line\">\twhile (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) &#123;</span><br><span class=\"line\">\t\tpayees[i].addr.send(payees[i].value);</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnextPayeeIndex = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你会需要确认在等待 <code>payOut()</code> 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。</p>\n<h3 id=\"强制将-ETH-发送到合约\"><a href=\"#强制将-ETH-发送到合约\" class=\"headerlink\" title=\"强制将 ETH 发送到合约\"></a>强制将 ETH 发送到合约</h3><p>可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Vulnerable &#123;</span><br><span class=\"line\">\tfunction () payable &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction somethingBad() &#123;</span><br><span class=\"line\">\t\trequire(this.balance &gt; 0);</span><br><span class=\"line\">\t\t// do something bad</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。</p>\n<p>合约方法 <code>selfdestruct</code> 允许用户指定一个受益人发送多余的 ETH。<code>selfdestruct</code> <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether\" target=\"_blank\" rel=\"noopener\">不会触发合约的 fallback 函数</a>。</p>\n<p>也可以<a href=\"https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo\" target=\"_blank\" rel=\"noopener\">预先计算</a>合约的地址，然后在合约部署之前给那个地址发送 ETH。</p>\n<p>合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。</p>\n<h3 id=\"废弃的-历史的攻击\"><a href=\"#废弃的-历史的攻击\" class=\"headerlink\" title=\"废弃的 / 历史的攻击\"></a>废弃的 / 历史的攻击</h3><p>这些攻击由于协议的改变或固体的改进而不再可能发生。</p>\n<h4 id=\"调用深度攻击（废弃）\"><a href=\"#调用深度攻击（废弃）\" class=\"headerlink\" title=\"调用深度攻击（废弃）\"></a>调用深度攻击（废弃）</h4><p>在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"已知攻击\"><a href=\"#已知攻击\" class=\"headerlink\" title=\"已知攻击\"></a>已知攻击</h2><p>以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。</p>\n<h3 id=\"竞争条件-Race-Conditions\"><a href=\"#竞争条件-Race-Conditions\" class=\"headerlink\" title=\"竞争条件(Race Conditions)\"></a><a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology\" target=\"_blank\" rel=\"noopener\">竞争条件</a>(Race Conditions)</h3><p>调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。</p>\n<h4 id=\"重入-Reentrancy\"><a href=\"#重入-Reentrancy\" class=\"headerlink\" title=\"重入(Reentrancy)\"></a>重入(Reentrancy)</h4><p>这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the call&apos;s code is executed, and can call withdrawBalance again</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。</p>\n<p>在给出的例子中，避免这个问题的最好的办法是通过 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value\" target=\"_blank\" rel=\"noopener\">使用 <code>send()</code> 代替 <code>call.value()()</code></a>。这会防止执行中的任何外部代码。</p>\n<p>然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，如果你有另一个调用了 <code>withdrawBalance()</code>的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。</p>\n<h4 id=\"函数交叉竞争条件-Cross-function-Race-Conditions\"><a href=\"#函数交叉竞争条件-Cross-function-Race-Conditions\" class=\"headerlink\" title=\"函数交叉竞争条件(Cross-function Race Conditions)\"></a>函数交叉竞争条件(Cross-function Race Conditions)</h4><p>一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function transfer(address to, uint amount) &#123;</span><br><span class=\"line\">\tif (userBalances[msg.sender] &gt;= amount) &#123;</span><br><span class=\"line\">\t\tuserBalance[to] += amount;</span><br><span class=\"line\">\t\tuserBalance[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdrawBalance() public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[msg.sender];</span><br><span class=\"line\">\trequire(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller&apos;s code is executed, and can call transfer()</span><br><span class=\"line\">\tuserBalances[msg.sender] = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，当攻击者的代码在 <code>withdrawBalance()</code> 中的外部调用中被执行，攻击者会调用 <code>transfer()</code>。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。这个漏洞也在 DAO 攻击中被使用。</p>\n<p>在相同的警告下，相同的解决方案也会起作用。也要注意，在这个例子中，函数都是同一个合约的一部分。但是，如果多个合约共享状态，那么相同的 bug 也可以出现在交叉的多重合约中。</p>\n<h4 id=\"竞争条件解决方案中的陷阱\"><a href=\"#竞争条件解决方案中的陷阱\" class=\"headerlink\" title=\"竞争条件解决方案中的陷阱\"></a>竞争条件解决方案中的陷阱</h4><p>因为竞争条件可以在多个函数，甚至多个合约中发生，所以任何旨在防止重入的解决方案都是不够的。</p>\n<p>相反，我们推荐在完成全部的内部工作之后再调用外部函数。如果你小心地遵循了这个规则，就可以避免竞争条件。但是，你不止要避免太早调用外部函数，也要避免调用了外部函数的函数。举例来说，下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\twithdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.</span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使 <code>getFirstWithdrawalBonus()</code> 没有直接调用外部合约，<code>withdraw()</code> 内的调用已经足够产生一个竞争条件的漏洞。因此你不可以信任 <code>withdraw()</code> 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint) private userBalances;</span><br><span class=\"line\">mapping(address =&gt; bool) private claimedBonus;</span><br><span class=\"line\">mapping(address =&gt; uint) private rewardsForA;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedWithdraw(address recipient) public &#123;</span><br><span class=\"line\">\tuint amountToWithdraw = userBalances[recipient];</span><br><span class=\"line\">\trewardsForA[recipient] = 0;</span><br><span class=\"line\">\trequire(recipient.call.value(amountToWithdraw)());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function untrustedGetFirstWithdrawalBonus(address recipient) public &#123;</span><br><span class=\"line\">\trequire(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once</span><br><span class=\"line\"></span><br><span class=\"line\">\tclaimedBonus[recipient] = true;</span><br><span class=\"line\">\trewardsForA[recipient] += 100;</span><br><span class=\"line\">\tuntrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了修复重入的问题，<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#mark-untrusted-contracts\" target=\"_blank\" rel=\"noopener\">不受信任的函数也被标记了</a>。这个模式在每个层级都被重复使用：既然 <code>untrustedGetFirstWithdrawalBonus()</code> 调用了调用了外部合约的 <code>untrustedWithdraw()</code>，那么你就必须将 <code>untrustedGetFirstWithdrawalBonus()</code> 视作不安全的。</p>\n<p>另一个经常建议的解决方案是一个 <a href=\"https://en.wikipedia.org/wiki/Mutual_exclusion\" target=\"_blank\" rel=\"noopener\">互斥</a>。它允许你 “锁定” 某些状态，所以状态只能被锁的拥有者改变。一个简单的例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state</span><br><span class=\"line\">mapping(address =&gt; uint) private balance;</span><br><span class=\"line\">bool private lockBalances;</span><br><span class=\"line\"></span><br><span class=\"line\">function deposit() payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\">\tbalances[msg.sender] += msg.value;</span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function withdraw(uint amount) payable public returns (bool) &#123;</span><br><span class=\"line\">\trequire(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class=\"line\">\tlockBalances = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (msg.sender.call(amount)()) &#123;</span><br><span class=\"line\">\t\tbalances[msg.sender] -= amount;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlockBalances = false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户试图在第一个调用结束前再次调用 <code>withdraw()</code>，锁就会防止其作用。这是一个有用的方式，但是当你有多个合约合作的时候，就会有一些困难。下面是不安全的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract StateHolder &#123;</span><br><span class=\"line\">\tuint private n;</span><br><span class=\"line\">\taddress private lockHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction getLock() &#123;</span><br><span class=\"line\">\t\trequire(lockHolder == 0);</span><br><span class=\"line\">\t\tlockHolder = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction releaseLock() &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tlockHolder = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction set(uint newState) &#123;</span><br><span class=\"line\">\t\trequire(msg.sender == lockHolder);</span><br><span class=\"line\">\t\tn = newState;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个攻击者可以调用 <code>getLock()</code>，之后就永远不用调用 <code>releaseLock()</code>。如果他们这么干了，那么合约将被永远锁定，无法进行任何修改。如果你使用互斥来防止竞争条件，那么你需要小心地确认不会出现只能锁定而不能释放的情况。（使用互斥编程也有其他潜在的危险，如死锁和活锁。如果你想要使用这种方式，你应该查阅咨询大量互斥相关的文献资料。）</p>\n<h6 id=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"><a href=\"#有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。-然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\" class=\"headerlink\" title=\"有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。\"></a>有些人可能会反对使用术语竞争条件，因为以太坊目前没有真正的并行性。 然而，逻辑上不同的进程争夺资源的基本特征仍然存在，同样的陷阱和潜在的解决方案也适用。</h6><h3 id=\"交易顺序依赖（TOD）-前台运行\"><a href=\"#交易顺序依赖（TOD）-前台运行\" class=\"headerlink\" title=\"交易顺序依赖（TOD）/ 前台运行\"></a>交易顺序依赖（TOD）/ 前台运行</h3><p>以上的竞争条件示例涉及到攻击者在单笔交易中执行恶意代码。以下是区块链固有的一种不同类型的竞争条件：交易本身（在区块内）的顺序容易受到操纵。</p>\n<p>在被打包进区块之前，交易会进入内存池一段时间，因此可以知道交易在被打包之前有什么行为。对于像去中心化市场这类对象来说，这可能会有些麻烦，在这种市场中，可能看到买入 token 的交易，和其他交易被包含之前的市场顺序实现形式。防止这种情况很困难，因为它会涉及到具体合约本身。举例来说，在市场中，实施批量拍卖会更好（这也可以防止高频交易问题）。另一种方法是使用预先提交方案（“我将在稍后提交细节”）。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>注意区块的时间戳可以被矿工操作，所以在不管是直接还是间接的对时间戳的使用中要多加考虑。</p>\n<p>有关与时间戳相关的设计注意事项，请参阅 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence\" target=\"_blank\" rel=\"noopener\">建议</a> 部分。</p>\n<h3 id=\"整数溢出和下溢\"><a href=\"#整数溢出和下溢\" class=\"headerlink\" title=\"整数溢出和下溢\"></a>整数溢出和下溢</h3><p>考虑一个简单的 token 转移：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapping(address =&gt; uint256) public balanceOf;</span><br><span class=\"line\"></span><br><span class=\"line\">// insecure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value);</span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// secure</span><br><span class=\"line\">function transfer(address _to, uint256 _value) &#123;</span><br><span class=\"line\">\t// check if sender has balance and for overflows</span><br><span class=\"line\">\trequire(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add and subtract new balances</span><br><span class=\"line\">\tbalanceOf[msg.sender] -= _value;</span><br><span class=\"line\">\tbalanceOf[_to] += _value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果余额到达了 uint 值（2^256）的最大值，它会被置为零。这是检查这个条件。这可能有关也可能无关，取决于实现方式。考虑一下 uint 值是否有这个机会达到这么大的一个数字。考虑 uint 变量是如何改变状态的，并且谁有权限来做这样的改变。如果任意用户都可以更新 uint 值，那么就会有很多的攻击漏洞。如果只有一个管理者拥有权限来修改变量的状态，那你可能是安全的。如果一个用户每次尽能增加 1，那你也可能是安全的，因为并没有可行的方式来达到限制。</p>\n<p>对于下溢来说也是一样的。如果一个 uint 被设置成小于 0，这就会导致一个下溢然后被设置成它的最大值。</p>\n<p>对 uint8, uint16, uint24… 等更小的数据类型要小心：它们会更容易的达到它们的最大值。</p>\n<p>注意这里有大约 <a href=\"https://github.com/ethereum/solidity/issues/796#issuecomment-253578925\" target=\"_blank\" rel=\"noopener\">20 个关于溢出和下溢的例子</a></p>\n<h3 id=\"（不期望的）回滚导致的-DoS\"><a href=\"#（不期望的）回滚导致的-DoS\" class=\"headerlink\" title=\"（不期望的）回滚导致的 DoS\"></a>（不期望的）回滚导致的 DoS</h3><p>考虑一个简单的拍卖合约：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// insecure</span><br><span class=\"line\"></span><br><span class=\"line\">contract Auction &#123;</span><br><span class=\"line\">\taddress currentLeader;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt; highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trequire(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcurrentLeader = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当它试图退款给用户的时候，当退款失败，它会回滚。意思是一个恶意的竞标者可以通过让它们的退款<em>总是</em>失败而变成领导者。在这个方式中，它们可以防止其他任何人调用 <code>bid()</code> 函数，然后保证自己一直都是领导者。一个推荐是如之前所述，设置一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">拉取支付系统</a> 来替代。</p>\n<p>另一个例子是当一个合约想要通过便利一个数组来支付给用户（如，在众筹合约中的支持者）。通常都想要确保每一笔支付都成功。如果没有的话，就回滚。这个问题是如果一个调用失败了，你就会回滚整个支付系统，那么循环将永远不会完成。因为一个地址强制错误所以没有人获得报酬。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address[] private refundAddresses;</span><br><span class=\"line\">mapping(address =&gt; uint) public refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">// bad</span><br><span class=\"line\">function refundAll() public &#123;</span><br><span class=\"line\">\tfor (uint x; x &lt; refundAddresses.length; x++) &#123; // // arbitrary length iteration based on how many addresses participated</span><br><span class=\"line\">\t\trequire(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再一次，推荐的解决方法是 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成拉推支付</a>。</p>\n<h3 id=\"区块燃料限制导致的-DoS\"><a href=\"#区块燃料限制导致的-DoS\" class=\"headerlink\" title=\"区块燃料限制导致的 DoS\"></a>区块燃料限制导致的 DoS</h3><p>你可能注意到了之前的例子中的另一个问题：一次性支付给所有人，你会有触及区块燃料限制的风险。每一个以太坊区块都能处理一个确定的最大算力值。如果你想要超过它，那你的交易就会失败。</p>\n<p>即使没有故意的攻击，这也会造成问题。但是，如果攻击者可以操纵所需的燃料值，就会特别糟糕。在之前的例子中，攻击者可以添加大量地址，每一个都需要获得极销量的退款。攻击者的每一个地址退款操作的燃气消耗最终可能超过燃料限制，从而阻止退款交易的发生。</p>\n<p>这是另一个 <a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations#favor-pull-over-push-for-external-calls\" target=\"_blank\" rel=\"noopener\">赞成推拉支付</a> 的原因。</p>\n<p>如果你必须完全遍历一个你不知道大小的数组，那么你应该计划它可能需要多个区块，因而需要多个交易。你会需要对你当前的进度保持跟踪，并且能够从那个点恢复，就像下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Payee &#123;</span><br><span class=\"line\">\taddress addr;</span><br><span class=\"line\">\tuint256 value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Payee[] payees;</span><br><span class=\"line\">uint256 nextPayeeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">function payOut() &#123;</span><br><span class=\"line\">\tuint256 i = nextPayeeIndex;</span><br><span class=\"line\">\twhile (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) &#123;</span><br><span class=\"line\">\t\tpayees[i].addr.send(payees[i].value);</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnextPayeeIndex = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你会需要确认在等待 <code>payOut()</code> 函数的下一个遍历的时候，如果其他交易被处理，不会有不好的事情发生。所以只在完全必要的时候使用这个模式。</p>\n<h3 id=\"强制将-ETH-发送到合约\"><a href=\"#强制将-ETH-发送到合约\" class=\"headerlink\" title=\"强制将 ETH 发送到合约\"></a>强制将 ETH 发送到合约</h3><p>可以不通过触发合约的 fallback 函数来强行将 ETH 发送到合约。当 fallback 函数内有重要的逻辑或者进行了基于合约余额的计算时，这是一个很重要的考虑。见下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Vulnerable &#123;</span><br><span class=\"line\">\tfunction () payable &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction somethingBad() &#123;</span><br><span class=\"line\">\t\trequire(this.balance &gt; 0);</span><br><span class=\"line\">\t\t// do something bad</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>合约逻辑看起来并不允许合约被支付，因此也不允许 “一些坏事” 发生。但是，存在一些强制发送 ETH 给合约的方法，因此它的余额大于 0。</p>\n<p>合约方法 <code>selfdestruct</code> 允许用户指定一个受益人发送多余的 ETH。<code>selfdestruct</code> <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether\" target=\"_blank\" rel=\"noopener\">不会触发合约的 fallback 函数</a>。</p>\n<p>也可以<a href=\"https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo\" target=\"_blank\" rel=\"noopener\">预先计算</a>合约的地址，然后在合约部署之前给那个地址发送 ETH。</p>\n<p>合约开发者应该注意 ETH 可以被强制发送给合约并且应该设计相应的合约逻辑。通常来说，假设不可能限制你的合约的资金来源。</p>\n<h3 id=\"废弃的-历史的攻击\"><a href=\"#废弃的-历史的攻击\" class=\"headerlink\" title=\"废弃的 / 历史的攻击\"></a>废弃的 / 历史的攻击</h3><p>这些攻击由于协议的改变或固体的改进而不再可能发生。</p>\n<h4 id=\"调用深度攻击（废弃）\"><a href=\"#调用深度攻击（废弃）\" class=\"headerlink\" title=\"调用深度攻击（废弃）\"></a>调用深度攻击（废弃）</h4><p>在 EIP 150 的硬分叉中，调用深度攻击不再相关*（在达到 1024 调用深度限制之前，所有气体都将消耗得很好）。</p>\n"},{"title":"智能合约最佳实践翻译二","comments":0,"date":"2018-03-02T09:04:23.000Z","img":null,"_content":"\n[原文链接](https://consensys.github.io/smart-contract-best-practices/recommendations/)\n\n## 对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\n\n本页面展示了编写智能合约时应遵循的一些 solidity 模式。\n\n### 协议具体建议\n\n以下建议适用于以太坊中所有的智能合约的开发。\n\n### 外部调用\n\n#### 小心使用外部调用\n\n调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险\n\n#### 标记不受信任的合约\n\n当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。\n\n```\n// bad\nBank.withdraw(100); // Unclear whether trusted or untrusted\n\n// Isn't clear that this function is potentially unsafe\nfunction makeWithdrawal(uint amount)  {\n\t\tBank.withdraw(amount);\n}\n\n// good\nUntrustedBank.withdraw(100);\nTrustedBank.withdraw(100);\n\nfunction makeUntrustedWithdrawal(uint amount) {\n\t\tUntrustedBank.withdraw(amount);\n}\n```\n\n#### 避免在外部调用之后改变状态\n\n不论是否使用 `raw calls`（`someAddress,call()` 的格式） 或者 `contract calls`（`ExternalContract.someMethod()` 的格式），都假定会执行恶意代码。即使 `ExternalContract` 不是恶意的，但它调用的任何合约也可能会执行恶意代码。\n\n一个特殊的危险是，恶意代码可能对控制流进行了 `hijack` 攻击，导致条件竞争。（见 [Race Conditions](https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions) 了解更多关于这个问题的讨论）。\n\n如果你调用了一个不受信任的外部合约，*避免在调用之后改变状态*。这个模式也常常作为 [check-effects-interactions 模式](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) 为人们所知。\n\n#### 注意 `send() / transfer() / call.value()` 之间的平衡\n\n在发送 ether 时注意 `someAddress.send() / someAddress.transfer() / someAddress.call.value()()` 之间的使用的关系的平衡。\n\n* `someAddress.send()` 和 `someAddress.transfer()` 被认为对于[重入](https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy)是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。\n* `x.transfer(y)` 和 `require(x.send(y));` 的等同的，如果发送失败，它会自动回退。\n* `someAddress.call.value(y)()` 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。\n\n使用 `send()` 和 `transfer()` 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 `someAddress.vall.value(ethAmount).gas(gasAmount)()` 来转发指定的燃料数量。\n\n一个试图平衡这个问题的解决办法是实现 *[退和拉](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments)* 的机制模式， *推送* 部分使用 `send()` 或者 `transfer()` ，*拉* 部分使用 `call.value()` 。\n\n值得指出的是，对于价值转移而言，专用 `send()` 或者 `transfer()` 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。\n\n#### 解决外部调用的错误\n\nSolidity 提供了处理原生地址的底层调用方法：`address.call()`，`address.callcode()`，`address,delegatecall()`，和 `address.send()`。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 `false`。从另一方面来说，*合约调用*（如 `ExternalContract.doSomething()`）会自动传播一个异常（比如，如果 `doSomething()` 抛出异常，`ExternalContract.doSomething()` 也会 `throw`）。\n\n如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。\n\n```\n// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\nsomeAddress.call.value(100)(bytes4(sha3(\"deposit()\"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif (!someAddress.send(55)) {\n\t\t// some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);\n```\n\n#### 对外部调用来说，拉比推更好\n\n外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了[燃料限制问题](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit)。）避免在单个交易中组合多个 `send()` \n\n```\n// bad\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid \n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n}\n\n// good\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\tmapping(address => uint) refunds;\n\n\tfunction bid() payable external {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim\n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n\n\tfunction withdrawRefund() external {\n\t\tuint refund = refunds[msg.sender];\n\t\trefunds[msg.sender] = 0;\n\t\tmsg.sender.transfer(refund);\n\t}\n}\n```\n\n#### 不要假设合约创建时是 0 资产\n\n一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 [问题 61](https://github.com/ConsenSys/smart-contract-best-practices/issues/61) 查看更多细节。\n\n#### 记住链上的数据是公开的\n\n许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。\n\n示例：\n* 在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。\n* 在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。\n* 当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 [http://btcrelay.org](http://btcrelay.org) 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 [RANDAO](https://github.com/randao/randao)\n* 如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。\n\n### 注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\n\n不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。\n\n### Solidity 详细建议\n\n下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。\n\n### 强制对不变值使用 `assert()`\n\n当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 `assert()` 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）\n\n例子：\n\n```\ncontract Token {\n\tmapping (address => uint) public balanceOf;\n\tuint public totalSupply;\n\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\ttotalSupply += msg.value;\n\t\tassert(this.balance >= totalSupply);\n\t}\n}\n```\n\n注意断言并非对资产严格相等，因为合约可以不通过 `deposit` 函数强制[发送以太币](https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent)\n\n### 正确地使用 `assert()` 和 `require()`\n\n在 Solidity 0.4.10 中，引入了 `assert()` 和 `require()`。`require(condition)` 被用来对用户的任何输入进行验证，如果条件不成立则回滚。`assert(condition)` 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。\n\n### 小心整数除法\n\n所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。\n\n（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）\n\n```\n// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n```\n\n使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：\n\n```\n// good\nuint multiplier = 10;\nuint x = (5 * multipler) / 2;\n```\n\n存储分子和分母意味着你可以离链计算分子除以分母的结果。\n\n```\n// good\nuint numerator = 5;\nuint denominator = 2;\n```\n\n### 记住以太币可以被强制发送到一个账户\n\n注意对严格检查了的合约的余额进行编码。\n\n一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 `revert()` 的 fallback 函数也不可以）\n\n攻击者通过创余额为 1 wei 的合约，然后通过 `selfdestruct(victimAddress)` 的方式达到目的。`victimAddress` 中没有代码被激活，所以这不能被阻止。\n\n### 注意抽象合约和接口的平衡\n\n接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。\n\n### 保持 fallback 函数简单\n\n当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，[Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function) 会被调用，而且如果通过 `.send()` 或者 `.transfer()` 调用的话只需要 2300 单位的燃料。如果你希望能够从 `.send()` 或者 `.transfer()` 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。\n\n```\n// bad\nfunciton() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { LogDepositReceived(msg.sender); }\n```\n\n### 为函数和状态变量显式标记可见性\n\n显式标记函数和状态变量的可见性。函数可以被指定为 `external / public / internal / private`。请理解它们之间的区别，比如，比起 `public`，`external` 可能已经足够使用了。对于状态变量来说，`external` 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 \n\n```\n// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public \n\t\t// public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n\t\t// only callable external\n}\n\nfunction utility() public {\n\t\t// callable externally, as well as internally: changing this code requires thinking about both cases\n}\n\nfunction internalAction() internal {\n\t\t// internal code\n}\n```\n\n### 锁定指定编译器版本的编译指示\n\n应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。\n\n```\n// bad \npragma solidity ^0.4.4;\n\n// good\npragma solidity 0.4.0;\n```\n\n#### 异常\n\n当合约打算供其他开发人员使用时，可以允许 `pragma` 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。\n\n### 函数和事件的区别\n\n对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。\n\n```\n// bad \nevent Transfer() {}\nfunction transfer() {}\n\n// good\nevent LogTransfer() {}\nfunction transfer() external {}\n```\n\n### 推荐使用更新的 Solidity 结构\n\n使用构造/别名如 `selfdestruct` （而不是 `suicide`），和 `keccak256` （而不是 `sha3`）。`require(msg.sender.send(1 ether))` 也可以使用 `transfer()` 简单地实现： `msg.sender.transfer(1 ether)`。\n\n### 注意内置函数可以被覆盖\n\n目前可以在 Solidity 覆盖（[shadow](https://en.wikipedia.org/wiki/Variable_shadowing)）内置的全局变量。它允许合约重写覆盖内置的方法，如 `msg` 和 `revert()`。尽管这是[故意](https://github.com/ethereum/solidity/issues/1249)的，但是它可能会在关于合约的真实行为上误导合约的用户。\n\n```\ncontract PretendingToRevert {\n\tfunction revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n\tfunction somethingBad() public {\n\t\trevert();\n\t}\n}\n```\n\n合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。\n\n### 避免使用 `tx.origin`\n\n永远不要使用 `tx.origin` 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 `tx.origin` 里面，你的合约就会授权该交易。\n\n```\npragma solidity ^0.4.18;\n\ncontract MyContract {\n\taddress owner;\n\n\tfunction MyContract() public {\n\t\towner = msg.sender;\n\t}\n\n\tfunction sendTo(address receiver, uint amount) public {\n\t\trequire(tx.origin == owner);\n\t\treceiver.transfer(amount);\n\t}\n}\n\ncontract AttackingContract {\n\tMyContract myContract;\n\taddress attacker;\n\n\tfunction AttackingContract(address myContractAddress) public {\n\t\tmyContract = MyContract(myContractAddress);\n\t\tattacker = msg.sender;\n\t}\n\n\tfunction() public {\n\t\tmyContract.sendTo(attacker, msg.sender.balance);\n\t}\n}\n```\n\n你应该使用 `msg.sender` 来授权（如果有另一个合约调用了你的合约，`msg.sender` 会成为合约的地址，而且不是调用合约的人的地址）。\n\n更多可见 [Solidity 文档](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n\n除了授权的这个问题，`tx.origin` 可能在将来从以太坊协议中移除，所以使用了 `tx.origin` 的代码在将来不会再被兼容 [Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'](https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200)\n\n另外值得一提的是，通过使用 `tx.origin`，你会限制合同之间的互操作性，因为使用 `tx.origin` 的合同不能被另一个合同使用，因为合同不能是 `tx.origin`。\n\n### 时间戳依赖\n\n在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。\n\n#### Gameability\n\n注意区块的时间戳是可用被矿工操作的。考虑这个[合约](https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code)：\n\n```\nuint256 constant private salt = block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result) {\n\t//get the best seed for randomness\n\tuint256 x = salt * 100/Max;\n\tuint256 y = salt * block.number/(salt % 5);\n\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n\tuint256 h = uint256(block.blockhash(seed));\n\n\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max\n}\n```\n\n当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。\n\n#### 30 秒规则\n\n评估时间戳使用的一般经验法则是：\n\n**如果合约功能可以容忍30秒的时间漂移，则可以安全使用 `block.timestamp`**\n\n如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。\n\n#### 将 `block.number` 作为时间戳使用时要当心\n\n当合约创建一个 `auction_complete` 修饰器来表示代币销售的结束，像[这样](https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol))\n\n```\nmodifier auction_complete {\n\trequire(auctionEndBlock <= block.number ||\n\t\tcurrentAuctionState == AuctionState.success ||\n\t\tcurrentAuctionState == AuctionState.cancel)\n\t\t_;\n}\n```\n\n`block.number` 和 [平均出块时间](https://etherscan.io/chart/blocktime) 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 [分叉重组](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/) 和 [难度炸弹](https://github.com/ethereum/EIPs/issues/649)）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。\n\n### 弃用/历史 建议\n\n由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.\n\n#### 注意被 0 除 （Solidity < 0.4）\n\n在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。\n","source":"_posts/智能合约最佳实践翻译二.md","raw":"---\ntitle: 智能合约最佳实践翻译二\ncomments: false\ndate: 2018-03-02 17:04:23\ncategories: 区块链\ntags: \n- ZhouFyk \n- 以太坊 \n- 智能合约 \n- 安全开发\nimg:\n---\n\n[原文链接](https://consensys.github.io/smart-contract-best-practices/recommendations/)\n\n## 对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\n\n本页面展示了编写智能合约时应遵循的一些 solidity 模式。\n\n### 协议具体建议\n\n以下建议适用于以太坊中所有的智能合约的开发。\n\n### 外部调用\n\n#### 小心使用外部调用\n\n调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险\n\n#### 标记不受信任的合约\n\n当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。\n\n```\n// bad\nBank.withdraw(100); // Unclear whether trusted or untrusted\n\n// Isn't clear that this function is potentially unsafe\nfunction makeWithdrawal(uint amount)  {\n\t\tBank.withdraw(amount);\n}\n\n// good\nUntrustedBank.withdraw(100);\nTrustedBank.withdraw(100);\n\nfunction makeUntrustedWithdrawal(uint amount) {\n\t\tUntrustedBank.withdraw(amount);\n}\n```\n\n#### 避免在外部调用之后改变状态\n\n不论是否使用 `raw calls`（`someAddress,call()` 的格式） 或者 `contract calls`（`ExternalContract.someMethod()` 的格式），都假定会执行恶意代码。即使 `ExternalContract` 不是恶意的，但它调用的任何合约也可能会执行恶意代码。\n\n一个特殊的危险是，恶意代码可能对控制流进行了 `hijack` 攻击，导致条件竞争。（见 [Race Conditions](https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions) 了解更多关于这个问题的讨论）。\n\n如果你调用了一个不受信任的外部合约，*避免在调用之后改变状态*。这个模式也常常作为 [check-effects-interactions 模式](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) 为人们所知。\n\n#### 注意 `send() / transfer() / call.value()` 之间的平衡\n\n在发送 ether 时注意 `someAddress.send() / someAddress.transfer() / someAddress.call.value()()` 之间的使用的关系的平衡。\n\n* `someAddress.send()` 和 `someAddress.transfer()` 被认为对于[重入](https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy)是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。\n* `x.transfer(y)` 和 `require(x.send(y));` 的等同的，如果发送失败，它会自动回退。\n* `someAddress.call.value(y)()` 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。\n\n使用 `send()` 和 `transfer()` 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 `someAddress.vall.value(ethAmount).gas(gasAmount)()` 来转发指定的燃料数量。\n\n一个试图平衡这个问题的解决办法是实现 *[退和拉](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments)* 的机制模式， *推送* 部分使用 `send()` 或者 `transfer()` ，*拉* 部分使用 `call.value()` 。\n\n值得指出的是，对于价值转移而言，专用 `send()` 或者 `transfer()` 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。\n\n#### 解决外部调用的错误\n\nSolidity 提供了处理原生地址的底层调用方法：`address.call()`，`address.callcode()`，`address,delegatecall()`，和 `address.send()`。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 `false`。从另一方面来说，*合约调用*（如 `ExternalContract.doSomething()`）会自动传播一个异常（比如，如果 `doSomething()` 抛出异常，`ExternalContract.doSomething()` 也会 `throw`）。\n\n如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。\n\n```\n// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\nsomeAddress.call.value(100)(bytes4(sha3(\"deposit()\"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\nif (!someAddress.send(55)) {\n\t\t// some failure code\n}\n\nExternalContract(someAddress).deposit.value(100);\n```\n\n#### 对外部调用来说，拉比推更好\n\n外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了[燃料限制问题](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit)。）避免在单个交易中组合多个 `send()` \n\n```\n// bad\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\n\tfunction bid() payable {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid \n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n}\n\n// good\ncontract auction {\n\taddress highestBidder;\n\tuint highestBid;\n\tmapping(address => uint) refunds;\n\n\tfunction bid() payable external {\n\t\trequire(msg.value >= highestBid);\n\n\t\tif (highestBidder != 0) {\n\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim\n\t\t}\n\n\t\thighestBidder = msg.sender;\n\t\thighestBid = msg.value;\n\t}\n\n\tfunction withdrawRefund() external {\n\t\tuint refund = refunds[msg.sender];\n\t\trefunds[msg.sender] = 0;\n\t\tmsg.sender.transfer(refund);\n\t}\n}\n```\n\n#### 不要假设合约创建时是 0 资产\n\n一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 [问题 61](https://github.com/ConsenSys/smart-contract-best-practices/issues/61) 查看更多细节。\n\n#### 记住链上的数据是公开的\n\n许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。\n\n示例：\n* 在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。\n* 在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。\n* 当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 [http://btcrelay.org](http://btcrelay.org) 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 [RANDAO](https://github.com/randao/randao)\n* 如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。\n\n### 注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\n\n不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。\n\n### Solidity 详细建议\n\n下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。\n\n### 强制对不变值使用 `assert()`\n\n当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 `assert()` 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）\n\n例子：\n\n```\ncontract Token {\n\tmapping (address => uint) public balanceOf;\n\tuint public totalSupply;\n\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\ttotalSupply += msg.value;\n\t\tassert(this.balance >= totalSupply);\n\t}\n}\n```\n\n注意断言并非对资产严格相等，因为合约可以不通过 `deposit` 函数强制[发送以太币](https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent)\n\n### 正确地使用 `assert()` 和 `require()`\n\n在 Solidity 0.4.10 中，引入了 `assert()` 和 `require()`。`require(condition)` 被用来对用户的任何输入进行验证，如果条件不成立则回滚。`assert(condition)` 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。\n\n### 小心整数除法\n\n所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。\n\n（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）\n\n```\n// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n```\n\n使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：\n\n```\n// good\nuint multiplier = 10;\nuint x = (5 * multipler) / 2;\n```\n\n存储分子和分母意味着你可以离链计算分子除以分母的结果。\n\n```\n// good\nuint numerator = 5;\nuint denominator = 2;\n```\n\n### 记住以太币可以被强制发送到一个账户\n\n注意对严格检查了的合约的余额进行编码。\n\n一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 `revert()` 的 fallback 函数也不可以）\n\n攻击者通过创余额为 1 wei 的合约，然后通过 `selfdestruct(victimAddress)` 的方式达到目的。`victimAddress` 中没有代码被激活，所以这不能被阻止。\n\n### 注意抽象合约和接口的平衡\n\n接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。\n\n### 保持 fallback 函数简单\n\n当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，[Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function) 会被调用，而且如果通过 `.send()` 或者 `.transfer()` 调用的话只需要 2300 单位的燃料。如果你希望能够从 `.send()` 或者 `.transfer()` 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。\n\n```\n// bad\nfunciton() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { LogDepositReceived(msg.sender); }\n```\n\n### 为函数和状态变量显式标记可见性\n\n显式标记函数和状态变量的可见性。函数可以被指定为 `external / public / internal / private`。请理解它们之间的区别，比如，比起 `public`，`external` 可能已经足够使用了。对于状态变量来说，`external` 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 \n\n```\n// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public \n\t\t// public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n\t\t// only callable external\n}\n\nfunction utility() public {\n\t\t// callable externally, as well as internally: changing this code requires thinking about both cases\n}\n\nfunction internalAction() internal {\n\t\t// internal code\n}\n```\n\n### 锁定指定编译器版本的编译指示\n\n应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。\n\n```\n// bad \npragma solidity ^0.4.4;\n\n// good\npragma solidity 0.4.0;\n```\n\n#### 异常\n\n当合约打算供其他开发人员使用时，可以允许 `pragma` 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。\n\n### 函数和事件的区别\n\n对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。\n\n```\n// bad \nevent Transfer() {}\nfunction transfer() {}\n\n// good\nevent LogTransfer() {}\nfunction transfer() external {}\n```\n\n### 推荐使用更新的 Solidity 结构\n\n使用构造/别名如 `selfdestruct` （而不是 `suicide`），和 `keccak256` （而不是 `sha3`）。`require(msg.sender.send(1 ether))` 也可以使用 `transfer()` 简单地实现： `msg.sender.transfer(1 ether)`。\n\n### 注意内置函数可以被覆盖\n\n目前可以在 Solidity 覆盖（[shadow](https://en.wikipedia.org/wiki/Variable_shadowing)）内置的全局变量。它允许合约重写覆盖内置的方法，如 `msg` 和 `revert()`。尽管这是[故意](https://github.com/ethereum/solidity/issues/1249)的，但是它可能会在关于合约的真实行为上误导合约的用户。\n\n```\ncontract PretendingToRevert {\n\tfunction revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n\tfunction somethingBad() public {\n\t\trevert();\n\t}\n}\n```\n\n合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。\n\n### 避免使用 `tx.origin`\n\n永远不要使用 `tx.origin` 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 `tx.origin` 里面，你的合约就会授权该交易。\n\n```\npragma solidity ^0.4.18;\n\ncontract MyContract {\n\taddress owner;\n\n\tfunction MyContract() public {\n\t\towner = msg.sender;\n\t}\n\n\tfunction sendTo(address receiver, uint amount) public {\n\t\trequire(tx.origin == owner);\n\t\treceiver.transfer(amount);\n\t}\n}\n\ncontract AttackingContract {\n\tMyContract myContract;\n\taddress attacker;\n\n\tfunction AttackingContract(address myContractAddress) public {\n\t\tmyContract = MyContract(myContractAddress);\n\t\tattacker = msg.sender;\n\t}\n\n\tfunction() public {\n\t\tmyContract.sendTo(attacker, msg.sender.balance);\n\t}\n}\n```\n\n你应该使用 `msg.sender` 来授权（如果有另一个合约调用了你的合约，`msg.sender` 会成为合约的地址，而且不是调用合约的人的地址）。\n\n更多可见 [Solidity 文档](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n\n除了授权的这个问题，`tx.origin` 可能在将来从以太坊协议中移除，所以使用了 `tx.origin` 的代码在将来不会再被兼容 [Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'](https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200)\n\n另外值得一提的是，通过使用 `tx.origin`，你会限制合同之间的互操作性，因为使用 `tx.origin` 的合同不能被另一个合同使用，因为合同不能是 `tx.origin`。\n\n### 时间戳依赖\n\n在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。\n\n#### Gameability\n\n注意区块的时间戳是可用被矿工操作的。考虑这个[合约](https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code)：\n\n```\nuint256 constant private salt = block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result) {\n\t//get the best seed for randomness\n\tuint256 x = salt * 100/Max;\n\tuint256 y = salt * block.number/(salt % 5);\n\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n\tuint256 h = uint256(block.blockhash(seed));\n\n\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max\n}\n```\n\n当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。\n\n#### 30 秒规则\n\n评估时间戳使用的一般经验法则是：\n\n**如果合约功能可以容忍30秒的时间漂移，则可以安全使用 `block.timestamp`**\n\n如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。\n\n#### 将 `block.number` 作为时间戳使用时要当心\n\n当合约创建一个 `auction_complete` 修饰器来表示代币销售的结束，像[这样](https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol))\n\n```\nmodifier auction_complete {\n\trequire(auctionEndBlock <= block.number ||\n\t\tcurrentAuctionState == AuctionState.success ||\n\t\tcurrentAuctionState == AuctionState.cancel)\n\t\t_;\n}\n```\n\n`block.number` 和 [平均出块时间](https://etherscan.io/chart/blocktime) 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 [分叉重组](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/) 和 [难度炸弹](https://github.com/ethereum/EIPs/issues/649)）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。\n\n### 弃用/历史 建议\n\n由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.\n\n#### 注意被 0 除 （Solidity < 0.4）\n\n在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。\n","slug":"智能合约最佳实践翻译二","published":1,"updated":"2018-03-07T10:07:15.510Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7f000ql8jxwoovofx8","content":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\"><a href=\"#对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\" class=\"headerlink\" title=\"对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\"></a>对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity</h2><p>本页面展示了编写智能合约时应遵循的一些 solidity 模式。</p>\n<h3 id=\"协议具体建议\"><a href=\"#协议具体建议\" class=\"headerlink\" title=\"协议具体建议\"></a>协议具体建议</h3><p>以下建议适用于以太坊中所有的智能合约的开发。</p>\n<h3 id=\"外部调用\"><a href=\"#外部调用\" class=\"headerlink\" title=\"外部调用\"></a>外部调用</h3><h4 id=\"小心使用外部调用\"><a href=\"#小心使用外部调用\" class=\"headerlink\" title=\"小心使用外部调用\"></a>小心使用外部调用</h4><p>调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险</p>\n<h4 id=\"标记不受信任的合约\"><a href=\"#标记不受信任的合约\" class=\"headerlink\" title=\"标记不受信任的合约\"></a>标记不受信任的合约</h4><p>当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">Bank.withdraw(100); // Unclear whether trusted or untrusted</span><br><span class=\"line\"></span><br><span class=\"line\">// Isn&apos;t clear that this function is potentially unsafe</span><br><span class=\"line\">function makeWithdrawal(uint amount)  &#123;</span><br><span class=\"line\">\t\tBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">UntrustedBank.withdraw(100);</span><br><span class=\"line\">TrustedBank.withdraw(100);</span><br><span class=\"line\"></span><br><span class=\"line\">function makeUntrustedWithdrawal(uint amount) &#123;</span><br><span class=\"line\">\t\tUntrustedBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"避免在外部调用之后改变状态\"><a href=\"#避免在外部调用之后改变状态\" class=\"headerlink\" title=\"避免在外部调用之后改变状态\"></a>避免在外部调用之后改变状态</h4><p>不论是否使用 <code>raw calls</code>（<code>someAddress,call()</code> 的格式） 或者 <code>contract calls</code>（<code>ExternalContract.someMethod()</code> 的格式），都假定会执行恶意代码。即使 <code>ExternalContract</code> 不是恶意的，但它调用的任何合约也可能会执行恶意代码。</p>\n<p>一个特殊的危险是，恶意代码可能对控制流进行了 <code>hijack</code> 攻击，导致条件竞争。（见 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions\" target=\"_blank\" rel=\"noopener\">Race Conditions</a> 了解更多关于这个问题的讨论）。</p>\n<p>如果你调用了一个不受信任的外部合约，<em>避免在调用之后改变状态</em>。这个模式也常常作为 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern\" target=\"_blank\" rel=\"noopener\">check-effects-interactions 模式</a> 为人们所知。</p>\n<h4 id=\"注意-send-transfer-call-value-之间的平衡\"><a href=\"#注意-send-transfer-call-value-之间的平衡\" class=\"headerlink\" title=\"注意 send() / transfer() / call.value() 之间的平衡\"></a>注意 <code>send() / transfer() / call.value()</code> 之间的平衡</h4><p>在发送 ether 时注意 <code>someAddress.send() / someAddress.transfer() / someAddress.call.value()()</code> 之间的使用的关系的平衡。</p>\n<ul>\n<li><code>someAddress.send()</code> 和 <code>someAddress.transfer()</code> 被认为对于<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy\" target=\"_blank\" rel=\"noopener\">重入</a>是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。</li>\n<li><code>x.transfer(y)</code> 和 <code>require(x.send(y));</code> 的等同的，如果发送失败，它会自动回退。</li>\n<li><code>someAddress.call.value(y)()</code> 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。</li>\n</ul>\n<p>使用 <code>send()</code> 和 <code>transfer()</code> 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 <code>someAddress.vall.value(ethAmount).gas(gasAmount)()</code> 来转发指定的燃料数量。</p>\n<p>一个试图平衡这个问题的解决办法是实现 <em><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments\" target=\"_blank\" rel=\"noopener\">退和拉</a></em> 的机制模式， <em>推送</em> 部分使用 <code>send()</code> 或者 <code>transfer()</code> ，<em>拉</em> 部分使用 <code>call.value()</code> 。</p>\n<p>值得指出的是，对于价值转移而言，专用 <code>send()</code> 或者 <code>transfer()</code> 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。</p>\n<h4 id=\"解决外部调用的错误\"><a href=\"#解决外部调用的错误\" class=\"headerlink\" title=\"解决外部调用的错误\"></a>解决外部调用的错误</h4><p>Solidity 提供了处理原生地址的底层调用方法：<code>address.call()</code>，<code>address.callcode()</code>，<code>address,delegatecall()</code>，和 <code>address.send()</code>。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 <code>false</code>。从另一方面来说，<em>合约调用</em>（如 <code>ExternalContract.doSomething()</code>）会自动传播一个异常（比如，如果 <code>doSomething()</code> 抛出异常，<code>ExternalContract.doSomething()</code> 也会 <code>throw</code>）。</p>\n<p>如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">someAddress.send(55);</span><br><span class=\"line\">someAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn&apos;t check for result</span><br><span class=\"line\">someAddress.call.value(100)(bytes4(sha3(&quot;deposit()&quot;))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">if (!someAddress.send(55)) &#123;</span><br><span class=\"line\">\t\t// some failure code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalContract(someAddress).deposit.value(100);</span><br></pre></td></tr></table></figure>\n<h4 id=\"对外部调用来说，拉比推更好\"><a href=\"#对外部调用来说，拉比推更好\" class=\"headerlink\" title=\"对外部调用来说，拉比推更好\"></a>对外部调用来说，拉比推更好</h4><p>外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了<a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit\" target=\"_blank\" rel=\"noopener\">燃料限制问题</a>。）避免在单个交易中组合多个 <code>send()</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\">\tmapping(address =&gt; uint) refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable external &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction withdrawRefund() external &#123;</span><br><span class=\"line\">\t\tuint refund = refunds[msg.sender];</span><br><span class=\"line\">\t\trefunds[msg.sender] = 0;</span><br><span class=\"line\">\t\tmsg.sender.transfer(refund);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不要假设合约创建时是-0-资产\"><a href=\"#不要假设合约创建时是-0-资产\" class=\"headerlink\" title=\"不要假设合约创建时是 0 资产\"></a>不要假设合约创建时是 0 资产</h4><p>一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 <a href=\"https://github.com/ConsenSys/smart-contract-best-practices/issues/61\" target=\"_blank\" rel=\"noopener\">问题 61</a> 查看更多细节。</p>\n<h4 id=\"记住链上的数据是公开的\"><a href=\"#记住链上的数据是公开的\" class=\"headerlink\" title=\"记住链上的数据是公开的\"></a>记住链上的数据是公开的</h4><p>许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。</p>\n<p>示例：</p>\n<ul>\n<li>在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。</li>\n<li>在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。</li>\n<li>当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 <a href=\"http://btcrelay.org\" target=\"_blank\" rel=\"noopener\">http://btcrelay.org</a> 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 <a href=\"https://github.com/randao/randao\" target=\"_blank\" rel=\"noopener\">RANDAO</a></li>\n<li>如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。</li>\n</ul>\n<h3 id=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"><a href=\"#注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\" class=\"headerlink\" title=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"></a>注意在双方或者多方合约中，一些成员可能”掉线“，没有返回</h3><p>不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。</p>\n<h3 id=\"Solidity-详细建议\"><a href=\"#Solidity-详细建议\" class=\"headerlink\" title=\"Solidity 详细建议\"></a>Solidity 详细建议</h3><p>下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。</p>\n<h3 id=\"强制对不变值使用-assert\"><a href=\"#强制对不变值使用-assert\" class=\"headerlink\" title=\"强制对不变值使用 assert()\"></a>强制对不变值使用 <code>assert()</code></h3><p>当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 <code>assert()</code> 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">\tmapping (address =&gt; uint) public balanceOf;</span><br><span class=\"line\">\tuint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction deposit() public payable &#123;</span><br><span class=\"line\">\t\tbalanceOf[msg.sender] += msg.value;</span><br><span class=\"line\">\t\ttotalSupply += msg.value;</span><br><span class=\"line\">\t\tassert(this.balance &gt;= totalSupply);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意断言并非对资产严格相等，因为合约可以不通过 <code>deposit</code> 函数强制<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent\" target=\"_blank\" rel=\"noopener\">发送以太币</a></p>\n<h3 id=\"正确地使用-assert-和-require\"><a href=\"#正确地使用-assert-和-require\" class=\"headerlink\" title=\"正确地使用 assert() 和 require()\"></a>正确地使用 <code>assert()</code> 和 <code>require()</code></h3><p>在 Solidity 0.4.10 中，引入了 <code>assert()</code> 和 <code>require()</code>。<code>require(condition)</code> 被用来对用户的任何输入进行验证，如果条件不成立则回滚。<code>assert(condition)</code> 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。</p>\n<h3 id=\"小心整数除法\"><a href=\"#小心整数除法\" class=\"headerlink\" title=\"小心整数除法\"></a>小心整数除法</h3><p>所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。</p>\n<p>（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer</span><br></pre></td></tr></table></figure>\n<p>使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint multiplier = 10;</span><br><span class=\"line\">uint x = (5 * multipler) / 2;</span><br></pre></td></tr></table></figure>\n<p>存储分子和分母意味着你可以离链计算分子除以分母的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint numerator = 5;</span><br><span class=\"line\">uint denominator = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"记住以太币可以被强制发送到一个账户\"><a href=\"#记住以太币可以被强制发送到一个账户\" class=\"headerlink\" title=\"记住以太币可以被强制发送到一个账户\"></a>记住以太币可以被强制发送到一个账户</h3><p>注意对严格检查了的合约的余额进行编码。</p>\n<p>一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 <code>revert()</code> 的 fallback 函数也不可以）</p>\n<p>攻击者通过创余额为 1 wei 的合约，然后通过 <code>selfdestruct(victimAddress)</code> 的方式达到目的。<code>victimAddress</code> 中没有代码被激活，所以这不能被阻止。</p>\n<h3 id=\"注意抽象合约和接口的平衡\"><a href=\"#注意抽象合约和接口的平衡\" class=\"headerlink\" title=\"注意抽象合约和接口的平衡\"></a>注意抽象合约和接口的平衡</h3><p>接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。</p>\n<h3 id=\"保持-fallback-函数简单\"><a href=\"#保持-fallback-函数简单\" class=\"headerlink\" title=\"保持 fallback 函数简单\"></a>保持 fallback 函数简单</h3><p>当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function\" target=\"_blank\" rel=\"noopener\">Fallback 函数</a> 会被调用，而且如果通过 <code>.send()</code> 或者 <code>.transfer()</code> 调用的话只需要 2300 单位的燃料。如果你希望能够从 <code>.send()</code> 或者 <code>.transfer()</code> 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">funciton() payable &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">function deposit() payable external &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function() payable &#123; LogDepositReceived(msg.sender); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为函数和状态变量显式标记可见性\"><a href=\"#为函数和状态变量显式标记可见性\" class=\"headerlink\" title=\"为函数和状态变量显式标记可见性\"></a>为函数和状态变量显式标记可见性</h3><p>显式标记函数和状态变量的可见性。函数可以被指定为 <code>external / public / internal / private</code>。请理解它们之间的区别，比如，比起 <code>public</code>，<code>external</code> 可能已经足够使用了。对于状态变量来说，<code>external</code> 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x; // the default is internal for state variables, but it should be made explicit</span><br><span class=\"line\">function buy() &#123; // the default is public </span><br><span class=\"line\">\t\t// public code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">uint private y;</span><br><span class=\"line\">function buy() external &#123;</span><br><span class=\"line\">\t\t// only callable external</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function utility() public &#123;</span><br><span class=\"line\">\t\t// callable externally, as well as internally: changing this code requires thinking about both cases</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function internalAction() internal &#123;</span><br><span class=\"line\">\t\t// internal code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"锁定指定编译器版本的编译指示\"><a href=\"#锁定指定编译器版本的编译指示\" class=\"headerlink\" title=\"锁定指定编译器版本的编译指示\"></a>锁定指定编译器版本的编译指示</h3><p>应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">pragma solidity ^0.4.4;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">pragma solidity 0.4.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>当合约打算供其他开发人员使用时，可以允许 <code>pragma</code> 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。</p>\n<h3 id=\"函数和事件的区别\"><a href=\"#函数和事件的区别\" class=\"headerlink\" title=\"函数和事件的区别\"></a>函数和事件的区别</h3><p>对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">event Transfer() &#123;&#125;</span><br><span class=\"line\">function transfer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">event LogTransfer() &#123;&#125;</span><br><span class=\"line\">function transfer() external &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推荐使用更新的-Solidity-结构\"><a href=\"#推荐使用更新的-Solidity-结构\" class=\"headerlink\" title=\"推荐使用更新的 Solidity 结构\"></a>推荐使用更新的 Solidity 结构</h3><p>使用构造/别名如 <code>selfdestruct</code> （而不是 <code>suicide</code>），和 <code>keccak256</code> （而不是 <code>sha3</code>）。<code>require(msg.sender.send(1 ether))</code> 也可以使用 <code>transfer()</code> 简单地实现： <code>msg.sender.transfer(1 ether)</code>。</p>\n<h3 id=\"注意内置函数可以被覆盖\"><a href=\"#注意内置函数可以被覆盖\" class=\"headerlink\" title=\"注意内置函数可以被覆盖\"></a>注意内置函数可以被覆盖</h3><p>目前可以在 Solidity 覆盖（<a href=\"https://en.wikipedia.org/wiki/Variable_shadowing\" target=\"_blank\" rel=\"noopener\">shadow</a>）内置的全局变量。它允许合约重写覆盖内置的方法，如 <code>msg</code> 和 <code>revert()</code>。尽管这是<a href=\"https://github.com/ethereum/solidity/issues/1249\" target=\"_blank\" rel=\"noopener\">故意</a>的，但是它可能会在关于合约的真实行为上误导合约的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction revert() internal constant &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ExampleContract is PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction somethingBad() public &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。</p>\n<h3 id=\"避免使用-tx-origin\"><a href=\"#避免使用-tx-origin\" class=\"headerlink\" title=\"避免使用 tx.origin\"></a>避免使用 <code>tx.origin</code></h3><p>永远不要使用 <code>tx.origin</code> 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 <code>tx.origin</code> 里面，你的合约就会授权该交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.18;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction MyContract() public &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction sendTo(address receiver, uint amount) public &#123;</span><br><span class=\"line\">\t\trequire(tx.origin == owner);</span><br><span class=\"line\">\t\treceiver.transfer(amount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AttackingContract &#123;</span><br><span class=\"line\">\tMyContract myContract;</span><br><span class=\"line\">\taddress attacker;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction AttackingContract(address myContractAddress) public &#123;</span><br><span class=\"line\">\t\tmyContract = MyContract(myContractAddress);</span><br><span class=\"line\">\t\tattacker = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() public &#123;</span><br><span class=\"line\">\t\tmyContract.sendTo(attacker, msg.sender.balance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你应该使用 <code>msg.sender</code> 来授权（如果有另一个合约调用了你的合约，<code>msg.sender</code> 会成为合约的地址，而且不是调用合约的人的地址）。</p>\n<p>更多可见 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin\" target=\"_blank\" rel=\"noopener\">Solidity 文档</a></p>\n<p>除了授权的这个问题，<code>tx.origin</code> 可能在将来从以太坊协议中移除，所以使用了 <code>tx.origin</code> 的代码在将来不会再被兼容 <a href=\"https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200\" target=\"_blank\" rel=\"noopener\">Vitalik: ‘Do NOT assume that tx.origin will continue to be usable or meaningful.’</a></p>\n<p>另外值得一提的是，通过使用 <code>tx.origin</code>，你会限制合同之间的互操作性，因为使用 <code>tx.origin</code> 的合同不能被另一个合同使用，因为合同不能是 <code>tx.origin</code>。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。</p>\n<h4 id=\"Gameability\"><a href=\"#Gameability\" class=\"headerlink\" title=\"Gameability\"></a>Gameability</h4><p>注意区块的时间戳是可用被矿工操作的。考虑这个<a href=\"https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code\" target=\"_blank\" rel=\"noopener\">合约</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 constant private salt = block.timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">function random(uint Max) constant private returns (uint256 result) &#123;</span><br><span class=\"line\">\t//get the best seed for randomness</span><br><span class=\"line\">\tuint256 x = salt * 100/Max;</span><br><span class=\"line\">\tuint256 y = salt * block.number/(salt % 5);</span><br><span class=\"line\">\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;</span><br><span class=\"line\">\tuint256 h = uint256(block.blockhash(seed));</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。</p>\n<h4 id=\"30-秒规则\"><a href=\"#30-秒规则\" class=\"headerlink\" title=\"30 秒规则\"></a>30 秒规则</h4><p>评估时间戳使用的一般经验法则是：</p>\n<p><strong>如果合约功能可以容忍30秒的时间漂移，则可以安全使用 <code>block.timestamp</code></strong></p>\n<p>如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。</p>\n<h4 id=\"将-block-number-作为时间戳使用时要当心\"><a href=\"#将-block-number-作为时间戳使用时要当心\" class=\"headerlink\" title=\"将 block.number 作为时间戳使用时要当心\"></a>将 <code>block.number</code> 作为时间戳使用时要当心</h4><p>当合约创建一个 <code>auction_complete</code> 修饰器来表示代币销售的结束，像<a href=\"https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol\" target=\"_blank\" rel=\"noopener\">这样</a>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier auction_complete &#123;</span><br><span class=\"line\">\trequire(auctionEndBlock &lt;= block.number ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.success ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.cancel)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>block.number</code> 和 <a href=\"https://etherscan.io/chart/blocktime\" target=\"_blank\" rel=\"noopener\">平均出块时间</a> 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 <a href=\"https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/\" target=\"_blank\" rel=\"noopener\">分叉重组</a> 和 <a href=\"https://github.com/ethereum/EIPs/issues/649\" target=\"_blank\" rel=\"noopener\">难度炸弹</a>）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。</p>\n<h3 id=\"弃用-历史-建议\"><a href=\"#弃用-历史-建议\" class=\"headerlink\" title=\"弃用/历史 建议\"></a>弃用/历史 建议</h3><p>由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.</p>\n<h4 id=\"注意被-0-除-（Solidity-lt-0-4）\"><a href=\"#注意被-0-除-（Solidity-lt-0-4）\" class=\"headerlink\" title=\"注意被 0 除 （Solidity &lt; 0.4）\"></a>注意被 0 除 （Solidity &lt; 0.4）</h4><p>在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\"><a href=\"#对-Solidity-中的智能合约的安全推荐-Recommendations-for-Smart-Contract-Security-in-Solidity\" class=\"headerlink\" title=\"对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity\"></a>对 Solidity 中的智能合约的安全推荐 Recommendations for Smart Contract Security in Solidity</h2><p>本页面展示了编写智能合约时应遵循的一些 solidity 模式。</p>\n<h3 id=\"协议具体建议\"><a href=\"#协议具体建议\" class=\"headerlink\" title=\"协议具体建议\"></a>协议具体建议</h3><p>以下建议适用于以太坊中所有的智能合约的开发。</p>\n<h3 id=\"外部调用\"><a href=\"#外部调用\" class=\"headerlink\" title=\"外部调用\"></a>外部调用</h3><h4 id=\"小心使用外部调用\"><a href=\"#小心使用外部调用\" class=\"headerlink\" title=\"小心使用外部调用\"></a>小心使用外部调用</h4><p>调用不受信任的合约会引入一些预期外的风险或错误。外部调用可能会在该合约或其依赖的任何其他合约中执行恶意代码。所以每个外部调用都要被当做潜在的安全风险来对待。如果不可能或不希望删除外部调用，请使用本节其余部分的建议来减少危险</p>\n<h4 id=\"标记不受信任的合约\"><a href=\"#标记不受信任的合约\" class=\"headerlink\" title=\"标记不受信任的合约\"></a>标记不受信任的合约</h4><p>当与外部合约交互的时候，通过某种形式命名你的变量，方法和合约接口来清楚地表达其所交互的对象是具有潜在性的安全问题的。这适用于你的调用外部合约的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">Bank.withdraw(100); // Unclear whether trusted or untrusted</span><br><span class=\"line\"></span><br><span class=\"line\">// Isn&apos;t clear that this function is potentially unsafe</span><br><span class=\"line\">function makeWithdrawal(uint amount)  &#123;</span><br><span class=\"line\">\t\tBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">UntrustedBank.withdraw(100);</span><br><span class=\"line\">TrustedBank.withdraw(100);</span><br><span class=\"line\"></span><br><span class=\"line\">function makeUntrustedWithdrawal(uint amount) &#123;</span><br><span class=\"line\">\t\tUntrustedBank.withdraw(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"避免在外部调用之后改变状态\"><a href=\"#避免在外部调用之后改变状态\" class=\"headerlink\" title=\"避免在外部调用之后改变状态\"></a>避免在外部调用之后改变状态</h4><p>不论是否使用 <code>raw calls</code>（<code>someAddress,call()</code> 的格式） 或者 <code>contract calls</code>（<code>ExternalContract.someMethod()</code> 的格式），都假定会执行恶意代码。即使 <code>ExternalContract</code> 不是恶意的，但它调用的任何合约也可能会执行恶意代码。</p>\n<p>一个特殊的危险是，恶意代码可能对控制流进行了 <code>hijack</code> 攻击，导致条件竞争。（见 <a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions\" target=\"_blank\" rel=\"noopener\">Race Conditions</a> 了解更多关于这个问题的讨论）。</p>\n<p>如果你调用了一个不受信任的外部合约，<em>避免在调用之后改变状态</em>。这个模式也常常作为 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern\" target=\"_blank\" rel=\"noopener\">check-effects-interactions 模式</a> 为人们所知。</p>\n<h4 id=\"注意-send-transfer-call-value-之间的平衡\"><a href=\"#注意-send-transfer-call-value-之间的平衡\" class=\"headerlink\" title=\"注意 send() / transfer() / call.value() 之间的平衡\"></a>注意 <code>send() / transfer() / call.value()</code> 之间的平衡</h4><p>在发送 ether 时注意 <code>someAddress.send() / someAddress.transfer() / someAddress.call.value()()</code> 之间的使用的关系的平衡。</p>\n<ul>\n<li><code>someAddress.send()</code> 和 <code>someAddress.transfer()</code> 被认为对于<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#reentrancy\" target=\"_blank\" rel=\"noopener\">重入</a>是安全的。尽管这些方法仍然会触发代码的执行，但是被调用的合约只会被提供 2300 单位的燃料，目前来说，这么多的燃料足够用来记录事件了。</li>\n<li><code>x.transfer(y)</code> 和 <code>require(x.send(y));</code> 的等同的，如果发送失败，它会自动回退。</li>\n<li><code>someAddress.call.value(y)()</code> 会发送提供的以太币，然后触发代码的执行。为执行的代码提供所有可用来执行的燃料使得这种转账方式对于重入来说很不安全。</li>\n</ul>\n<p>使用 <code>send()</code> 和 <code>transfer()</code> 可以防止重入，但是这样的做法会使得与那些 fallback 函数的消耗超过 2300 单位燃料的合约不兼容。也可以使用 <code>someAddress.vall.value(ethAmount).gas(gasAmount)()</code> 来转发指定的燃料数量。</p>\n<p>一个试图平衡这个问题的解决办法是实现 <em><a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-payments\" target=\"_blank\" rel=\"noopener\">退和拉</a></em> 的机制模式， <em>推送</em> 部分使用 <code>send()</code> 或者 <code>transfer()</code> ，<em>拉</em> 部分使用 <code>call.value()</code> 。</p>\n<p>值得指出的是，对于价值转移而言，专用 <code>send()</code> 或者 <code>transfer()</code> 并不能使得合约避免重入的安全问题，但是能够使得一些特定的转账避免重入的安全问题。</p>\n<h4 id=\"解决外部调用的错误\"><a href=\"#解决外部调用的错误\" class=\"headerlink\" title=\"解决外部调用的错误\"></a>解决外部调用的错误</h4><p>Solidity 提供了处理原生地址的底层调用方法：<code>address.call()</code>，<code>address.callcode()</code>，<code>address,delegatecall()</code>，和 <code>address.send()</code>。当调用遇到一个异常的时候，这些底层方法不会抛出一个异常，而是返回一个 <code>false</code>。从另一方面来说，<em>合约调用</em>（如 <code>ExternalContract.doSomething()</code>）会自动传播一个异常（比如，如果 <code>doSomething()</code> 抛出异常，<code>ExternalContract.doSomething()</code> 也会 <code>throw</code>）。</p>\n<p>如果你选择使用底层调用方法，要确定你通过检查返回值，处理了可能存在的调用失败的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">someAddress.send(55);</span><br><span class=\"line\">someAddress.call.value(55)(); // this is doubly dangerous, as it will forward all remaining gas and doesn&apos;t check for result</span><br><span class=\"line\">someAddress.call.value(100)(bytes4(sha3(&quot;deposit()&quot;))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">if (!someAddress.send(55)) &#123;</span><br><span class=\"line\">\t\t// some failure code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalContract(someAddress).deposit.value(100);</span><br></pre></td></tr></table></figure>\n<h4 id=\"对外部调用来说，拉比推更好\"><a href=\"#对外部调用来说，拉比推更好\" class=\"headerlink\" title=\"对外部调用来说，拉比推更好\"></a>对外部调用来说，拉比推更好</h4><p>外部调用可能有意无意而失败。为了最小化这样失败带来的破坏，通常最好将每个外部调用隔离到可以由调用接收方发起的自己的交易中。这与支付特别相关，与将资金自动推给用户比起来，更好的是让用户提取资金。（这也减少了<a href=\"https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit\" target=\"_blank\" rel=\"noopener\">燃料限制问题</a>。）避免在单个交易中组合多个 <code>send()</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\thighestBidder.transfer(highestBid); // if this call consistently fails, no one else can bid </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">contract auction &#123;</span><br><span class=\"line\">\taddress highestBidder;</span><br><span class=\"line\">\tuint highestBid;</span><br><span class=\"line\">\tmapping(address =&gt; uint) refunds;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction bid() payable external &#123;</span><br><span class=\"line\">\t\trequire(msg.value &gt;= highestBid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (highestBidder != 0) &#123;</span><br><span class=\"line\">\t\t\trefunds[highestBidder] += highestBid; // record the refund that this user can claim</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thighestBidder = msg.sender;</span><br><span class=\"line\">\t\thighestBid = msg.value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction withdrawRefund() external &#123;</span><br><span class=\"line\">\t\tuint refund = refunds[msg.sender];</span><br><span class=\"line\">\t\trefunds[msg.sender] = 0;</span><br><span class=\"line\">\t\tmsg.sender.transfer(refund);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不要假设合约创建时是-0-资产\"><a href=\"#不要假设合约创建时是-0-资产\" class=\"headerlink\" title=\"不要假设合约创建时是 0 资产\"></a>不要假设合约创建时是 0 资产</h4><p>一个攻击者可以在合约创建之前发送 wei 到合约的地址。合约不应该假设初始状态包含 0 资产。见 <a href=\"https://github.com/ConsenSys/smart-contract-best-practices/issues/61\" target=\"_blank\" rel=\"noopener\">问题 61</a> 查看更多细节。</p>\n<h4 id=\"记住链上的数据是公开的\"><a href=\"#记住链上的数据是公开的\" class=\"headerlink\" title=\"记住链上的数据是公开的\"></a>记住链上的数据是公开的</h4><p>许多应用程序要求提交数据以便在某个时间点可以供其工作。游戏（如链上的石头剪子布）和拍卖机制（如 盲派的第二次出价）是两种主要类别的例子。如果你正在构建一个涉及到隐私的应用，注意不免要求用户过早发布信息。</p>\n<p>示例：</p>\n<ul>\n<li>在石头剪子布中，首先要求两个玩家同时提交他们的出手意图的哈希值，然后再要求提交他们的实际出手，如果匹配不上之前的哈希值，则抛出。</li>\n<li>在一个拍卖中，要求玩家在初始阶段提交他们的出价金额的哈希值（保证金高于他们的竞价），然后在第二阶段提交他们的实际竞价。</li>\n<li>当开发一个依赖于随机数生成器的应用时，顺序应该总是（1）提交行动，（2）生成随机数，（3）玩家付出。随机数生成方法本来就是一个活跃的研究领域；目前同类最佳的解决方案包括比特币区块头（通过 <a href=\"http://btcrelay.org\" target=\"_blank\" rel=\"noopener\">http://btcrelay.org</a> 来验证），散列提交揭示方案（即一方产生一个数字，将其散列值发布为”提交“的值，然后揭示这个数）和 <a href=\"https://github.com/randao/randao\" target=\"_blank\" rel=\"noopener\">RANDAO</a></li>\n<li>如果你正在实现一个频繁的批量拍卖，哈希提交方案也很合适。</li>\n</ul>\n<h3 id=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"><a href=\"#注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\" class=\"headerlink\" title=\"注意在双方或者多方合约中，一些成员可能”掉线“，没有返回\"></a>注意在双方或者多方合约中，一些成员可能”掉线“，没有返回</h3><p>不要只依赖于特定方执行特定行动的退款或者索赔流程，而没有其他获得资金的方式。比如，在剪刀石头布游戏中，一个常见的错误是在两位玩家提交它们的行动之前，没有进行支付；然而，一个恶意的玩家可以简单地通过不提交他的动作来使得另一位玩家陷入困境 - 实际上，如果一个玩家看到了其他玩家暴露的行为，并且确定他们输了，他们就没有任何理由去提交他们自己的行为。这个问题也可能出现在状态渠道的解决中。当这样的场景变成一个问题，（1）提供一种规避未参与的参与者的方式，可能是通过限制时间，（2）考虑增加额外的经济激励，让参与者在需要提交信息的场景中提交所有该场景需要的信息。</p>\n<h3 id=\"Solidity-详细建议\"><a href=\"#Solidity-详细建议\" class=\"headerlink\" title=\"Solidity 详细建议\"></a>Solidity 详细建议</h3><p>下面的建议对于 Solidity 来说十分详细，不过对于使用其他语言来开发智能合约来说，应该也是有所帮助的。</p>\n<h3 id=\"强制对不变值使用-assert\"><a href=\"#强制对不变值使用-assert\" class=\"headerlink\" title=\"强制对不变值使用 assert()\"></a>强制对不变值使用 <code>assert()</code></h3><p>当一个断言失败的时候，它的保护机制就会被触发 - 比如当一个不变的属性改变的时候。比如，在一个代币发行合约中，代币与以太币的汇率可能是固定的。然后你可以通过 <code>assert()</code> 来验证所有的这种情况。断言保护机制应该经常与其他技术结合，如暂停合约和允许升级。（否则，你可能会陷入停滞，而一个断言总是在失败。）</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">\tmapping (address =&gt; uint) public balanceOf;</span><br><span class=\"line\">\tuint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction deposit() public payable &#123;</span><br><span class=\"line\">\t\tbalanceOf[msg.sender] += msg.value;</span><br><span class=\"line\">\t\ttotalSupply += msg.value;</span><br><span class=\"line\">\t\tassert(this.balance &gt;= totalSupply);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意断言并非对资产严格相等，因为合约可以不通过 <code>deposit</code> 函数强制<a href=\"https://consensys.github.io/smart-contract-best-practices/recommendations/#ether-forcibly-sent\" target=\"_blank\" rel=\"noopener\">发送以太币</a></p>\n<h3 id=\"正确地使用-assert-和-require\"><a href=\"#正确地使用-assert-和-require\" class=\"headerlink\" title=\"正确地使用 assert() 和 require()\"></a>正确地使用 <code>assert()</code> 和 <code>require()</code></h3><p>在 Solidity 0.4.10 中，引入了 <code>assert()</code> 和 <code>require()</code>。<code>require(condition)</code> 被用来对用户的任何输入进行验证，如果条件不成立则回滚。<code>assert(condition)</code> 在条件不成立时也会回滚，但是只用在不变值上：内部错误或者检查你的合约是否是非法的状态。遵循这种范式将允许形式分析工具来进行验证工作，而非法的操作码永远不会到达：这意味着代码中的任何不变值都不会被违反，并且代码正确地验证。</p>\n<h3 id=\"小心整数除法\"><a href=\"#小心整数除法\" class=\"headerlink\" title=\"小心整数除法\"></a>小心整数除法</h3><p>所有整数除法都被向下取整。如果你需要更高的精度，考虑使用乘数，或者存储分子和分母。</p>\n<p>（在未来，Solidity 会有定点类型，这会使得整数除法更容易。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer</span><br></pre></td></tr></table></figure>\n<p>使用乘数来防止向下取整，当使用 x 的时候要考虑到这个乘数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint multiplier = 10;</span><br><span class=\"line\">uint x = (5 * multipler) / 2;</span><br></pre></td></tr></table></figure>\n<p>存储分子和分母意味着你可以离链计算分子除以分母的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">uint numerator = 5;</span><br><span class=\"line\">uint denominator = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"记住以太币可以被强制发送到一个账户\"><a href=\"#记住以太币可以被强制发送到一个账户\" class=\"headerlink\" title=\"记住以太币可以被强制发送到一个账户\"></a>记住以太币可以被强制发送到一个账户</h3><p>注意对严格检查了的合约的余额进行编码。</p>\n<p>一个攻击者可以强制对任何账户发送 wei，而且这不能被阻止（即使是使用了 <code>revert()</code> 的 fallback 函数也不可以）</p>\n<p>攻击者通过创余额为 1 wei 的合约，然后通过 <code>selfdestruct(victimAddress)</code> 的方式达到目的。<code>victimAddress</code> 中没有代码被激活，所以这不能被阻止。</p>\n<h3 id=\"注意抽象合约和接口的平衡\"><a href=\"#注意抽象合约和接口的平衡\" class=\"headerlink\" title=\"注意抽象合约和接口的平衡\"></a>注意抽象合约和接口的平衡</h3><p>接口和抽象合约都为智能合约提供了一种定制的，可复用的方式。接口，在 Solidity 0.4.11 中被引入，与抽象合约十分相似，但是接口不能有已经实现的方法。接口同样也有限制，它不能访问存储，不能继承其他接口，而这通常使得抽象合约更加实用。虽然，接口实际上对设计合约的实现上十分有用。另外，十分重要的是如果一个合约继承了一个抽象合约，那它必须通过重写来实现所有抽象合约中未实现的函数，否则它依旧是一个抽象合约。</p>\n<h3 id=\"保持-fallback-函数简单\"><a href=\"#保持-fallback-函数简单\" class=\"headerlink\" title=\"保持 fallback 函数简单\"></a>保持 fallback 函数简单</h3><p>当一个合约发送了没有参数（或者当没有函数匹配上的时候）的消息时，<a href=\"https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function\" target=\"_blank\" rel=\"noopener\">Fallback 函数</a> 会被调用，而且如果通过 <code>.send()</code> 或者 <code>.transfer()</code> 调用的话只需要 2300 单位的燃料。如果你希望能够从 <code>.send()</code> 或者 <code>.transfer()</code> 接受以太币，你能做的就是在 fallback 函数中记录一个日志。如果需要计算，或者更多的燃料，就使用一个真正的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">funciton() payable &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">function deposit() payable external &#123; balances[msg.sender] += msg.value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function() payable &#123; LogDepositReceived(msg.sender); &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为函数和状态变量显式标记可见性\"><a href=\"#为函数和状态变量显式标记可见性\" class=\"headerlink\" title=\"为函数和状态变量显式标记可见性\"></a>为函数和状态变量显式标记可见性</h3><p>显式标记函数和状态变量的可见性。函数可以被指定为 <code>external / public / internal / private</code>。请理解它们之间的区别，比如，比起 <code>public</code>，<code>external</code> 可能已经足够使用了。对于状态变量来说，<code>external</code> 是不可能的。显式标记可见性将更容易捕捉有关谁可以调用函数或访问变量的错误假设。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">uint x; // the default is internal for state variables, but it should be made explicit</span><br><span class=\"line\">function buy() &#123; // the default is public </span><br><span class=\"line\">\t\t// public code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">uint private y;</span><br><span class=\"line\">function buy() external &#123;</span><br><span class=\"line\">\t\t// only callable external</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function utility() public &#123;</span><br><span class=\"line\">\t\t// callable externally, as well as internally: changing this code requires thinking about both cases</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function internalAction() internal &#123;</span><br><span class=\"line\">\t\t// internal code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"锁定指定编译器版本的编译指示\"><a href=\"#锁定指定编译器版本的编译指示\" class=\"headerlink\" title=\"锁定指定编译器版本的编译指示\"></a>锁定指定编译器版本的编译指示</h3><p>应该使用相同的编译器版本部署合同，并标记它们已经经过了足够的测试。锁定编译指示可以帮助确保合约不会意外部署，比如，最新的编译器对未知错误有更高的风险。合约也可能由其他人部署，通过编译指示就知道原作者打算使用的编译器版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">pragma solidity ^0.4.4;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">pragma solidity 0.4.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>当合约打算供其他开发人员使用时，可以允许 <code>pragma</code> 语句浮动，例如类库或者 EthPM 包。否则，开发人员为了在本地编译就需要手动更新编译指示。</p>\n<h3 id=\"函数和事件的区别\"><a href=\"#函数和事件的区别\" class=\"headerlink\" title=\"函数和事件的区别\"></a>函数和事件的区别</h3><p>对事件名首字母大写,以及添加作用前缀，来防止对函数和事件产生困惑。对于方法来说，总是以小写字母开头，除了构造函数之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad </span><br><span class=\"line\">event Transfer() &#123;&#125;</span><br><span class=\"line\">function transfer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">event LogTransfer() &#123;&#125;</span><br><span class=\"line\">function transfer() external &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推荐使用更新的-Solidity-结构\"><a href=\"#推荐使用更新的-Solidity-结构\" class=\"headerlink\" title=\"推荐使用更新的 Solidity 结构\"></a>推荐使用更新的 Solidity 结构</h3><p>使用构造/别名如 <code>selfdestruct</code> （而不是 <code>suicide</code>），和 <code>keccak256</code> （而不是 <code>sha3</code>）。<code>require(msg.sender.send(1 ether))</code> 也可以使用 <code>transfer()</code> 简单地实现： <code>msg.sender.transfer(1 ether)</code>。</p>\n<h3 id=\"注意内置函数可以被覆盖\"><a href=\"#注意内置函数可以被覆盖\" class=\"headerlink\" title=\"注意内置函数可以被覆盖\"></a>注意内置函数可以被覆盖</h3><p>目前可以在 Solidity 覆盖（<a href=\"https://en.wikipedia.org/wiki/Variable_shadowing\" target=\"_blank\" rel=\"noopener\">shadow</a>）内置的全局变量。它允许合约重写覆盖内置的方法，如 <code>msg</code> 和 <code>revert()</code>。尽管这是<a href=\"https://github.com/ethereum/solidity/issues/1249\" target=\"_blank\" rel=\"noopener\">故意</a>的，但是它可能会在关于合约的真实行为上误导合约的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction revert() internal constant &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ExampleContract is PretendingToRevert &#123;</span><br><span class=\"line\">\tfunction somethingBad() public &#123;</span><br><span class=\"line\">\t\trevert();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合约用户（和审计人员）应该注意他们想要使用的应用的所有合约源代码。</p>\n<h3 id=\"避免使用-tx-origin\"><a href=\"#避免使用-tx-origin\" class=\"headerlink\" title=\"避免使用 tx.origin\"></a>避免使用 <code>tx.origin</code></h3><p>永远不要使用 <code>tx.origin</code> 进行授权，另一个合约可以有一种方法来调用你的合约（比如用户有一些资金），而因为你的地址在 <code>tx.origin</code> 里面，你的合约就会授权该交易。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.4.18;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">\taddress owner;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction MyContract() public &#123;</span><br><span class=\"line\">\t\towner = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction sendTo(address receiver, uint amount) public &#123;</span><br><span class=\"line\">\t\trequire(tx.origin == owner);</span><br><span class=\"line\">\t\treceiver.transfer(amount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AttackingContract &#123;</span><br><span class=\"line\">\tMyContract myContract;</span><br><span class=\"line\">\taddress attacker;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction AttackingContract(address myContractAddress) public &#123;</span><br><span class=\"line\">\t\tmyContract = MyContract(myContractAddress);</span><br><span class=\"line\">\t\tattacker = msg.sender;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunction() public &#123;</span><br><span class=\"line\">\t\tmyContract.sendTo(attacker, msg.sender.balance);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你应该使用 <code>msg.sender</code> 来授权（如果有另一个合约调用了你的合约，<code>msg.sender</code> 会成为合约的地址，而且不是调用合约的人的地址）。</p>\n<p>更多可见 <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin\" target=\"_blank\" rel=\"noopener\">Solidity 文档</a></p>\n<p>除了授权的这个问题，<code>tx.origin</code> 可能在将来从以太坊协议中移除，所以使用了 <code>tx.origin</code> 的代码在将来不会再被兼容 <a href=\"https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200\" target=\"_blank\" rel=\"noopener\">Vitalik: ‘Do NOT assume that tx.origin will continue to be usable or meaningful.’</a></p>\n<p>另外值得一提的是，通过使用 <code>tx.origin</code>，你会限制合同之间的互操作性，因为使用 <code>tx.origin</code> 的合同不能被另一个合同使用，因为合同不能是 <code>tx.origin</code>。</p>\n<h3 id=\"时间戳依赖\"><a href=\"#时间戳依赖\" class=\"headerlink\" title=\"时间戳依赖\"></a>时间戳依赖</h3><p>在合同中使用时间戳执行关键功能时有三个主要考虑因素，特别是当涉及到资金转移时。</p>\n<h4 id=\"Gameability\"><a href=\"#Gameability\" class=\"headerlink\" title=\"Gameability\"></a>Gameability</h4><p>注意区块的时间戳是可用被矿工操作的。考虑这个<a href=\"https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18#code\" target=\"_blank\" rel=\"noopener\">合约</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 constant private salt = block.timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">function random(uint Max) constant private returns (uint256 result) &#123;</span><br><span class=\"line\">\t//get the best seed for randomness</span><br><span class=\"line\">\tuint256 x = salt * 100/Max;</span><br><span class=\"line\">\tuint256 y = salt * block.number/(salt % 5);</span><br><span class=\"line\">\tuint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;</span><br><span class=\"line\">\tuint256 h = uint256(block.blockhash(seed));</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn uint256((h / x)) % Max + 1; // random number between 1 and Max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当合约使用时间戳来产生随机数时，矿工实际上可以在被验证块的 30 秒内发布时间戳，从而有效地允许矿工预先计算一个更有利于他们抽奖机会的选项。 时间戳不是随机的，不应该在这种情况下使用。</p>\n<h4 id=\"30-秒规则\"><a href=\"#30-秒规则\" class=\"headerlink\" title=\"30 秒规则\"></a>30 秒规则</h4><p>评估时间戳使用的一般经验法则是：</p>\n<p><strong>如果合约功能可以容忍30秒的时间漂移，则可以安全使用 <code>block.timestamp</code></strong></p>\n<p>如果您的时间相关事件的比例可以变化 30 秒并保持完整性，则使用时间戳是安全的。 这包括拍卖结束，注册期限等事情。</p>\n<h4 id=\"将-block-number-作为时间戳使用时要当心\"><a href=\"#将-block-number-作为时间戳使用时要当心\" class=\"headerlink\" title=\"将 block.number 作为时间戳使用时要当心\"></a>将 <code>block.number</code> 作为时间戳使用时要当心</h4><p>当合约创建一个 <code>auction_complete</code> 修饰器来表示代币销售的结束，像<a href=\"https://consensys.github.io/smart-contract-best-practices/(https://github.com/SpankChain/old-sc_auction/blob/master/contracts/Auction.sol\" target=\"_blank\" rel=\"noopener\">这样</a>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier auction_complete &#123;</span><br><span class=\"line\">\trequire(auctionEndBlock &lt;= block.number ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.success ||</span><br><span class=\"line\">\t\tcurrentAuctionState == AuctionState.cancel)</span><br><span class=\"line\">\t\t_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>block.number</code> 和 <a href=\"https://etherscan.io/chart/blocktime\" target=\"_blank\" rel=\"noopener\">平均出块时间</a> 也可以用来估算时间，但是这不是未来的证明，因为区块时间可以修改（例如 <a href=\"https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/\" target=\"_blank\" rel=\"noopener\">分叉重组</a> 和 <a href=\"https://github.com/ethereum/EIPs/issues/649\" target=\"_blank\" rel=\"noopener\">难度炸弹</a>）。在一天的销售中，12分钟规则允许人们构建更可靠的时间估计。</p>\n<h3 id=\"弃用-历史-建议\"><a href=\"#弃用-历史-建议\" class=\"headerlink\" title=\"弃用/历史 建议\"></a>弃用/历史 建议</h3><p>由于协议的修改或者 solidity 的提升，这些建议不再相关。They are recorded here for posterity and awareness.</p>\n<h4 id=\"注意被-0-除-（Solidity-lt-0-4）\"><a href=\"#注意被-0-除-（Solidity-lt-0-4）\" class=\"headerlink\" title=\"注意被 0 除 （Solidity &lt; 0.4）\"></a>注意被 0 除 （Solidity &lt; 0.4）</h4><p>在版本 0.4 之前，当一个数字除以 0 时，Solidity 会返回零，并且不会引发异常。 确保你至少运行 0.4 版本。</p>\n"},{"title":"比特币挖矿之Merkle树","comments":0,"date":"2018-03-02T08:08:16.000Z","img":null,"_content":"\n## Merkle树概念\nMerkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。\n在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。\n\n## Merkle树特点\n1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；\n2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。\n3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。\n\n## 比特币与Merkle树\n根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。\n![](/images/miner.png)\nSPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4->H12->H5656->root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34->H1234->root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。\n\n比特币[最初版本](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868)构建Merkle树的实现代码如下：\n```\nuint256 BuildMerkleTree() const\n{\n    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector<uint256> 结构\n    foreach(const CTransaction& tx, vtx) // 遍历所有交易 vtx是一个vector<CTransaction> 结构 \n\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 \n\tint j = 0;\n    // 构建Merkle树的非叶节点\n    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n\t\t  for (int i = 0; i < nSize; i += 2)\n\t\t  {\n\t\t\t  int i2 = min(i+1, nSize-1);\n              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n\t\t  }\n\t\t  j += nSize;\n\t }\n\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot\n\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n}\n```\n获取[Merkle树分支](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887)的代码如下：\n```\nvector<uint256> GetMerkleBranch(int nIndex) const\n{\n\t    // 判断MerkleTree是否为空，若为空，则重新构建\n\tif (vMerkleTree.empty())\n\t  BuildMerkleTree();\n\t// vMerkleBranch用来保存分支数据\n\tvector<uint256> vMerkleBranch;\n\tint j = 0;\n\t// 填充分支数据\n\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n\t{\n\t\tint i = min(nIndex^1, nSize-1);\n\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);\n\t\tnIndex >>= 1;\n\t\tj += nSize;\n\t}\n\treturn vMerkleBranch;\n}\n```\n","source":"_posts/比特币挖矿之Merkle树.md","raw":"---\ntitle: 比特币挖矿之Merkle树\ncomments: false\ndate: 2018-03-02 16:08:16\ncategories: 矿池 \ntags: \n- LeonBCK \n- 比特币 \n- 矿池\nimg:\n---\n\n## Merkle树概念\nMerkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。\n在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。\n\n## Merkle树特点\n1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；\n2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。\n3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。\n\n## 比特币与Merkle树\n根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。\n![](/images/miner.png)\nSPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4->H12->H5656->root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34->H1234->root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。\n\n比特币[最初版本](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868)构建Merkle树的实现代码如下：\n```\nuint256 BuildMerkleTree() const\n{\n    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector<uint256> 结构\n    foreach(const CTransaction& tx, vtx) // 遍历所有交易 vtx是一个vector<CTransaction> 结构 \n\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 \n\tint j = 0;\n    // 构建Merkle树的非叶节点\n    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n\t\t  for (int i = 0; i < nSize; i += 2)\n\t\t  {\n\t\t\t  int i2 = min(i+1, nSize-1);\n              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n\t\t  }\n\t\t  j += nSize;\n\t }\n\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot\n\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n}\n```\n获取[Merkle树分支](https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887)的代码如下：\n```\nvector<uint256> GetMerkleBranch(int nIndex) const\n{\n\t    // 判断MerkleTree是否为空，若为空，则重新构建\n\tif (vMerkleTree.empty())\n\t  BuildMerkleTree();\n\t// vMerkleBranch用来保存分支数据\n\tvector<uint256> vMerkleBranch;\n\tint j = 0;\n\t// 填充分支数据\n\tfor (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n\t{\n\t\tint i = min(nIndex^1, nSize-1);\n\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);\n\t\tnIndex >>= 1;\n\t\tj += nSize;\n\t}\n\treturn vMerkleBranch;\n}\n```\n","slug":"比特币挖矿之Merkle树","published":1,"updated":"2018-03-07T10:07:30.124Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7h000rl8jxz40rvt8t","content":"<h2 id=\"Merkle树概念\"><a href=\"#Merkle树概念\" class=\"headerlink\" title=\"Merkle树概念\"></a>Merkle树概念</h2><p>Merkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。<br>在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p>\n<h2 id=\"Merkle树特点\"><a href=\"#Merkle树特点\" class=\"headerlink\" title=\"Merkle树特点\"></a>Merkle树特点</h2><p>1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；<br>2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。<br>3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。</p>\n<h2 id=\"比特币与Merkle树\"><a href=\"#比特币与Merkle树\" class=\"headerlink\" title=\"比特币与Merkle树\"></a>比特币与Merkle树</h2><p>根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。<br><img src=\"/images/miner.png\" alt=\"\"><br>SPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4-&gt;H12-&gt;H5656-&gt;root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34-&gt;H1234-&gt;root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。</p>\n<p>比特币<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868\" target=\"_blank\" rel=\"noopener\">最初版本</a>构建Merkle树的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 BuildMerkleTree() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector&lt;uint256&gt; 结构</span><br><span class=\"line\">    foreach(const CTransaction&amp; tx, vtx) // 遍历所有交易 vtx是一个vector&lt;CTransaction&gt; 结构 </span><br><span class=\"line\">\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 </span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">    // 构建Merkle树的非叶节点</span><br><span class=\"line\">    for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">\t\t  for (int i = 0; i &lt; nSize; i += 2)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t  int i2 = min(i+1, nSize-1);</span><br><span class=\"line\">              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),</span><br><span class=\"line\">\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  j += nSize;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot</span><br><span class=\"line\">\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887\" target=\"_blank\" rel=\"noopener\">Merkle树分支</a>的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;uint256&gt; GetMerkleBranch(int nIndex) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t    // 判断MerkleTree是否为空，若为空，则重新构建</span><br><span class=\"line\">\tif (vMerkleTree.empty())</span><br><span class=\"line\">\t  BuildMerkleTree();</span><br><span class=\"line\">\t// vMerkleBranch用来保存分支数据</span><br><span class=\"line\">\tvector&lt;uint256&gt; vMerkleBranch;</span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">\t// 填充分支数据</span><br><span class=\"line\">\tfor (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint i = min(nIndex^1, nSize-1);</span><br><span class=\"line\">\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);</span><br><span class=\"line\">\t\tnIndex &gt;&gt;= 1;</span><br><span class=\"line\">\t\tj += nSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn vMerkleBranch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Merkle树概念\"><a href=\"#Merkle树概念\" class=\"headerlink\" title=\"Merkle树概念\"></a>Merkle树概念</h2><p>Merkle树，通常也被称为Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块的Hash值，非叶子节点是其对应子节点串联字符串的Hash值。<br>在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应的哈希与之对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合成一个字符串，然后运算这个字符串的哈希。如果最底层的哈希总数是单数，那么便将最后一个叶子节点复制一份，以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。</p>\n<h2 id=\"Merkle树特点\"><a href=\"#Merkle树特点\" class=\"headerlink\" title=\"Merkle树特点\"></a>Merkle树特点</h2><p>1、Merkle树是一种树，大多数是二叉树，也可以是多叉树，当然也都具有树结构的所有特点；<br>2、Merkle树的叶子节点的值是数据集合的单元数据或者单元数据的HASH。<br>3、非叶子节点的值是根据它下面所有的叶子节点值，按照Hash算法计算得到的。</p>\n<h2 id=\"比特币与Merkle树\"><a href=\"#比特币与Merkle树\" class=\"headerlink\" title=\"比特币与Merkle树\"></a>比特币与Merkle树</h2><p>根据之前文章对比特币区块头的分析，可以知道比特币区块头中存在一个hashMerkleRoot字段，这儿的hashMerkleRoot便是区块中所有交易构建的Merkle树的树根value，比特币使用Merkle树来归纳一个区块中的所有交易，当某个节点试图修改某个区块中的交易时，交易的Hash值改变，这种改变层层传递，会导致MerkleRoot值改变，进而导致区块头的Hash值改变，这将导致软分叉，要想使这种改变被全网接受，只能通过大算力，使包含该区块的链成为最长链，这种修改的成本无疑是巨大的。由于Merkle树结构的特殊性，通过Merkle树，轻量级节点SPV可以很容易验证交易的存在，下面进行具体介绍。<br><img src=\"/images/miner.png\" alt=\"\"><br>SPV节点不保存所有交易，也不会下载整个区块，仅保存区块头，当需要验证交易时，假设要验证区块图中交易tx3,SPV节点会通过向相邻节点索要Merkle树分支（H4-&gt;H12-&gt;H5656-&gt;root）来确认交易的存在性和正确性。得到了分支数据，SPV节点可以很容易计算出H34-&gt;H1234-&gt;root,通过这种计算得到的root与本地存储的区块头中的hashMerkleRoot字段比较，可以很容易得到验证结果。</p>\n<p>比特币<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L868\" target=\"_blank\" rel=\"noopener\">最初版本</a>构建Merkle树的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint256 BuildMerkleTree() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vMerkleTree.clear(); // 清空Merkle树原有内容 vMerkleTree是一个vector&lt;uint256&gt; 结构</span><br><span class=\"line\">    foreach(const CTransaction&amp; tx, vtx) // 遍历所有交易 vtx是一个vector&lt;CTransaction&gt; 结构 </span><br><span class=\"line\">\t\tvMerkleTree.push_back(tx.GetHash());  // 将交易Hash放入Merkle树，作为叶子节点 </span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">    // 构建Merkle树的非叶节点</span><br><span class=\"line\">    for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">\t\t  for (int i = 0; i &lt; nSize; i += 2)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t  int i2 = min(i+1, nSize-1);</span><br><span class=\"line\">              vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),</span><br><span class=\"line\">\t\t\t  BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  j += nSize;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t// 返回vMerkleTree的最后一个元素，即为MerkleRoot</span><br><span class=\"line\">\treturn (vMerkleTree.empty() ? 0 : vMerkleTree.back());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取<a href=\"https://github.com/trottier/original-bitcoin/blob/92ee8d9a994391d148733da77e2bbc2f4acc43cd/src/main.h#L887\" target=\"_blank\" rel=\"noopener\">Merkle树分支</a>的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;uint256&gt; GetMerkleBranch(int nIndex) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t    // 判断MerkleTree是否为空，若为空，则重新构建</span><br><span class=\"line\">\tif (vMerkleTree.empty())</span><br><span class=\"line\">\t  BuildMerkleTree();</span><br><span class=\"line\">\t// vMerkleBranch用来保存分支数据</span><br><span class=\"line\">\tvector&lt;uint256&gt; vMerkleBranch;</span><br><span class=\"line\">\tint j = 0;</span><br><span class=\"line\">\t// 填充分支数据</span><br><span class=\"line\">\tfor (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint i = min(nIndex^1, nSize-1);</span><br><span class=\"line\">\t\tvMerkleBranch.push_back(vMerkleTree[j+i]);</span><br><span class=\"line\">\t\tnIndex &gt;&gt;= 1;</span><br><span class=\"line\">\t\tj += nSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn vMerkleBranch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"比特币挖矿之全网难度","comments":0,"date":"2018-02-09T04:24:39.000Z","img":null,"_content":"\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 目标值（target）\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<target\n```\n在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。\n``` bash\ntarget = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ntarget = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ntarget = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ntarget =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n### 难度（difficulty）\n难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：\n```\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    if (blockindex == NULL)\n    {\n        if (chainActive.Tip() == NULL)\n            return 1.0;\n        else\n            blockindex = chainActive.Tip();\n    }\n    \n    int nShift = (blockindex->nBits >> 24) & 0xff;\n    \n    double dDiff = (double)0x0000ffff / (double)(blockindex->nBits &0x00ffffff);\n    \n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    \n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}\n```\n创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。\n根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:\n```\ndifficulty = difficulty_1_target/current_target\n```\n其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。\n从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。\n同样以508230区块为例:\n```\ndifficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /\n             0x00000000000000000061e9f80000000000000000000000000000000000000000\n           = 2.87 * 10^12\n           = 2.87 T\n```\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n具体代码实现如下：\n```\nunsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n{\n    if (params.fPowNoRetargeting)\n         return pindexLast->nBits;\n         \n    // Limit adjustment step\n    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n    if (nActualTimespan < params.nPowTargetTimespan/4)\n        nActualTimespan = params.nPowTargetTimespan/4;\n    if (nActualTimespan > params.nPowTargetTimespan*4)\n        nActualTimespan = params.nPowTargetTimespan*4;\n        \n    // Retarget\n    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n    arith_uint256 bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= params.nPowTargetTimespan;\n  \n    if (bnNew > bnPowLimit)\n        bnNew = bnPowLimit;\n                                                                                    \n    return bnNew.GetCompact();\n                                                                                    }\n}\n```\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","source":"_posts/比特币挖矿之全网难度.md","raw":"---\ntitle: 比特币挖矿之全网难度\ncomments: false\ndate: 2018-02-09 12:24:39\ncategories: 矿池\ntags: \n- LeonBCK \n- bitcoin \n- 比特币\nimg:\n---\n\n2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？\n\n### 目标值（target）\n上文中提到，矿工在打包区块的时候，合格的区块应该满足:\n``` bash\nSHA256(SHA256(BlockHeader))<target\n```\n在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。\n``` bash\ntarget = bits_coefficient * 2^(8 * (bits_exponent-3))\n```\n以508230区块为例，此区块对应的bits为0x1761e9f8\n``` bash\ntarget = 0x61e9f8 *2^(0x08*(0x17-3))\n               = 0x61e9f8 *2^(0x08*0x14)\n               = 0x61e9f8 *2^0xA0\n```\n按十进制计算为:\n``` bash\ntarget = 6,416,888 * 2^160\n```\n转换为十六进制后为:\n``` bash\ntarget =0x00000000000000000061e9f80000000000000000000000000000000000000000\n```\n而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。\n\n### 难度（difficulty）\n难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：\n```\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    if (blockindex == NULL)\n    {\n        if (chainActive.Tip() == NULL)\n            return 1.0;\n        else\n            blockindex = chainActive.Tip();\n    }\n    \n    int nShift = (blockindex->nBits >> 24) & 0xff;\n    \n    double dDiff = (double)0x0000ffff / (double)(blockindex->nBits &0x00ffffff);\n    \n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    \n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}\n```\n创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。\n根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:\n```\ndifficulty = difficulty_1_target/current_target\n```\n其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。\n从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。\n同样以508230区块为例:\n```\ndifficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /\n             0x00000000000000000061e9f80000000000000000000000000000000000000000\n           = 2.87 * 10^12\n           = 2.87 T\n```\n\n### 难度调整\n上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？\n\n比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：\n``` bash\nNew Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)\n```\n通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。\n\n在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断\n1、当高度不是2016的倍数时，会直接返回上一个区块的bit\n2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。\n具体代码实现如下：\n```\nunsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n{\n    if (params.fPowNoRetargeting)\n         return pindexLast->nBits;\n         \n    // Limit adjustment step\n    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n    if (nActualTimespan < params.nPowTargetTimespan/4)\n        nActualTimespan = params.nPowTargetTimespan/4;\n    if (nActualTimespan > params.nPowTargetTimespan*4)\n        nActualTimespan = params.nPowTargetTimespan*4;\n        \n    // Retarget\n    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n    arith_uint256 bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= params.nPowTargetTimespan;\n  \n    if (bnNew > bnPowLimit)\n        bnNew = bnPowLimit;\n                                                                                    \n    return bnNew.GetCompact();\n                                                                                    }\n}\n```\n为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。\n\n","slug":"比特币挖矿之全网难度","published":1,"updated":"2018-03-07T10:07:44.779Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7k000vl8jxz5uha1l6","content":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"目标值（target）\"><a href=\"#目标值（target）\" class=\"headerlink\" title=\"目标值（target）\"></a>目标值（target）</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;target</span><br></pre></td></tr></table></figure></p>\n<p>在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<h3 id=\"难度（difficulty）\"><a href=\"#难度（difficulty）\" class=\"headerlink\" title=\"难度（difficulty）\"></a>难度（difficulty）</h3><p>难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double GetDifficulty(const CBlockIndex* blockindex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (blockindex == NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (chainActive.Tip() == NULL)</span><br><span class=\"line\">            return 1.0;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            blockindex = chainActive.Tip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int nShift = (blockindex-&gt;nBits &gt;&gt; 24) &amp; 0xff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double dDiff = (double)0x0000ffff / (double)(blockindex-&gt;nBits &amp;0x00ffffff);</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &lt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff *= 256.0;</span><br><span class=\"line\">        nShift++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &gt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff /= 256.0;</span><br><span class=\"line\">        nShift--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return dDiff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。<br>根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = difficulty_1_target/current_target</span><br></pre></td></tr></table></figure></p>\n<p>其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。<br>从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。<br>同样以508230区块为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class=\"line\">             0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br><span class=\"line\">           = 2.87 * 10^12</span><br><span class=\"line\">           = 2.87 T</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。<br>具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (params.fPowNoRetargeting)</span><br><span class=\"line\">         return pindexLast-&gt;nBits;</span><br><span class=\"line\">         </span><br><span class=\"line\">    // Limit adjustment step</span><br><span class=\"line\">    int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;</span><br><span class=\"line\">    if (nActualTimespan &lt; params.nPowTargetTimespan/4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan/4;</span><br><span class=\"line\">    if (nActualTimespan &gt; params.nPowTargetTimespan*4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan*4;</span><br><span class=\"line\">        </span><br><span class=\"line\">    // Retarget</span><br><span class=\"line\">    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);</span><br><span class=\"line\">    arith_uint256 bnNew;</span><br><span class=\"line\">    bnNew.SetCompact(pindexLast-&gt;nBits);</span><br><span class=\"line\">    bnNew *= nActualTimespan;</span><br><span class=\"line\">    bnNew /= params.nPowTargetTimespan;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (bnNew &gt; bnPowLimit)</span><br><span class=\"line\">        bnNew = bnPowLimit;</span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    return bnNew.GetCompact();</span><br><span class=\"line\">                                                                                    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？</p>\n<h3 id=\"目标值（target）\"><a href=\"#目标值（target）\" class=\"headerlink\" title=\"目标值（target）\"></a>目标值（target）</h3><p>上文中提到，矿工在打包区块的时候，合格的区块应该满足:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(BlockHeader))&lt;target</span><br></pre></td></tr></table></figure></p>\n<p>在比特币系统中，target是使用区块头中的nBits字段来标识的。nBits使用压缩表示机制来存储当前目标值，其中nBits的前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)，nBits可以通过如下运算，得到target。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = bits_coefficient * 2^(8 * (bits_exponent-3))</span><br></pre></td></tr></table></figure></p>\n<p>以508230区块为例，此区块对应的bits为0x1761e9f8<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 0x61e9f8 *2^(0x08*(0x17-3))</span><br><span class=\"line\">               = 0x61e9f8 *2^(0x08*0x14)</span><br><span class=\"line\">               = 0x61e9f8 *2^0xA0</span><br></pre></td></tr></table></figure></p>\n<p>按十进制计算为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = 6,416,888 * 2^160</span><br></pre></td></tr></table></figure></p>\n<p>转换为十六进制后为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target =0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>\n<p>而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。</p>\n<h3 id=\"难度（difficulty）\"><a href=\"#难度（difficulty）\" class=\"headerlink\" title=\"难度（difficulty）\"></a>难度（difficulty）</h3><p>难度（difficulty）是对挖矿困难程度的度量，创世区块的difficulty为1。需要注意的是，difficulty并没有记录在区块头中，而是通过nBits计算得到的。具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double GetDifficulty(const CBlockIndex* blockindex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (blockindex == NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (chainActive.Tip() == NULL)</span><br><span class=\"line\">            return 1.0;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            blockindex = chainActive.Tip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int nShift = (blockindex-&gt;nBits &gt;&gt; 24) &amp; 0xff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double dDiff = (double)0x0000ffff / (double)(blockindex-&gt;nBits &amp;0x00ffffff);</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &lt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff *= 256.0;</span><br><span class=\"line\">        nShift++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (nShift &gt; 29)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dDiff /= 256.0;</span><br><span class=\"line\">        nShift--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return dDiff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创世区块的bits值为0x1d00ffff，代入上述方法中，nShift=29,dDiff=1,可得创世区块的difficulty为1。<br>根据上面目标值target的计算公式可得创世区块的target为:0x00000000ffff0000000000000000000000000000000000000000000000000000。根据难度调整机制（参见下文），我们可以知道，高度为1的区块的target也为0x00000000ffff0000000000000000000000000000000000000000000000000000，也就是说，为了构建出高度为1的合法区块，矿工需要不断对区块头做双SHA256运算，直到找到一个区块头的Hash值的前32位均为0，而SHA256运算结果在某一位上的值可以认为是随机的，也就是平均要做2^32次运算，才能找到问题的解。上述GetDifficulty方法表现的nBits与Difficulty的关系可转化为target与Difficulty:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = difficulty_1_target/current_target</span><br></pre></td></tr></table></figure></p>\n<p>其中difficulty表示最新区块的挖矿难度，difficulty_1_target表示难度为1的区块的目标值，也可以理解为创世区块的目标值，current_target表示最新区块的目标值。<br>从上述公式我们可以看出，难度与目标值成反比关系，目标值越小，难度越大，矿工平均需要运算的次数也就越大。<br>同样以508230区块为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difficulty = 0x00000000FFFF0000000000000000000000000000000000000000000000000000 /</span><br><span class=\"line\">             0x00000000000000000061e9f80000000000000000000000000000000000000000</span><br><span class=\"line\">           = 2.87 * 10^12</span><br><span class=\"line\">           = 2.87 T</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"难度调整\"><a href=\"#难度调整\" class=\"headerlink\" title=\"难度调整\"></a>难度调整</h3><p>上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？</p>\n<p>比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式可表示如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</span><br></pre></td></tr></table></figure></p>\n<p>通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。</p>\n<p>在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断<br>1、当高度不是2016的倍数时，会直接返回上一个区块的bit<br>2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。<br>具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (params.fPowNoRetargeting)</span><br><span class=\"line\">         return pindexLast-&gt;nBits;</span><br><span class=\"line\">         </span><br><span class=\"line\">    // Limit adjustment step</span><br><span class=\"line\">    int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;</span><br><span class=\"line\">    if (nActualTimespan &lt; params.nPowTargetTimespan/4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan/4;</span><br><span class=\"line\">    if (nActualTimespan &gt; params.nPowTargetTimespan*4)</span><br><span class=\"line\">        nActualTimespan = params.nPowTargetTimespan*4;</span><br><span class=\"line\">        </span><br><span class=\"line\">    // Retarget</span><br><span class=\"line\">    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);</span><br><span class=\"line\">    arith_uint256 bnNew;</span><br><span class=\"line\">    bnNew.SetCompact(pindexLast-&gt;nBits);</span><br><span class=\"line\">    bnNew *= nActualTimespan;</span><br><span class=\"line\">    bnNew /= params.nPowTargetTimespan;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (bnNew &gt; bnPowLimit)</span><br><span class=\"line\">        bnNew = bnPowLimit;</span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    return bnNew.GetCompact();</span><br><span class=\"line\">                                                                                    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。</p>\n"},{"title":"比特币挖矿之矿工任务","comments":0,"date":"2018-02-28T03:10:09.000Z","img":null,"_content":"\n## 挖矿介绍\n中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿\"，而进行挖矿的人则被称为\"矿工\"。\n\n## 矿工任务\n考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：\n1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。\n2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。\n3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。\n4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。\n5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。\n\n## 区块头BlockHeader\n挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：\n```\nint32_t nVersion;            //版本号，4字节\nuint256 hashPrevBlock;       //前一个区块的hash值，32字节\nuint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节\nuint32_t nTime;              //Uinx时间戳，4字节\nuint32_t nBits;              //难度的压缩表示，4字节\nuint32_t nNonce;             //随机数，4字节\n```\n比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：\n```\nSHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))<F(nBits)\n```\n关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。\n","source":"_posts/比特币挖矿之矿工任务-1.md","raw":"---\ntitle: 比特币挖矿之矿工任务\ncomments: false\ndate: 2018-02-28 11:10:09\ncategories: 矿池\ntags: \n- LeonBCK \n- 矿池 \nimg:\n---\n\n## 挖矿介绍\n中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿\"，而进行挖矿的人则被称为\"矿工\"。\n\n## 矿工任务\n考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：\n1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。\n2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。\n3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。\n4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。\n5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。\n\n## 区块头BlockHeader\n挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：\n```\nint32_t nVersion;            //版本号，4字节\nuint256 hashPrevBlock;       //前一个区块的hash值，32字节\nuint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节\nuint32_t nTime;              //Uinx时间戳，4字节\nuint32_t nBits;              //难度的压缩表示，4字节\nuint32_t nNonce;             //随机数，4字节\n```\n比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：\n```\nSHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))<F(nBits)\n```\n关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。\n","slug":"比特币挖矿之矿工任务-1","published":1,"updated":"2018-03-07T10:07:58.762Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7n000yl8jxrvsktl0x","content":"<h2 id=\"挖矿介绍\"><a href=\"#挖矿介绍\" class=\"headerlink\" title=\"挖矿介绍\"></a>挖矿介绍</h2><p>中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。</p>\n<h2 id=\"矿工任务\"><a href=\"#矿工任务\" class=\"headerlink\" title=\"矿工任务\"></a>矿工任务</h2><p>考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：<br>1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。<br>2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。<br>3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。<br>4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。<br>5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。</p>\n<h2 id=\"区块头BlockHeader\"><a href=\"#区块头BlockHeader\" class=\"headerlink\" title=\"区块头BlockHeader\"></a>区块头BlockHeader</h2><p>挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int32_t nVersion;            //版本号，4字节</span><br><span class=\"line\">uint256 hashPrevBlock;       //前一个区块的hash值，32字节</span><br><span class=\"line\">uint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节</span><br><span class=\"line\">uint32_t nTime;              //Uinx时间戳，4字节</span><br><span class=\"line\">uint32_t nBits;              //难度的压缩表示，4字节</span><br><span class=\"line\">uint32_t nNonce;             //随机数，4字节</span><br></pre></td></tr></table></figure></p>\n<p>比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"挖矿介绍\"><a href=\"#挖矿介绍\" class=\"headerlink\" title=\"挖矿介绍\"></a>挖矿介绍</h2><p>中本聪为了实现比特币的去中心化，引入了工作量证明机制(proof of work)。工作量证明的理念是把随机选取节点记账改为根据算力来选取节点，任何一个提议并创建区块的节点要想构建下一个区块，必须找到一个解，当把这个解与前区块的哈希值、当前时间戳、区块包含交易集合唯一标识MerkleRoot等组装起来，带入哈希函数时，刚好小于指定的目标值，这一系列操作就称为“挖矿”，而进行挖矿的人则被称为”矿工”。</p>\n<h2 id=\"矿工任务\"><a href=\"#矿工任务\" class=\"headerlink\" title=\"矿工任务\"></a>矿工任务</h2><p>考虑到矿工记账的积极性，中本聪在比特币系统中，设计了两种奖励，一是区块奖励，初始为每挖到一个区块奖励50个比特币，每四年递减一次，到2040年左右发放完毕，总量约为2100万个，而这也是比特币系统产生新币的唯一来源。二是交易手续费，区块中所包含交易的所有交易手续费都归成功打包该区块的矿工所得，交易手续费的重要性随着区块奖励的减少会逐渐提升，最终完全取代区块奖励，成为比特币系统刺激矿工挖矿的唯一物质激励。那么矿工作为淘金者，都需要做哪些工作呢？要想成为比特币矿工，首先要加入比特币网络并与其他节点相连，建立连接后，还有如下任务要完成：<br>1、同步区块链已有数据，监听新区块。比特币系统默认最长链作为系统主链，因此只有在已有最长链的基础上打包区块，才可能得到大家的认可。<br>2、监听交易广播。监听网络上的交易广播，验证交易签名是否有效，是否存在双花，付款地址有没有足够的余额，验证通过，放入交易池。<br>3、构建coinbase交易，组装新区块。coinbase交易为矿工自行构建，用以接收挖矿奖励。矿工应以全网最长链上的最后一个区块为基础构建新区块。<br>4、找到让区块满足要求的随机数。工作量证明就体现在这一步，最为耗时。<br>5、广播新区块。为了获得区块奖励和交易手续费，矿工在成功打包新区块后，会在第一时间向全网广播，因为网络延迟，所以存在相近时间不同矿工成功打包出不同区块的情况，这时便会出现软分叉，只有被大部分矿工所接受，新区块才算真正加入区块链。</p>\n<h2 id=\"区块头BlockHeader\"><a href=\"#区块头BlockHeader\" class=\"headerlink\" title=\"区块头BlockHeader\"></a>区块头BlockHeader</h2><p>挖矿的本质是执行Hash函数，而Hash函数是一个单向函数，一个输入对应一个输出，根据输入可以很容易计算出输出，但根据输出无法逆推出输入。当输出小于目标值值，便可认为一次挖矿成功，而这里输入数据就是区块头。比特币的区块头有如下6个字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int32_t nVersion;            //版本号，4字节</span><br><span class=\"line\">uint256 hashPrevBlock;       //前一个区块的hash值，32字节</span><br><span class=\"line\">uint256 hashMerkleRoot;      //根据区块所包含交易构建的Merkle树根，32字节</span><br><span class=\"line\">uint32_t nTime;              //Uinx时间戳，4字节</span><br><span class=\"line\">uint32_t nBits;              //难度的压缩表示，4字节</span><br><span class=\"line\">uint32_t nNonce;             //随机数，4字节</span><br></pre></td></tr></table></figure></p>\n<p>比特币挖矿就是对区块头的80个字节进行两次SHA256运算，得到32字节的数据，使之满足nBits转化出来的目标值。可用如下公式表示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHA256(SHA256(nVersion+hashPrevBlock+hashMerkleRoot+nTime+nBits+nNonce))&lt;F(nBits)</span><br></pre></td></tr></table></figure></p>\n<p>关于区块头BlockHeader各字段的具体含义将在接下来的文章具体介绍。</p>\n"},{"title":"比特币挖矿之随机数","comments":0,"date":"2018-03-02T08:11:51.000Z","img":null,"_content":"\n## 比特币区块头字段分析\n在[比特币挖矿之矿工任务](https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示[nBits](https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。\n\n## 随机数调整\n比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。\n[构建区块头函数](https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106)\n```\nUniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n{\n\t// 内循环次数上限 nNonce的调整空间[0,2^16)\n\tstatic const int nInnerLoopCount = 0x10000;\n\tint nHeightEnd = 0;\n\tint nHeight = 0;\n\n\t{   // Don't keep cs_main locked\n\t\tLOCK(cs_main);\n\t\t// 区块当前高度\n\t\tnHeight = chainActive.Height();\n\t\t// 待生成区块高度\n\t\tnHeightEnd = nHeight+nGenerate;\n\t}\n\t// nExtraNonce 为CoinBase交易输入部分\n\tunsigned int nExtraNonce = 0;\n\tUniValue blockHashes(UniValue::VARR);\n\t// 循环生成区块，直到达到指定高度\n\twhile (nHeight < nHeightEnd)\n\t{\n\t\t// 创建区块模板\n\t\tstd::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n\t\tif (!pblocktemplate.get())\n\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n\t\t// pblock 待构建区块\n\t\tCBlock *pblock = &pblocktemplate->block;\n\t\t{\n\t\t\tLOCK(cs_main);\n\t\t\t// 调整CoinBase输入脚本中的nExtranNonce\n\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n\t\t}\n\t\t// pblock->nNonce < nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount\n\t\t// CheckProofOfWork(pblock->GetHash(),pblock->nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求\n\t\twhile (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount &&!CheckProofOfWork(pblock->GetHash(), pblock->nBits,Params().GetConsensus())) {\n\t\t\t// nNonce++\n\t\t\t++pblock->nNonce;\n\t\t\t--nMaxTries;\n\t\t}\n\t\t// 超过最大尝试次数，退出循环\n\t\tif (nMaxTries == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环\n\t\tif (pblock->nNonce == nInnerLoopCount) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n\t\t// 处理挖到的区块\n\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n\t\t++nHeight;\n\t\t// 存放区块头Hash\n\t\tblockHashes.push_back(pblock->GetHash().GetHex());\n\n\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet\n\t\tif (keepScript)\n\t\t{\n\t\t\tcoinbaseScript->KeepScript();\n\t\t}\n\t}\n\treturn blockHashes;\n}\n```\n[校验工作量函数](https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74)\n```\nbool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n{\n\tbool fNegative;\n\tbool fOverflow;\n\tarith_uint256 bnTarget;\n\n\tbnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n\n\t// Check range\n\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n\t  return false;\n\n\t// Check proof of work matches claimed amount\n\t// 比较区块头hash值是否满足目标值\n\tif (UintToArith256(hash) > bnTarget)\n\t    return false;\n\n\treturn true;\n}\n```\n[调整CoinBase输入字段函数](https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442)\n```\nvoid IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int& nExtraNonce)\n{\n\t// Update nExtraNonce\n\tstatic uint256 hashPrevBlock;\n\tif (hashPrevBlock != pblock->hashPrevBlock)\n\t{\n\t\tnExtraNonce = 0;\n\t\thashPrevBlock = pblock->hashPrevBlock;\n\t}\n\t// nExtranNonce调整\n\t++nExtraNonce;\n\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头\n\tunsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n\tCMutableTransaction txCoinbase(*pblock->vtx[0]);\n\t// 构建coinbase交易的输入脚本\n\ttxCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n\tassert(txCoinbase.vin[0].scriptSig.size() <= 100);\n\n\tpblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n\t// 重新构建Merkle数，计算MerkleRoot\n\tpblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n}\n```\n","source":"_posts/比特币挖矿之随机数.md","raw":"---\ntitle: 比特币挖矿之随机数\ncomments: false\ndate: 2018-03-02 16:11:51\ncategories: 矿池\ntags: \n- LeonBCK \n- 比特币 \n- 矿池\nimg:\n---\n\n## 比特币区块头字段分析\n在[比特币挖矿之矿工任务](https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/)中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示[nBits](https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/)由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。\n\n## 随机数调整\n比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。\n[构建区块头函数](https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106)\n```\nUniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n{\n\t// 内循环次数上限 nNonce的调整空间[0,2^16)\n\tstatic const int nInnerLoopCount = 0x10000;\n\tint nHeightEnd = 0;\n\tint nHeight = 0;\n\n\t{   // Don't keep cs_main locked\n\t\tLOCK(cs_main);\n\t\t// 区块当前高度\n\t\tnHeight = chainActive.Height();\n\t\t// 待生成区块高度\n\t\tnHeightEnd = nHeight+nGenerate;\n\t}\n\t// nExtraNonce 为CoinBase交易输入部分\n\tunsigned int nExtraNonce = 0;\n\tUniValue blockHashes(UniValue::VARR);\n\t// 循环生成区块，直到达到指定高度\n\twhile (nHeight < nHeightEnd)\n\t{\n\t\t// 创建区块模板\n\t\tstd::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n\t\tif (!pblocktemplate.get())\n\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n\t\t// pblock 待构建区块\n\t\tCBlock *pblock = &pblocktemplate->block;\n\t\t{\n\t\t\tLOCK(cs_main);\n\t\t\t// 调整CoinBase输入脚本中的nExtranNonce\n\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n\t\t}\n\t\t// pblock->nNonce < nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount\n\t\t// CheckProofOfWork(pblock->GetHash(),pblock->nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求\n\t\twhile (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount &&!CheckProofOfWork(pblock->GetHash(), pblock->nBits,Params().GetConsensus())) {\n\t\t\t// nNonce++\n\t\t\t++pblock->nNonce;\n\t\t\t--nMaxTries;\n\t\t}\n\t\t// 超过最大尝试次数，退出循环\n\t\tif (nMaxTries == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环\n\t\tif (pblock->nNonce == nInnerLoopCount) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n\t\t// 处理挖到的区块\n\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n\t\t++nHeight;\n\t\t// 存放区块头Hash\n\t\tblockHashes.push_back(pblock->GetHash().GetHex());\n\n\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet\n\t\tif (keepScript)\n\t\t{\n\t\t\tcoinbaseScript->KeepScript();\n\t\t}\n\t}\n\treturn blockHashes;\n}\n```\n[校验工作量函数](https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74)\n```\nbool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n{\n\tbool fNegative;\n\tbool fOverflow;\n\tarith_uint256 bnTarget;\n\n\tbnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n\n\t// Check range\n\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n\t  return false;\n\n\t// Check proof of work matches claimed amount\n\t// 比较区块头hash值是否满足目标值\n\tif (UintToArith256(hash) > bnTarget)\n\t    return false;\n\n\treturn true;\n}\n```\n[调整CoinBase输入字段函数](https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442)\n```\nvoid IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int& nExtraNonce)\n{\n\t// Update nExtraNonce\n\tstatic uint256 hashPrevBlock;\n\tif (hashPrevBlock != pblock->hashPrevBlock)\n\t{\n\t\tnExtraNonce = 0;\n\t\thashPrevBlock = pblock->hashPrevBlock;\n\t}\n\t// nExtranNonce调整\n\t++nExtraNonce;\n\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头\n\tunsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n\tCMutableTransaction txCoinbase(*pblock->vtx[0]);\n\t// 构建coinbase交易的输入脚本\n\ttxCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n\tassert(txCoinbase.vin[0].scriptSig.size() <= 100);\n\n\tpblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n\t// 重新构建Merkle数，计算MerkleRoot\n\tpblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n}\n```\n","slug":"比特币挖矿之随机数","published":1,"updated":"2018-03-07T10:08:12.969Z","layout":"post","photos":[],"link":"","_id":"cjejlcu7s0013l8jx8uuk5b59","content":"<h2 id=\"比特币区块头字段分析\"><a href=\"#比特币区块头字段分析\" class=\"headerlink\" title=\"比特币区块头字段分析\"></a>比特币区块头字段分析</h2><p>在<a href=\"https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示<a href=\"https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">nBits</a>由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。</p>\n<h2 id=\"随机数调整\"><a href=\"#随机数调整\" class=\"headerlink\" title=\"随机数调整\"></a>随机数调整</h2><p>比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106\" target=\"_blank\" rel=\"noopener\">构建区块头函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 内循环次数上限 nNonce的调整空间[0,2^16)</span><br><span class=\"line\">\tstatic const int nInnerLoopCount = 0x10000;</span><br><span class=\"line\">\tint nHeightEnd = 0;</span><br><span class=\"line\">\tint nHeight = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;   // Don&apos;t keep cs_main locked</span><br><span class=\"line\">\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t// 区块当前高度</span><br><span class=\"line\">\t\tnHeight = chainActive.Height();</span><br><span class=\"line\">\t\t// 待生成区块高度</span><br><span class=\"line\">\t\tnHeightEnd = nHeight+nGenerate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtraNonce 为CoinBase交易输入部分</span><br><span class=\"line\">\tunsigned int nExtraNonce = 0;</span><br><span class=\"line\">\tUniValue blockHashes(UniValue::VARR);</span><br><span class=\"line\">\t// 循环生成区块，直到达到指定高度</span><br><span class=\"line\">\twhile (nHeight &lt; nHeightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 创建区块模板</span><br><span class=\"line\">\t\tstd::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript));</span><br><span class=\"line\">\t\tif (!pblocktemplate.get())</span><br><span class=\"line\">\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&apos;t create new block&quot;);</span><br><span class=\"line\">\t\t// pblock 待构建区块</span><br><span class=\"line\">\t\tCBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t\t// 调整CoinBase输入脚本中的nExtranNonce</span><br><span class=\"line\">\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// pblock-&gt;nNonce &lt; nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount</span><br><span class=\"line\">\t\t// CheckProofOfWork(pblock-&gt;GetHash(),pblock-&gt;nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求</span><br><span class=\"line\">\t\twhile (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp;!CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits,Params().GetConsensus())) &#123;</span><br><span class=\"line\">\t\t\t// nNonce++</span><br><span class=\"line\">\t\t\t++pblock-&gt;nNonce;</span><br><span class=\"line\">\t\t\t--nMaxTries;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 超过最大尝试次数，退出循环</span><br><span class=\"line\">\t\tif (nMaxTries == 0) &#123;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环</span><br><span class=\"line\">\t\tif (pblock-&gt;nNonce == nInnerLoopCount) &#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock);</span><br><span class=\"line\">\t\t// 处理挖到的区块</span><br><span class=\"line\">\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))</span><br><span class=\"line\">\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;);</span><br><span class=\"line\">\t\t++nHeight;</span><br><span class=\"line\">\t\t// 存放区块头Hash</span><br><span class=\"line\">\t\tblockHashes.push_back(pblock-&gt;GetHash().GetHex());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet</span><br><span class=\"line\">\t\tif (keepScript)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcoinbaseScript-&gt;KeepScript();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn blockHashes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74\" target=\"_blank\" rel=\"noopener\">校验工作量函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbool fNegative;</span><br><span class=\"line\">\tbool fOverflow;</span><br><span class=\"line\">\tarith_uint256 bnTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbnTarget.SetCompact(nBits, &amp;fNegative, &amp;fOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check range</span><br><span class=\"line\">\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget &gt; UintToArith256(params.powLimit))</span><br><span class=\"line\">\t  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check proof of work matches claimed amount</span><br><span class=\"line\">\t// 比较区块头hash值是否满足目标值</span><br><span class=\"line\">\tif (UintToArith256(hash) &gt; bnTarget)</span><br><span class=\"line\">\t    return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442\" target=\"_blank\" rel=\"noopener\">调整CoinBase输入字段函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int&amp; nExtraNonce)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// Update nExtraNonce</span><br><span class=\"line\">\tstatic uint256 hashPrevBlock;</span><br><span class=\"line\">\tif (hashPrevBlock != pblock-&gt;hashPrevBlock)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnExtraNonce = 0;</span><br><span class=\"line\">\t\thashPrevBlock = pblock-&gt;hashPrevBlock;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtranNonce调整</span><br><span class=\"line\">\t++nExtraNonce;</span><br><span class=\"line\">\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头</span><br><span class=\"line\">\tunsigned int nHeight = pindexPrev-&gt;nHeight+1; // Height first in coinbase required for block.version=2</span><br><span class=\"line\">\tCMutableTransaction txCoinbase(*pblock-&gt;vtx[0]);</span><br><span class=\"line\">\t// 构建coinbase交易的输入脚本</span><br><span class=\"line\">\ttxCoinbase.vin[0].scriptSig = (CScript() &lt;&lt; nHeight &lt;&lt; CScriptNum(nExtraNonce)) + COINBASE_FLAGS;</span><br><span class=\"line\">\tassert(txCoinbase.vin[0].scriptSig.size() &lt;= 100);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpblock-&gt;vtx[0] = MakeTransactionRef(std::move(txCoinbase));</span><br><span class=\"line\">\t// 重新构建Merkle数，计算MerkleRoot</span><br><span class=\"line\">\tpblock-&gt;hashMerkleRoot = BlockMerkleRoot(*pblock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"比特币区块头字段分析\"><a href=\"#比特币区块头字段分析\" class=\"headerlink\" title=\"比特币区块头字段分析\"></a>比特币区块头字段分析</h2><p>在<a href=\"https://xingyunbite.github.io/2018/02/28/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E7%9F%BF%E5%B7%A5%E4%BB%BB%E5%8A%A1-1/\" target=\"_blank\" rel=\"noopener\">比特币挖矿之矿工任务</a>中已经提到矿工的工作量主要就消耗在寻找使区块满足要求的随机数这一步。在比特币区块头的6个字段中，区块版本号nVersion只有在升级的时候才会改变。上一个区块Hash值hashPrevBlock在矿工不想制造软分叉的情况下，由最长链的最后一个区块决定。全网难度压缩表示<a href=\"https://xingyunbite.github.io/2018/02/09/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B9%8B%E5%85%A8%E7%BD%91%E9%9A%BE%E5%BA%A6/\" target=\"_blank\" rel=\"noopener\">nBits</a>由全网决定,每2016个区块重新调整一次，调整算法固定。上述三个字段对于每个矿工来说，可以理解为固定的。随机数nNonce即我们要找的解，因其字段大小为4字节，32位，因此存在2^32种可能。打包时间nTime可调整的范围根据前一个区块时间来决定，比上一个区块太超前或者太落后会被其他节点拒绝，一般情况下，矿工会直接使用机器当前时间戳。Merkle树根hashMerkleRoot，因其字段长度为256位，理论上存在2^256种可能，本字段的变化主要在于修改CoinBase交易的输入字段，CoinBase交易的改变会传导到至hashMerkleRoot。根据Hash函数特性，nNonce、nTime、hashMerkleRoot任意改变一个，都会导致区块头Hash值结果产生巨大变化。</p>\n<h2 id=\"随机数调整\"><a href=\"#随机数调整\" class=\"headerlink\" title=\"随机数调整\"></a>随机数调整</h2><p>比特币挖矿的修改主要是体现在调整随机数nNonce上，但是随着算力的不断增长，2^32的调整空间已经很难满足求解的需要，因此比特币采取的处理方式是当遍历完2^32个随机数空间后，调整CoinBase的输入字段，致使hashMerkleRoot改变，再次遍历随机数空间，直到发现满足要求的解为止。当然正常情况下，矿工无法遍历完所有的调整空间(2^256 * 2^32)。下面主要以分析代码的方式展示随机数的调整机制。<br><a href=\"https://github.com/bitcoin/bitcoin/blob/fd65937ec601326b479654a5ad14847adcdb214c/src/rpc/mining.cpp#L106\" target=\"_blank\" rel=\"noopener\">构建区块头函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 内循环次数上限 nNonce的调整空间[0,2^16)</span><br><span class=\"line\">\tstatic const int nInnerLoopCount = 0x10000;</span><br><span class=\"line\">\tint nHeightEnd = 0;</span><br><span class=\"line\">\tint nHeight = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;   // Don&apos;t keep cs_main locked</span><br><span class=\"line\">\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t// 区块当前高度</span><br><span class=\"line\">\t\tnHeight = chainActive.Height();</span><br><span class=\"line\">\t\t// 待生成区块高度</span><br><span class=\"line\">\t\tnHeightEnd = nHeight+nGenerate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtraNonce 为CoinBase交易输入部分</span><br><span class=\"line\">\tunsigned int nExtraNonce = 0;</span><br><span class=\"line\">\tUniValue blockHashes(UniValue::VARR);</span><br><span class=\"line\">\t// 循环生成区块，直到达到指定高度</span><br><span class=\"line\">\twhile (nHeight &lt; nHeightEnd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 创建区块模板</span><br><span class=\"line\">\t\tstd::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript));</span><br><span class=\"line\">\t\tif (!pblocktemplate.get())</span><br><span class=\"line\">\t\t  throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&apos;t create new block&quot;);</span><br><span class=\"line\">\t\t// pblock 待构建区块</span><br><span class=\"line\">\t\tCBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLOCK(cs_main);</span><br><span class=\"line\">\t\t\t// 调整CoinBase输入脚本中的nExtranNonce</span><br><span class=\"line\">\t\t\tIncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// pblock-&gt;nNonce &lt; nInnerLoopCount 区块头随机数调整次数不能超过nInnerLooCount</span><br><span class=\"line\">\t\t// CheckProofOfWork(pblock-&gt;GetHash(),pblock-&gt;nBits,Params().GetConsensus()) 校验当前区块头Hash值是否满足要求</span><br><span class=\"line\">\t\twhile (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp;!CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits,Params().GetConsensus())) &#123;</span><br><span class=\"line\">\t\t\t// nNonce++</span><br><span class=\"line\">\t\t\t++pblock-&gt;nNonce;</span><br><span class=\"line\">\t\t\t--nMaxTries;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 超过最大尝试次数，退出循环</span><br><span class=\"line\">\t\tif (nMaxTries == 0) &#123;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 达到内循环次数上限，调整CoinBase交易的nExtraNonce，重新开始循环</span><br><span class=\"line\">\t\tif (pblock-&gt;nNonce == nInnerLoopCount) &#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock);</span><br><span class=\"line\">\t\t// 处理挖到的区块</span><br><span class=\"line\">\t\tif (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))</span><br><span class=\"line\">\t\t    throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;);</span><br><span class=\"line\">\t\t++nHeight;</span><br><span class=\"line\">\t\t// 存放区块头Hash</span><br><span class=\"line\">\t\tblockHashes.push_back(pblock-&gt;GetHash().GetHex());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//mark script as important because it was used at least for one coinbase output if the script came from the wallet</span><br><span class=\"line\">\t\tif (keepScript)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcoinbaseScript-&gt;KeepScript();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn blockHashes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/pow.cpp#L74\" target=\"_blank\" rel=\"noopener\">校验工作量函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&amp; params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbool fNegative;</span><br><span class=\"line\">\tbool fOverflow;</span><br><span class=\"line\">\tarith_uint256 bnTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbnTarget.SetCompact(nBits, &amp;fNegative, &amp;fOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check range</span><br><span class=\"line\">\tif (fNegative || bnTarget == 0 || fOverflow || bnTarget &gt; UintToArith256(params.powLimit))</span><br><span class=\"line\">\t  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Check proof of work matches claimed amount</span><br><span class=\"line\">\t// 比较区块头hash值是否满足目标值</span><br><span class=\"line\">\tif (UintToArith256(hash) &gt; bnTarget)</span><br><span class=\"line\">\t    return false;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/44080a90a29292df96e92f22242785c5040000a1/src/miner.cpp#L442\" target=\"_blank\" rel=\"noopener\">调整CoinBase输入字段函数</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev,unsigned int&amp; nExtraNonce)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// Update nExtraNonce</span><br><span class=\"line\">\tstatic uint256 hashPrevBlock;</span><br><span class=\"line\">\tif (hashPrevBlock != pblock-&gt;hashPrevBlock)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnExtraNonce = 0;</span><br><span class=\"line\">\t\thashPrevBlock = pblock-&gt;hashPrevBlock;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// nExtranNonce调整</span><br><span class=\"line\">\t++nExtraNonce;</span><br><span class=\"line\">\t// 正在打包的区块高度从版本2开始，要求coinbase交易的输入脚本以本区块高度开头</span><br><span class=\"line\">\tunsigned int nHeight = pindexPrev-&gt;nHeight+1; // Height first in coinbase required for block.version=2</span><br><span class=\"line\">\tCMutableTransaction txCoinbase(*pblock-&gt;vtx[0]);</span><br><span class=\"line\">\t// 构建coinbase交易的输入脚本</span><br><span class=\"line\">\ttxCoinbase.vin[0].scriptSig = (CScript() &lt;&lt; nHeight &lt;&lt; CScriptNum(nExtraNonce)) + COINBASE_FLAGS;</span><br><span class=\"line\">\tassert(txCoinbase.vin[0].scriptSig.size() &lt;= 100);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpblock-&gt;vtx[0] = MakeTransactionRef(std::move(txCoinbase));</span><br><span class=\"line\">\t// 重新构建Merkle数，计算MerkleRoot</span><br><span class=\"line\">\tpblock-&gt;hashMerkleRoot = BlockMerkleRoot(*pblock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjejlcu5n0000l8jxjkocz38r","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu6o000cl8jxsvtz4hee"},{"post_id":"cjejlcu5w0001l8jxjxa784hv","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu75000il8jxb1ps0j5v"},{"post_id":"cjejlcu650004l8jx97foepq8","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu7d000nl8jxuvu2ux4l"},{"post_id":"cjejlcu7a000ll8jxs52zonmm","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7i000sl8jxnhxavbiq"},{"post_id":"cjejlcu690005l8jxlf1sgrrx","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7m000wl8jxhalm6tsy"},{"post_id":"cjejlcu7c000ml8jxtpymxerh","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7o000zl8jx6ofu8hnx"},{"post_id":"cjejlcu7f000ql8jxwoovofx8","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7u0014l8jx5adi4ce4"},{"post_id":"cjejlcu6c0006l8jxtq0dq8q5","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7v0016l8jxpi13mn4l"},{"post_id":"cjejlcu7h000rl8jxz40rvt8t","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu7x0019l8jxx31e4un5"},{"post_id":"cjejlcu7k000vl8jxz5uha1l6","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu7y001al8jxc5eno4sf"},{"post_id":"cjejlcu6i0009l8jxivdky4cf","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu7z001dl8jxxva3l7u1"},{"post_id":"cjejlcu7n000yl8jxrvsktl0x","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu81001fl8jx86kahtk0"},{"post_id":"cjejlcu7s0013l8jx8uuk5b59","category_id":"cjejlcu600002l8jxzbs776fa","_id":"cjejlcu81001hl8jxa6d4nm8y"},{"post_id":"cjejlcu6m000al8jxsoy8kfkv","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu83001kl8jx37uru923"},{"post_id":"cjejlcu6w000el8jxigjvplbr","category_id":"cjejlcu70000hl8jxnbzz2w9f","_id":"cjejlcu84001ll8jxbul28oma"},{"post_id":"cjejlcu6z000gl8jxzwhcu9yj","category_id":"cjejlcu7z001bl8jx0yrlvndo","_id":"cjejlcu85001nl8jxqx2ph48m"}],"PostTag":[{"post_id":"cjejlcu5n0000l8jxjkocz38r","tag_id":"cjejlcu640003l8jx3dst6vvt","_id":"cjejlcu6y000fl8jx0s012fqt"},{"post_id":"cjejlcu5n0000l8jxjkocz38r","tag_id":"cjejlcu6e0008l8jxm03463a9","_id":"cjejlcu75000jl8jxybzuispe"},{"post_id":"cjejlcu5w0001l8jxjxa784hv","tag_id":"cjejlcu640003l8jx3dst6vvt","_id":"cjejlcu7m000xl8jxo1x3fsge"},{"post_id":"cjejlcu5w0001l8jxjxa784hv","tag_id":"cjejlcu76000kl8jxf2poeoyu","_id":"cjejlcu7r0011l8jxqtfks3l6"},{"post_id":"cjejlcu5w0001l8jxjxa784hv","tag_id":"cjejlcu7e000pl8jxx66bcbj6","_id":"cjejlcu7v0015l8jxj27lxja0"},{"post_id":"cjejlcu650004l8jx97foepq8","tag_id":"cjejlcu640003l8jx3dst6vvt","_id":"cjejlcu80001el8jxrysv3y0z"},{"post_id":"cjejlcu650004l8jx97foepq8","tag_id":"cjejlcu7e000pl8jxx66bcbj6","_id":"cjejlcu81001gl8jxeceib5rd"},{"post_id":"cjejlcu650004l8jx97foepq8","tag_id":"cjejlcu76000kl8jxf2poeoyu","_id":"cjejlcu83001jl8jxt925jsju"},{"post_id":"cjejlcu690005l8jxlf1sgrrx","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu87001pl8jx5i1xyjp2"},{"post_id":"cjejlcu690005l8jxlf1sgrrx","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu87001ql8jxmmente0a"},{"post_id":"cjejlcu690005l8jxlf1sgrrx","tag_id":"cjejlcu84001ml8jxt41iocwr","_id":"cjejlcu87001sl8jxv937nm19"},{"post_id":"cjejlcu6c0006l8jxtq0dq8q5","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu89001vl8jx00rzvrhu"},{"post_id":"cjejlcu6c0006l8jxtq0dq8q5","tag_id":"cjejlcu87001rl8jxkehv5ncd","_id":"cjejlcu89001wl8jxi6x1is11"},{"post_id":"cjejlcu6c0006l8jxtq0dq8q5","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8a001yl8jx8wzkur4n"},{"post_id":"cjejlcu6i0009l8jxivdky4cf","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8c0022l8jxua7qopkt"},{"post_id":"cjejlcu6i0009l8jxivdky4cf","tag_id":"cjejlcu87001rl8jxkehv5ncd","_id":"cjejlcu8c0023l8jxrix1mm0m"},{"post_id":"cjejlcu6i0009l8jxivdky4cf","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8d0025l8jxe64vb9ia"},{"post_id":"cjejlcu6i0009l8jxivdky4cf","tag_id":"cjejlcu84001ml8jxt41iocwr","_id":"cjejlcu8d0026l8jx6dukjg8e"},{"post_id":"cjejlcu6m000al8jxsoy8kfkv","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8g0029l8jxfopozdfp"},{"post_id":"cjejlcu6m000al8jxsoy8kfkv","tag_id":"cjejlcu87001rl8jxkehv5ncd","_id":"cjejlcu8g002al8jx4c2bcauy"},{"post_id":"cjejlcu6m000al8jxsoy8kfkv","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8h002cl8jx8hs4ljrl"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8k002il8jxctdj5hwi"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu87001rl8jxkehv5ncd","_id":"cjejlcu8k002jl8jxl0lludn0"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8k002ll8jxtpv4vi4r"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu8i002el8jxfmypm9yg","_id":"cjejlcu8l002ml8jxi0qvnmk1"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu8i002fl8jxwykppjfa","_id":"cjejlcu8m002ol8jxwkzve3pr"},{"post_id":"cjejlcu6w000el8jxigjvplbr","tag_id":"cjejlcu8j002gl8jx71anrolp","_id":"cjejlcu8m002pl8jxvp0hvwcg"},{"post_id":"cjejlcu6z000gl8jxzwhcu9yj","tag_id":"cjejlcu8j002hl8jxxim4rb0b","_id":"cjejlcu8n002rl8jxugsmmz3u"},{"post_id":"cjejlcu6z000gl8jxzwhcu9yj","tag_id":"cjejlcu8k002kl8jx81h8joz5","_id":"cjejlcu8o002sl8jxapwsnxq4"},{"post_id":"cjejlcu7a000ll8jxs52zonmm","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8q002wl8jxo5rsnwwc"},{"post_id":"cjejlcu7a000ll8jxs52zonmm","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8q002xl8jxyvygb9ov"},{"post_id":"cjejlcu7a000ll8jxs52zonmm","tag_id":"cjejlcu8o002tl8jxdd9uxeif","_id":"cjejlcu8r002zl8jx1zk2kj3r"},{"post_id":"cjejlcu7a000ll8jxs52zonmm","tag_id":"cjejlcu8p002ul8jxgk37eb21","_id":"cjejlcu8r0030l8jxsqh748y1"},{"post_id":"cjejlcu7c000ml8jxtpymxerh","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8u0034l8jxzpacb58v"},{"post_id":"cjejlcu7c000ml8jxtpymxerh","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8u0035l8jxw2vtodwe"},{"post_id":"cjejlcu7c000ml8jxtpymxerh","tag_id":"cjejlcu8o002tl8jxdd9uxeif","_id":"cjejlcu8v0037l8jxqnsvqzsc"},{"post_id":"cjejlcu7c000ml8jxtpymxerh","tag_id":"cjejlcu8p002ul8jxgk37eb21","_id":"cjejlcu8v0038l8jx09uwihwo"},{"post_id":"cjejlcu7f000ql8jxwoovofx8","tag_id":"cjejlcu7z001cl8jxkceo0wx5","_id":"cjejlcu8x003cl8jxa23xy87g"},{"post_id":"cjejlcu7f000ql8jxwoovofx8","tag_id":"cjejlcu81001il8jx4cl5bee8","_id":"cjejlcu8x003dl8jxu5jsn3q0"},{"post_id":"cjejlcu7f000ql8jxwoovofx8","tag_id":"cjejlcu8o002tl8jxdd9uxeif","_id":"cjejlcu8z003fl8jxg64s3pcg"},{"post_id":"cjejlcu7f000ql8jxwoovofx8","tag_id":"cjejlcu8p002ul8jxgk37eb21","_id":"cjejlcu8z003gl8jxswewryzh"},{"post_id":"cjejlcu7h000rl8jxz40rvt8t","tag_id":"cjejlcu8x003bl8jxh58x43kv","_id":"cjejlcu90003il8jx8nupeqm7"},{"post_id":"cjejlcu7h000rl8jxz40rvt8t","tag_id":"cjejlcu8y003el8jxrmxvzfqn","_id":"cjejlcu90003jl8jx7p2z5eqn"},{"post_id":"cjejlcu7h000rl8jxz40rvt8t","tag_id":"cjejlcu7e000pl8jxx66bcbj6","_id":"cjejlcu90003ll8jxpj74fvkw"},{"post_id":"cjejlcu7k000vl8jxz5uha1l6","tag_id":"cjejlcu8x003bl8jxh58x43kv","_id":"cjejlcu92003ol8jxxvjv6u7l"},{"post_id":"cjejlcu7k000vl8jxz5uha1l6","tag_id":"cjejlcu90003kl8jxsm66jcsl","_id":"cjejlcu92003pl8jxwdhvl8kc"},{"post_id":"cjejlcu7k000vl8jxz5uha1l6","tag_id":"cjejlcu8y003el8jxrmxvzfqn","_id":"cjejlcu93003rl8jx68ecldfv"},{"post_id":"cjejlcu7n000yl8jxrvsktl0x","tag_id":"cjejlcu8x003bl8jxh58x43kv","_id":"cjejlcu93003sl8jxpil9jvjv"},{"post_id":"cjejlcu7n000yl8jxrvsktl0x","tag_id":"cjejlcu7e000pl8jxx66bcbj6","_id":"cjejlcu96003ul8jxyq113ja0"},{"post_id":"cjejlcu7s0013l8jx8uuk5b59","tag_id":"cjejlcu8x003bl8jxh58x43kv","_id":"cjejlcu97003vl8jxayrn2gv7"},{"post_id":"cjejlcu7s0013l8jx8uuk5b59","tag_id":"cjejlcu8y003el8jxrmxvzfqn","_id":"cjejlcu97003wl8jxaeomtr2z"},{"post_id":"cjejlcu7s0013l8jx8uuk5b59","tag_id":"cjejlcu7e000pl8jxx66bcbj6","_id":"cjejlcu97003xl8jxn9qmxml0"}],"Tag":[{"name":"lucas556","_id":"cjejlcu640003l8jx3dst6vvt"},{"name":"矿机","_id":"cjejlcu6e0008l8jxm03463a9"},{"name":"zcash","_id":"cjejlcu76000kl8jxf2poeoyu"},{"name":"矿池","_id":"cjejlcu7e000pl8jxx66bcbj6"},{"name":"ZhouFyk","_id":"cjejlcu7z001cl8jxkceo0wx5"},{"name":"以太坊","_id":"cjejlcu81001il8jx4cl5bee8"},{"name":"ethereum","_id":"cjejlcu84001ml8jxt41iocwr"},{"name":"区块链","_id":"cjejlcu87001rl8jxkehv5ncd"},{"name":"燃料","_id":"cjejlcu8i002el8jxfmypm9yg"},{"name":"gas","_id":"cjejlcu8i002fl8jxwykppjfa"},{"name":"翻译","_id":"cjejlcu8j002gl8jx71anrolp"},{"name":"ciscolxh","_id":"cjejlcu8j002hl8jxxim4rb0b"},{"name":"钱包","_id":"cjejlcu8k002kl8jx81h8joz5"},{"name":"智能合约","_id":"cjejlcu8o002tl8jxdd9uxeif"},{"name":"安全开发","_id":"cjejlcu8p002ul8jxgk37eb21"},{"name":"LeonBCK","_id":"cjejlcu8x003bl8jxh58x43kv"},{"name":"比特币","_id":"cjejlcu8y003el8jxrmxvzfqn"},{"name":"bitcoin","_id":"cjejlcu90003kl8jxsm66jcsl"}]}}