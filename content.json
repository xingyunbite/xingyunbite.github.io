{"meta":{"title":"星云比特","subtitle":null,"description":null,"author":"xingyunbite","url":"http://xingyunbite.github.com"},"pages":[],"posts":[{"title":"比特币挖矿之全网难度","slug":"比特币挖矿之全网难度","date":"2018-02-09T20:24:39.000Z","updated":"2018-02-09T10:07:34.484Z","comments":false,"path":"2018/02/09/比特币挖矿之全网难度/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/比特币挖矿之全网难度/","excerpt":"","text":"2018年2月7日，比特币全网难度再次提升10.43%，而这对于正经历币价大跌的矿工来说，挖矿难度的提升，意味着挖矿收益进一步下降。那么在比特币系统中，挖矿难度究竟是如何调整的呢？ 难度表示上文中提到，矿工在打包区块的时候，合格的区块应该满足:1SHA256(SHA256(BlockHeader))&lt;F(nBits) 这儿的nBits正是难度的一种压缩表达方式。前两位十六进制数字为幂(bits_exponent),后六位为系数(bits_coefficient)1current_target = bits_coefficient * 2^(8 * (bits_exponent-3)) 以508230区块为例，此区块对应的bits为0x1761e9f8123current_target = 0x61e9f8 *2^(0x08*(0x17-3)) = 0x61e9f8 *2^(0x08*0x14) = 0x61e9f8 *2^0xA0 按十进制计算为:1current_target = 6,416,888 * 2^160 转换为十六进制后为:1current_target =0x00000000000000000061e9f80000000000000000000000000000000000000000 而记录到区块链上的该高度对应的区块头的hash值为0000000000000000003692a92ed937e4e0a5f247e27feeeb4df383e6d9c2bd94,满足要求。 创世区块的bits值在代码中是写死的，具体代码如下:1genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN); 其中各参数含义如下:1231006505:时间戳，对应北京时间:2009/1/4 2:15:52083236893:nNonce,随机数0x1d00ffff:bits,难度的压缩表示1:版本号50:区块奖励数 难度调整上面提到，比特币的挖矿难度是可调整的，那么这个难度为什么需要调整？由谁来调整？如何调整？ 比特币系统平均每10分钟生成一个区块，而全网的算力是变化的，为了应对全网算力可能在一定时间内发生暴增或者骤减的情况，保持每10分钟产生一个新区块的产生速率，比特币采用这样一种难度调整机制:每2016个区块，所有节点调整一次难度，难度的调整公式如下：1New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes) 通过上述公式，比特币系统便能实现当区块产生速率比10分钟要快时，增加难度。如果发现比10分钟慢时，则降低难度。当然这种调整无法及时应对币价暴跌导致全网算力骤减的情况。 在矿工每次打包新的区块的时候，会对下一个区块的高度进行判断1、当高度不是2016的倍数时，会直接返回上一个区块的bit2、当高度是2016的倍数时，会根据上面提到的难度调整公式进行计算。 为了防止难度的变化过快，每隔周期的调整幅度必须有一定的限制。如果调整幅度大于4倍，则按4倍调整，因此当难度变化过快时，可能要经过几个2016区块周期才会完成。","categories":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}],"tags":[{"name":"bitcoin 比特币","slug":"bitcoin-比特币","permalink":"http://xingyunbite.github.com/tags/bitcoin-比特币/"}],"keywords":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}]},{"title":"以太坊wiki-设计原理翻译一","slug":"以太坊wiki-设计原理翻译一","date":"2018-02-09T19:22:26.000Z","updated":"2018-02-09T10:08:28.046Z","comments":false,"path":"2018/02/09/以太坊wiki-设计原理翻译一/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/以太坊wiki-设计原理翻译一/","excerpt":"","text":"设计原理原文链接尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。 原则以太坊协议的设计过程遵循了下列原则： 三明治复杂模型：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，leveldb存储接口和有线协议等。但是，这种偏好并不是绝对的。 自由：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 OP_RETURN 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 Ethereum 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（bloat-producing）的方式内部化其活动成本（即 Pigovian 税）。 概念：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 LOG 操作码作为向（特别是轻客户端）dapps 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。 我们没有特征：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。 非风险规避：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。 这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。 区块链层次的协议这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。 账户和非 UTXOs比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 unspent transaction outputs(UTXOs) 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有： 每一个被引用的输入必须是合法的并且没有被花费过 交易中的每一个输入都必须有一个符合该输入的主人的签名 所有的输入必须大于等于所有的输出 因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。 (图片来自 https://bitcoin.org/en/developer-guide) 以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。 UTXOs 的好处： 高度的隐私性：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 dapps 就不是那么合适了，因为 dapps 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。 潜在的可扩展性范例：UTXO 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 Merkle 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 Merkle 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 UTXO 依赖的可伸缩性范例确实存在。 账户的好处： 节省了大量空间：例如，如果一个账户有 5 个 UTXO，然后将一个 UTXO 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 txid，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 nonce)。实际上，要求的存储空间没有这么大，因为账户需要存储在 Patricia 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。 更好的可替代性：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。 简单：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 UTXO 模型来实现 dapp，但本质上是通过赋予脚本能力，来限制给定的 UTXO 可以以哪种 UTXO 类型来花费，并且需要花费包括根据脚本评估的 Merkle 树中的应用程序状态改变的证明的 Merkle 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。 持久的轻客户端引用：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 UTXO 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 UTXO 状态传播机制的长期运行的 dapps 来说，这是一个特别麻烦的问题。 我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 dapps 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。 账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 nonce 值，这样账户就可以对使用的 nonce 进行跟踪，并且只接受当前 nonce 值比之前的 nonce 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 nonce。矿工或者其他用户会对账户进行 ping 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 1.0 的发展; 1.1 及以后可能会使用这样一个系统。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"以太坊 ethereum","slug":"以太坊-ethereum","permalink":"http://xingyunbite.github.com/tags/以太坊-ethereum/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"以太坊wiki-设计原理翻译二","slug":"以太坊wiki-设计原理翻译二","date":"2018-02-09T10:10:31.000Z","updated":"2018-02-09T10:38:44.211Z","comments":false,"path":"2018/02/09/以太坊wiki-设计原理翻译二/","link":"","permalink":"http://xingyunbite.github.com/2018/02/09/以太坊wiki-设计原理翻译二/","excerpt":"","text":"以太坊wiki-设计原理翻译一 默克尔帕夏里克树默克尔帕夏里克树（Merkle Patricia tree/trie），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。MPT 是 Merkle tree 和 Patricia tree 的结合，以两者的元素来创建具有以下两个属性的结构： 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力） 在对数时间对进行修改，添加和删除键值对。 这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 MPT 是正式描述如下：https://github.com/ethereum/wiki/wiki/Patricia-Tree MPT 中详细的设计决定包括： 拥有两种节点类别：kv 节点和分叉节点（从 MPT 详解中获得更多信息）。kv 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，kv 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。 使分叉节点为 6 而不是 2：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 1.1。 空值和“没有成员”之间没有区别：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。 终止和非终止节点之间的区别：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 MPT 的实现方式。 使用 sha3(k) 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 SLOAD 和 SSTORE」这样的方式，对树进行 DoS 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 sha3（k） - &gt; k。 RLPRLP（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。RLP 的正式描述如下：https://github.com/ethereum/wiki/wiki/RLP RLP 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 protobuf，BSON 和其他解决方式，RLP 并不想定义任何具体的数据类型，如 booleans, floats, doubles 或者 integers，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为[[k1，v1]，[k2，v2]，...]，其中 k1，k2 ... 使用字符串的标准排序来排序。 RLP 的备选方案可以使用已经存在的算法如 protobuf 或者 BSON，但我们更青睐 RLP 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 VM）。注意 BitTorrent 使用的 bencode，可能为 RLP 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 RLP 相比稍微不太理想。 压缩算法有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（run-length-encoding zeroes），并保留其他值，除了像 sha3（&#39;&#39;） 这样的常见值的一些特殊情况例外。例如： 1234567&gt;&gt;&gt; compress(&apos;horse&apos;)&apos;horse&apos;&gt;&gt;&gt; compress(&apos;donkey dragon 1231231243&apos;)&apos;donkey dragon 1231231243&apos;&gt;&gt;&gt; compress(&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;)&apos;\\xf8\\xaf\\xf8\\xab\\xa0\\xfe\\x9e\\xbe&#123;b\\xd5\\xcd\\x8d\\x87\\x97&apos;&gt;&gt;&gt; compress(&quot;\\xc5\\xd2F\\x01\\x86\\xf7#&lt;\\x92~&#125;\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6S\\xca\\x82&apos;;&#123;\\xfa\\xd8\\x04]\\x85\\xa4p&quot;)&apos;\\xfe\\x01&apos; 在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，sha3 常常被覆盖，这样 sha3(&#39;&#39;)=&#39;&#39;，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}],"tags":[{"name":"区块链 以太坊 ethereum","slug":"区块链-以太坊-ethereum","permalink":"http://xingyunbite.github.com/tags/区块链-以太坊-ethereum/"}],"keywords":[{"name":"区块链","slug":"区块链","permalink":"http://xingyunbite.github.com/categories/区块链/"}]},{"title":"linux下Zcash钱包使用教程","slug":"linux下Zcash钱包使用教程","date":"2018-02-09T03:04:15.000Z","updated":"2018-02-09T10:09:48.544Z","comments":false,"path":"2018/02/08/linux下Zcash钱包使用教程/","link":"","permalink":"http://xingyunbite.github.com/2018/02/08/linux下Zcash钱包使用教程/","excerpt":"","text":"Zcash (ZEC)是首个使用零知识证明机制的区块链系统，它可提供完全的支付保密性，同时仍能够使用公有区块链来维护一个去中心化网络。与比特币相同的是，Zcash代币（ZEC）的总量也是2100万，不同之处在于，Zcash交易自动隐藏区块链上所有交易的发送者、接受者及数额。只用那些拥有查看秘钥的人才能看到交易的内容。用户拥有完全的控制权，他们可自行选择向其他人提供查看秘钥. ZCash 是 bitcoin 的分支，保留了 bitcoin 原有的模式，基于比特币 0.11.2 版代码修改的。 ZCash 钱包资金分 2 种：透明资金、私有资金，透明资金类似比特币资金；私有资金加强了 隐私性，涉及到私有资金的交易是保密不可查的，透明资金与透明资金的交易是公开可查的. 目前Zcash流通市值在12亿美元左右，每日交易额也高达1亿美元，其使用zero-knowledge proof（零知识证明）使得数字化货币更加具有安全性；隐私性而备受市场关注。 现在zcash官方提供的钱包是linux版本的，而原因是zcash团队没人熟悉gui，不过zcash官方提供了编译后的可执行程序，这里也不用我们来进行编译了。 下载地址 ： https://z.cash/downloads/zcash-1.0.14-linux64.tar.gzhash : 352ea2a67ae3484046a6bd43af9a5ce125e2d103a6a32ac71805658918f7076a 下载后请务必进行哈希值验证，以保证文件的真实和准确性。 tar -xvf zcash-1.0.14-linux64.tar.gz //解压缩mv -t /usr/local/bin/ zcash-1.0.14/bin/* //移动可执行文件 现在我们已经安装了zcash，运行下面的命令下载 key ，用于创建和验证参数。 zcash-fetch-params 这里由于国内网络的原因，可能会失败，请多试几次。 验证通过后，我们需要对客户端进行配置。 mkdir ~/.zcash //创建zcash目录 vim zcash.conf 以上按照个人配置的不同，设置不同的配置文件，下面提供一个配置供参考。 //这是测试链接的配置 addnode=testnet.z.cash //节点 rpcuser=test //rpc用户名 rpcpassword=test //rpc密码 gen=0 //屏蔽cpu挖矿 testnet=1 //开启测试链 rpcallowip=100.100.60.10 //允许访问的IP rpcport=8333 //rpc端口号 equihashsolver=tromp //指定算法，非挖矿钱包可以删除 好了，保存后输入zcashd就可以启动zcash客户端了，也可以使用zcashd -daemon在后台运行zcash客户端,在shell输入zcash-cli getinfo命令就可以看到网络和块信息了。 下面提供一些zcash节点常用命令： zcash-cli getinfo //显示节点信息 zcashd -daemon //后台启动zcash守护 zcash-cli getnetworkhashps //获取全网算力 zcash-cli z_getnewaddress //生成一个Z-addr zcash-cli getnewaddress //生成一个t-addr zcas-cli getblockhash //区块高度 zcash-cli getaddressesbyaccount &quot;&quot; //显示所有t-addr钱包 zcash-cli z_listaddresses //显示所有Z-addr钱包 zcash-cli z_getbalance &quot;&quot; //z钱包余额 如果有其他的需要，可以使用zcash-cli help来查看zcash的全部命令。 附1： zcash钱包配置： //这里是zcash钱包主链配置 rpcuser=rpc用户名 rpcpassword=rpc密码 rpcport=rpc端口 rpcallowip=允许链接rpc ip地址 server=1 //打开服务 daemon=1 //后台运行守护 mainnet=1 //主链 addnode=mainnet.z.cash //主链节点 附2： //zcash命令 == Blockchain == getbestblockhash getblock &quot;hash|height&quot; ( verbose ) getblockchaininfo getblockcount getblockhash index getblockheader &quot;hash&quot; ( verbose ) getchaintips getdifficultygetmempoolinfogetrawmempool ( verbose ) gettxout “txid” n ( includemempool ) gettxoutproof [“txid”,…] ( blockhash ) gettxoutsetinfo verifychain ( checklevel numblocks ) verifytxoutproof “proof” == Control == getinfo help ( &quot;command&quot; ) stop == Disclosure == z_getpaymentdisclosure &quot;txid&quot; &quot;js_index&quot; &quot;output_index&quot; (&quot;message&quot;) z_validatepaymentdisclosure &quot;paymentdisclosure&quot; == Generating == generate numblocks getgenerate setgenerate generate ( genproclimit ) == Mining == getblocksubsidy height getblocktemplate ( &quot;jsonrequestobject&quot; ) getlocalsolps getmininginfo getnetworkhashps ( blocks height ) getnetworksolps ( blocks height ) prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt; submitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; ) == Network == addnode &quot;node&quot; &quot;add|remove|onetry&quot; clearbanned disconnectnode &quot;node&quot; getaddednodeinfo dns ( &quot;node&quot; ) getconnectioncount getnettotals getnetworkinfo getpeerinfo listbanned ping setban &quot;ip(/netmask)&quot; &quot;add|remove&quot; (bantime) (absolute) == Rawtransactions == createrawtransaction [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n},...] {&quot;address&quot;:amount,...} decoderawtransaction &quot;hexstring&quot; decodescript &quot;hex&quot; fundrawtransaction &quot;hexstring&quot; getrawtransaction &quot;txid&quot; ( verbose ) sendrawtransaction &quot;hexstring&quot; ( allowhighfees ) signrawtransaction &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;},...] [&quot;privatekey1&quot;,...] sighashtype ) == Util == createmultisig nrequired [&quot;key&quot;,...] estimatefee nblocks estimatepriority nblocks validateaddress &quot;zcashaddress&quot; verifymessage &quot;zcashaddress&quot; &quot;signature&quot; &quot;message&quot; z_validateaddress &quot;zaddr&quot; == Wallet == addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; ) backupwallet &quot;destination&quot; dumpprivkey &quot;zcashaddress&quot; dumpwallet &quot;filename&quot; encryptwallet &quot;passphrase&quot; getaccount &quot;zcashaddress&quot; getaccountaddress &quot;account&quot; getaddressesbyaccount &quot;account&quot; getbalance ( &quot;account&quot; minconf includeWatchonly ) getnewaddress ( &quot;account&quot; ) getrawchangeaddress getreceivedbyaccount &quot;account&quot; ( minconf ) getreceivedbyaddress &quot;zcashaddress&quot; ( minconf ) gettransaction &quot;txid&quot; ( includeWatchonly ) getunconfirmedbalance getwalletinfo importaddress &quot;address&quot; ( &quot;label&quot; rescan ) importprivkey &quot;zcashprivkey&quot; ( &quot;label&quot; rescan ) importwallet &quot;filename&quot; keypoolrefill ( newsize ) listaccounts ( minconf includeWatchonly) listaddressgroupings listlockunspent listreceivedbyaccount ( minconf includeempty includeWatchonly) listreceivedbyaddress ( minconf includeempty includeWatchonly) listsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly) listtransactions ( &quot;account&quot; count from includeWatchonly) listunspent ( minconf maxconf [&quot;address&quot;,...] ) lockunspent unlock [{&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n},...] move &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; ) sendfrom &quot;fromaccount&quot; &quot;tozcashaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; ) sendmany &quot;fromaccount&quot; {&quot;address&quot;:amount,...} ( minconf &quot;comment&quot; [&quot;address&quot;,...] ) sendtoaddress &quot;zcashaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; subtractfeefromamount ) setaccount &quot;zcashaddress&quot; &quot;account&quot; settxfee amount signmessage &quot;zcashaddress&quot; &quot;message&quot; z_exportkey &quot;zaddr&quot; z_exportviewingkey &quot;zaddr&quot; z_exportwallet &quot;filename&quot; z_getbalance &quot;address&quot; ( minconf ) z_getnewaddress z_getoperationresult ([&quot;operationid&quot;, ... ]) z_getoperationstatus ([&quot;operationid&quot;, ... ]) z_gettotalbalance ( minconf includeWatchonly ) z_importkey &quot;zkey&quot; ( rescan startHeight ) z_importviewingkey &quot;vkey&quot; ( rescan startHeight ) z_importwallet &quot;filename&quot; z_listaddresses ( includeWatchonly ) z_listoperationids z_listreceivedbyaddress &quot;address&quot; ( minconf ) z_sendmany &quot;fromaddress&quot; [{&quot;address&quot;:... ,&quot;amount&quot;:...},...] ( minconf ) ( fee ) z_shieldcoinbase &quot;fromaddress&quot; &quot;tozaddress&quot; ( fee ) ( limit ) zcbenchmark benchmarktype samplecount zcrawjoinsplit rawtx inputs outputs vpub_old vpub_new zcrawkeygen zcrawreceive zcsecretkey encryptednote zcsamplejoinsplit","categories":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}],"tags":[{"name":"zcash 矿池","slug":"zcash-矿池","permalink":"http://xingyunbite.github.com/tags/zcash-矿池/"}],"keywords":[{"name":"矿池","slug":"矿池","permalink":"http://xingyunbite.github.com/categories/矿池/"}]}]}