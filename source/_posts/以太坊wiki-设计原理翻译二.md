---
title: 以太坊wiki-设计原理翻译二
comments: true
date: 2018-02-09 02:10:31
categories: 区块链
tags: 
- ZhouFyk 
- 区块链 
- 以太坊 
- ethereum
img:
---

[以太坊wiki-设计原理翻译一](https://xingyunbite.github.io/2018/02/09/%E4%BB%A5%E5%A4%AA%E5%9D%8Awiki-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%BF%BB%E8%AF%91%E4%B8%80/)

## 默克尔帕夏里克树

默克尔帕夏里克树（`Merkle Patricia tree/trie`），以前由 Alan Reiner 设想并在 Ripple 协议中实现，是以太坊中的基本数据结构，被用来存储所有的账户状态，以及区块中的交易和收据。`MPT` 是 `Merkle tree` 和 `Patricia tree` 的结合，以两者的元素来创建具有以下两个属性的结构：

1. 每一组唯一的键/值对唯一地映射到一个根散列，并且不可能欺骗一棵树中的键/值对的成员（除非攻击者具有〜2 ^ 128 的计算能力）
2. 在对数时间内进行修改，添加和删除键值对。

这为我们提供了一种高效、更新容易的方法，来对我们整个状态树进行“指纹”操作。以太坊 `MPT` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/Patricia-Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree)

`MPT` 中详细的设计决定包括：

1. **拥有两种节点类别**：`kv` 节点和分叉节点（从 `MPT` 详解中获得更多信息）。`kv` 节点的存在提高了效率，因为如果一棵树在特定区域稀疏，`kv` 节点就可以作为“快捷方式”，从而不需要深度为 64 的树。
2. **使分叉节点为 6 而不是 2**：这是为了提升查找效率。我们现在认识到这个选择并不理想，因为可以通过存储批量节点，以二进制模式模拟六叉树的查找效率。然而，由于树结构在实现中很容易出现错误，而导致根不匹配，所以我们决定把它推迟到 `1.1`。
3. **空值和“没有成员”之间没有区别**：这是为了简单起见，并且因为以太坊的默认值通常意味着零（如 余额（balance）），而且空字符串被用来表示零，所以实际运行起来也没有任何问题。
4. **终止和非终止节点之间的区别**：从技术上讲，“这个节点终止”标志是不必要的，因为以太坊中的所有树都用来存储静态键长度，但是为了增加通用性，我们添加了它，并且希望其他加密协议也能够使用以太坊中 `MPT` 的实现方式。
5. **使用 `sha3(k)` 作为 “安全树（secure tree）” 中的键（在状态和账户存储中使用）**：这会使得「通过设置一个分叉了 64 层级深的节点的最大不利链，然后在这上面不断调用 `SLOAD` 和 `SSTORE`」这样的方式，对树进行 `DoS` 攻击会十分困难。同时请注意，这将使枚举树更加困难。 如果你想在你的客户端拥有枚举功能，最简单的方法是维护一个数据库映射 `sha3（k） - > k`。

## RLP

`RLP`（递归长度前缀）编码是以太坊中使用的主要序列化格式，并且被使用于任何地方 - 区块，交易，账户状态和信息传递协议。`RLP` 的正式描述如下：[https://github.com/ethereum/wiki/wiki/RLP](https://github.com/ethereum/wiki/wiki/RLP)

`RLP` 旨在成为高度简约的序列化格式，它唯一的目的是存储嵌套的字节数组。不像 [`protobuf`](https://developers.google.com/protocol-buffers/docs/pythontutorial)，[`BSON`](http://bsonspec.org/) 和其他解决方式，`RLP` 并不想定义任何具体的数据类型，如 `booleans, floats, doubles` 或者 `integers`，相反，它只是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。键/值映射也不被明确支持; 支持键/值映射的半官方建议是将这些映射表示为`[[k1，v1]，[k2，v2]，...]`，其中 `k1，k2 ...` 使用字符串的标准排序来排序。

`RLP` 的备选方案可以使用已经存在的算法如 `protobuf` 或者 `BSON`，但我们更青睐 `RLP` 的原因是：(1) 实现方式简单。（2）保证绝对的字节完美一致性。许多语言中的键/值映射没有明确的顺序，浮点格式有许多特殊情况，这可能导致相同的数据使用不同的编码，因此产生不同的哈希。我们可以内部开发一个协议来确定解决这些问题（这是一个普遍的原则，也适用于代码的其他部分，例如 `VM`）。注意 `BitTorrent` 使用的 `bencode`，可能为 `RLP` 提供了一个可行的替代方案，尽管其使用十进制编码的长度使得它与二进制 `RLP` 相比稍微不太理想。

## 压缩算法

有线协议和数据库都使用了定制的压缩算法来存储数据。该算法最好的描述为运行长度编码零（`run-length-encoding zeroes`），并保留其他值，除了像 `sha3（''）` 这样的常见值的一些特殊情况例外。例如：

```
>>> compress('horse')
'horse'
>>> compress('donkey dragon 1231231243')
'donkey dragon 1231231243'
>>> compress('\xf8\xaf\xf8\xab\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbe{b\xd5\xcd\x8d\x87\x97')
'\xf8\xaf\xf8\xab\xa0\xfe\x9e\xbe{b\xd5\xcd\x8d\x87\x97'
>>> compress("\xc5\xd2F\x01\x86\xf7#<\x92~}\xb2\xdc\xc7\x03\xc0\xe5\x00\xb6S\xca\x82';{\xfa\xd8\x04]\x85\xa4p")'\xfe\x01'
			```

在压缩算法出现之前，以太坊协议中的很多部分都有大量的特殊情况。比如，`sha3` 常常被覆盖，这样 `sha3('')=''`，从而无需存储代码或者在账户中存储，由此会节省 64 个字节。但是，最近所有的这些特殊情况都被移除了 - 这使得以太坊数据结构在默认情况下变得非常庞大，取而代之的是将数据保存功能添加到区块链协议层之外的层级，添加方式是将其利用有线协议无缝插入用户的数据库实现。 这增加了模块性，简化了共识层，并且还允许相对容易地部署压缩算法的升级（例如，通过网络协议版本）。
