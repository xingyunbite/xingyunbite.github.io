---
title: 以太坊wiki-设计原理翻译一
comments: false
date: 2018-02-09 11:22:26
categories: 区块链
tags: 以太坊 ethereum
img:
---
## [设计原理原文链接](https://github.com/ethereum/wiki/wiki/Design-Rationale)

尽管以太坊借鉴了许多已经在比特币这样的老式加密货币中经过了5年的尝试和测试的想法，但是以太坊在处理某些协议特征方面与常见方式有很多不同之处，因为目前现存的系统中没有以太坊需要的功能，所以以太坊另外开发了全新的功能。本文档的目的是详细说明在制定以太坊协议过程中所做出的所有可能不明显的或有些有争议的决定，以及显示我们的方法和可能的替代方案所涉及的风险。

## 原则

以太坊协议的设计过程遵循了下列原则：

1. **三明治复杂模型**：我们相信以太坊结构的底层应该尽可能的简单，并且与以太坊的交互接口（包括开发者使用的高级编程语言以及用户的使用界面）应该尽可能的易懂。在复杂性不可避免的情况下，它应该被推入协议的“中间层”，它们不是核心共识的一部分，但也不被终端用户看到，如高级语言编译器，参数序列化和反序列化脚本，存储 数据结构模型，`leveldb`存储接口和有线协议等。但是，这种偏好并不是绝对的。

2. **自由**：用户在使用以太坊协议的时候不应该被限制，我们也不应该试图去表示喜欢或者不喜欢他们基于某种目的而使用的以太坊合约或者交易。这类似于和“网络中立”背后的指导原则。一个没有遵循此原则的例子是比特币交易协议中的情况，它不鼓励使用区块链来做“非标签”（如数据存储，元协议）目的的行为，并且在某些情况下明确了对准协议的改变（如 `OP_RETURN` 限制为 40 字节），试图以“未授权”方式使用区块链来攻击应用。在 `Ethereum` 中，我们强烈支持设置交易费用，这样大致上就会具有激励作用，这样，使用区块链的用户会以膨胀（`bloat-producing`）的方式内部化其活动成本（即 `Pigovian` 税）。

3. **概念**：以太坊中的协议特征和操作码应该体现最低级别的概念，以便可以以任意的方式进行组合，包括今天可能看起来不太有用但以后可能会变得有用的方法，然后当这些概念对于使用了这些概念的功能来说不再必要的时候，就可以通过剥离它们来提升效率。遵循这个原则的一个例子是我们选择 `LOG` 操作码作为向（特别是轻客户端）`dapps` 提供信息的一种方式，而不是像之前建议的那样在内部简单地记录所有事务和消息 - “消息”的概念是包括“方法调用”和“外部观察者感兴趣的事件”在内的多个概念的聚集，理应分离这两个概念。

4. **我们没有特征**：作为泛化的必然结果，我们常常拒绝将十分常见的高级使用示例作为协议的一部分，我们认为如果人们真的需要做一件事情，那么他可以在一个合约内部创建一个子协议。一个例子是以太坊中缺少与比特币中一样“锁定时间”的功能，因为这样的功能可以通过用户发送“签名数据包”协议来模拟，然后这些数据包可以被输入到专门的合同中处理，并且如果数据包符合合同的一些条件，就会触发相应的功能。

5. **非风险规避**：如果风险增加的变化提供了非常可观的收益（例如，广义的状态转换，50倍的更快的阻塞时间，共识效率等），那么我们可以承受更高的风险程度。

这些原则在规定以太坊开发中都涉及到，但它们并不是绝对的，在某些情况下，为了减少开发时间或者避免一次性尝试太多激进的东西，我们会推迟某些明显有利的变革，以便将来发行（如以太坊1.1）。

## 区块链层次的协议

这部分描述了以太坊中对区块链层次协议所做的一些改变，包括了区块和交易是如何工作的，数据是如何序列化和存储的，以及账户背后的机制。

### 账户和非 `UTXOs`

比特币，以及许多由它衍生而来的系统，将用户的资产数据存储在一个基于 `unspent transaction outputs(UTXOs)` 的结构中：整个系统的状态由一系列未花费输出（联想成“币”）组成，所以每个币都有一个主人和面值，而一笔交易可以花费一个或更多的币并且创建一个或更多的币，有效性的约束有：

1. 每一个被引用的输入必须是合法的并且没有被花费过
2. 交易中的每一个输入都必须有一个符合该输入的主人的签名
3. 所有的输入必须大于等于所有的输出

因此，系统中用户的“余额”是用户具有能够产生有效签名的私钥的一组硬币的总值。

![](https://bitcoin.org/img/dev/en-transaction-propagation.svg)

(图片来自 `https://bitcoin.org/en/developer-guide`)

以太坊抛弃这个方案，转而采用更简单的方法：使用状态存储一个账户列表，其中每个账户都有一个余额，以及以太坊特定的数据（代码和内部存储）。一笔交易会在发送账户有足够的余额支付的情况下生效，此时，发送账户减少余额，收款账户增加余额。如果接收账户有代码，代码会运行，而内部存储也可能被更改，或者代码甚至可能会创建额外的消息给其他账户，从而导致进一步的余额变更。

`UTXOs` 的好处：

1. **高度的隐私性**：如果用户接受每笔交易的时候都使用一个新地址，那么就很难将账户连接起来。这很适用于货币，但是对任意 `dapps` 就不是那么合适了，因为 `dapps` 常常需要对用户的一系列复杂的状态保持跟踪，并且可能不存在像货币那样简单的用户状态分区方案。
2. **潜在的可扩展性范例**：`UTXO` 在理论上更与某些可扩展性模式相兼容，因为我们只能依靠一些拥有 `Merkle` 所有权证明的币的所有者，即使包括所有者在内的每个人都决定忘记这些数据，只有所有者受到损害( and even if everyone including the owner decides to forget that data then only the owner is harmed)。 在一个账户范例中，一旦某个人失去其账户对应的部分 `Merkle` 树，将使得不可能以任何方式处理该账户相关的消息，包括发送给它。 但是，非 `UTXO` 依赖的可伸缩性范例确实存在。

账户的好处：

1. **节省了大量空间**：例如，如果一个账户有 5 个 `UTXO`，然后将一个 `UTXO` 模型转换成账户模型，它的空间要求就会从 （20 + 32 + 8）* 5 = 300 bytes(20 是地址，32 是 `txid`，8 是值)减少到 20 + 8 + 2 = 30 bytes(20 是地址，8 是值，2 是 `nonce`)。实际上，要求的存储空间没有这么大，因为账户需要存储在 `Patricia` 树中（见下文），但是它们仍然很大。（In reality savings are not nearly this massive because accounts need to be stored in a Patricia tree (see below) but they are nevertheless large. ）另外，交易可以更小（如以太坊中需要 100 bytes 而比特币中需要 200 - 250 bytes），因为每笔交易只需要使用一个引用，一个签名以及一个输出。
2. **更好的可替代性**：因为没有区块链层次的特定币来源的概念，所以从技术上和法律上来说，建立一个红名单/黑名单方案并根据它们的来源来区分币就很不现实。
3. **简单**：编码简单易懂，特别是涉及到复杂脚本的时候。虽然也可以强制使用 `UTXO` 模型来实现 `dapp`，但本质上是通过赋予脚本能力，来限制给定的 `UTXO` 可以以哪种 `UTXO` 类型来花费，并且需要花费包括根据脚本评估的 `Merkle` 树中的应用程序状态改变的证明的 `Merkle` 树的根（and requiring spends to include Merkle tree proofs of change-of-application-state-root that scripts evaluate），这样的范例比使用帐户更加复杂和难看。
4. **持久的轻客户端引用**：轻客户端可以在任何时候通过定向扫描一棵状态树来访问一个账户相关的所有数据。在 `UTXO` 模型中，每笔交易都会改变引用，这对于试图使用上面提到的 `UTXO` 状态传播机制的长期运行的 `dapps` 来说，这是一个特别麻烦的问题。

我们已经做好了决定，因为对于我们正在处理的包含任意状态和代码的 `dapps` 来说，帐户模型远比其他要好。 此外，本着“我们没有特征”原则的精神，我们认为，如果人们确实关心隐私，那么可以通过合同内的签名数据包协议来建立混淆器（mixer）和组合币（coinjoin）。

账户模型的一个缺点是，为了防止重放攻击，每笔交易都必须有一个 `nonce` 值，这样账户就可以对使用的 `nonce` 进行跟踪，并且只接受当前 `nonce` 值比之前的 `nonce` 值多 1 的交易。这意味着即使是废弃的账号也不会删除账号状态。解决这个问题的一个简单方法是要求每笔交易都包含一个区块号，使得它们在一段时期之后就不能够被重放，并且在每个时期都重置一次 `nonce`。矿工或者其他用户会对账户进行 `ping` 操作，然后删除状态中的未使用账户，因为作为区块链协议的一部分，进行全部扫描的代价太高了。我们没有用这个机制只是为了加快 `1.0` 的发展; `1.1` 及以后可能会使用这样一个系统。
